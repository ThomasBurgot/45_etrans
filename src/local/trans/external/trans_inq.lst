


NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/include
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/lib
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: trans_inq.F90

(    1) SUBROUTINE TRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    2)                     &KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    3)                     &KMYMS,KASM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    4)                     &KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    5)                     &KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    6)                     &KULTPP,KPTRLS,KNMENG,&
(    7)                     &KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    8)                     &LDSPLITLAT,&
(    9)                     &KSMAX,PLAPIN,KNVALUE,KDEF_RESOL,LDLAM,&
(   10)                     &PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KDGLU)
(   11) 
(   12) !**** *TRANS_INQ* - Extract information from the transform package
(   13) 
(   14) !     Purpose.
(   15) !     --------
(   16) !     Interface routine for extracting information from the T.P.
(   17) 
(   18) !**   Interface.
(   19) !     ----------
(   20) !     CALL TRANS_INQ(...)
(   21) !     Explicit arguments : All arguments are optional.
(   22) !     --------------------
(   23) !     KRESOL   - resolution tag for which info is required ,default is the
(   24) !                first defined resulution (input)
(   25) 
(   26) !                   MULTI-TRANSFORMS MANAGEMENT
(   27) !     KDEF_RESOL - number or resolutions defined
(   28) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   29) 
(   30) !                   SPECTRAL SPACE
(   31) !     KSPEC    - number of complex spectral coefficients on this PE






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 2

(   32) !     KSPEC2   - 2*KSPEC
(   33) !     KSPEC2G  - global KSPEC2
(   34) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   35) !     KNUMP    - Number of spectral waves handled by this PE
(   36) !     KGPTOT   - Total number of grid columns on this PE
(   37) !     KGPTOTG  - Total number of grid columns on the Globe
(   38) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   39) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   40) !     KMYMS    - This PEs spectral zonal wavenumbers
(   41) !     KASM0    - Address in a spectral array of (m, n=m)
(   42) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   43) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   44) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   45) !     KALLMS   - Wave numbers for all wave-set concatenated together
(   46) !                to give all wave numbers in wave-set order
(   47) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   48) !     KSMAX    - spectral truncation
(   49) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   50) 
(   51) !                 GRIDPOINT SPACE
(   52) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   53) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   54) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   55) !     KPTRLAT     - Pointer to the start of each latitude
(   56) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in
(   57) !                   NSTA and NONL arrays
(   58) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   59) !                   NSTA and NONL arrays
(   60) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   61) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   62) !     KSTA        - Position of first grid column for the latitudes on a
(   63) !                   processor. The information is available for all processors.
(   64) !                   The b-sets are distinguished by the last dimension of
(   65) !                   nsta().The latitude band for each a-set is addressed by
(   66) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and
(   67) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   68) !                   Each split latitude has two entries in nsta(,:) which
(   69) !                   necessitates the rather complex addressing of nsta(,:)
(   70) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   71) !     KONL        - Number of grid columns for the latitudes on a processor.
(   72) !                   Similar to nsta() in data structure.
(   73) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over
(   74) !                   two a-sets
(   75) 
(   76) !                FOURIER SPACE
(   77) !     KULTPP   - number of latitudes for which each a-set is calculating
(   78) !                the FFT's.
(   79) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   80) !                it performs the Fourier calculations
(   81) !     KNMENG   - associated (with NLOENG) cut-off zonal wavenumber
(   82) 
(   83) !                 LEGENDRE
(   84) !     PMU      - sin(Gaussian latitudes)
(   85) !     PGW      - Gaussian weights
(   86) !     PRPNM    - Legendre polynomials
(   87) !     KLEI3    - First dimension of Legendre polynomials
(   88) !     KSPOLEGL - Second dimension of Legendre polynomials
(   89) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 3

(   90) !     PLAPIN   - Eigen-values of the inverse Laplace operator
(   91) !     KDGLU    - Number of active points in an hemisphere for a given wavenumber "m"
(   92) 
(   93) !     Method.
(   94) !     -------
(   95) 
(   96) !     Externals.  SET_RESOL - set resolution
(   97) !     ----------
(   98) 
(   99) !     Author.
(  100) !     -------
(  101) !        Mats Hamrud *ECMWF*
(  102) 
(  103) !     Modifications.
(  104) !     --------------
(  105) !        Original : 00-03-03
(  106) !        M. Hortal : 2001-03-05 Dimensions of the Legendre polynomials
(  107) !        R. El Khatib 08-Aug-2012 KSMAX,PLAPIN,KNVALUE,LDLAM,KDEF_RESOL
(  108) 
(  109) !     ------------------------------------------------------------------
(  110) 
(  111) USE PARKIND1  ,ONLY : JPIM     ,JPRB, JPRD
(  112) 
(  113) !ifndef INTERFACE
(  114) 
(  115) USE TPM_GEN         ,ONLY : NDEF_RESOL
(  116) USE TPM_DIM         ,ONLY : R
(  117) USE TPM_DISTR       ,ONLY : D, NPRTRNS, NPRTRW, MYSETV, MYSETW, NPRTRV
(  118) USE TPM_GEOMETRY    ,ONLY : G
(  119) USE TPM_FIELDS      ,ONLY : F
(  120) USE TPM_FLT
(  121) 
(  122) USE SET_RESOL_MOD   ,ONLY : SET_RESOL
(  123) USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS
(  124) USE EQ_REGIONS_MOD  ,ONLY : MY_REGION_EW, MY_REGION_NS, &
(  125)      &                      N_REGIONS_EW, N_REGIONS_NS
(  126) 
(  127) !endif INTERFACE
(  128) 
(  129) IMPLICIT NONE
(  130) 
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(  132) 
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2G
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2MX
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNUMP
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOT
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTG
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTMX
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTL(:,:)
(  142) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLOFF
(  143) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFLOFF
(  144) 
(  145) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYMS(:)
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KASM0(0:)
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KUMPP(:)






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 4

(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPOSSP(:)
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRMS(:)
(  150) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KALLMS(:)
(  151) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDIM0G(0:)
(  152) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLAT(:)
(  153) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLSTLAT(:)
(  154) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLAT(:)
(  155) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFRSTLAT(:)
(  156) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLSTLAT(:)
(  157) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSTA(:,:)
(  158) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KONL(:,:)
(  159) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  160) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  163) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  164) LOGICAL   ,OPTIONAL, INTENT(OUT) :: LDSPLITLAT(:)
(  165) 
(  166) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KULTPP(:)
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLS(:)
(  168) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNMENG(:)
(  169) 
(  170) REAL(KIND=JPRD)    ,OPTIONAL, INTENT(OUT) :: PMU(:)
(  171) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGW(:)
(  172) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PRPNM(:,:)
(  173) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLEI3
(  174) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPOLEGL
(  175) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPMS(0:)
(  176) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDGLU(0:)
(  177) 
(  178) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PLAPIN(-1:)
(  179) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  180) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  181) 
(  182) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  183) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  184) 
(  185) !ifndef INTERFACE
(  186) 
(  187) INTEGER(KIND=JPIM) :: IU1,IU2
(  188) INTEGER(KIND=JPIM) :: IC, JN, JMLOC
(  189) INTEGER(KIND=JPIM) :: IPRTRV,JSETV,IMLOC,IM,ISL,IA,ILA,IS,ILS,IDGLU,J,I
(  190) !     ------------------------------------------------------------------
(  191) 
(  192) 
(  193) ! Set current resolution
(  194) CALL SET_RESOL(KRESOL)
(  195) 
(  196) IF(PRESENT(KSPEC))     KSPEC     = D%NSPEC
(  197) IF(PRESENT(KSPEC2))    KSPEC2    = D%NSPEC2
(  198) IF(PRESENT(KSPEC2G))   KSPEC2G   = R%NSPEC2_G
(  199) IF(PRESENT(KSPEC2MX))  KSPEC2MX  = D%NSPEC2MX
(  200) IF(PRESENT(KNUMP))     KNUMP     = D%NUMP
(  201) IF(PRESENT(KGPTOT))    KGPTOT    = D%NGPTOT
(  202) IF(PRESENT(KGPTOTG))   KGPTOTG   = D%NGPTOTG
(  203) IF(PRESENT(KGPTOTMX))  KGPTOTMX  = D%NGPTOTMX
(  204) IF(PRESENT(KFRSTLOFF)) KFRSTLOFF = D%NFRSTLOFF
(  205) IF(PRESENT(KPTRFLOFF)) KPTRFLOFF = D%NPTRFLOFF






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 5

(  206) IF(PRESENT(KPTRFLOFF)) KPTRFLOFF = D%NPTRFLOFF
(  207) IF(PRESENT(KPRTRW))    KPRTRW    = NPRTRW
(  208) IF(PRESENT(KMYSETW))   KMYSETW   = MYSETW
(  209) IF(PRESENT(KMYSETV))   KMYSETV   = MYSETV
(  210) IF(PRESENT(KMY_REGION_NS))   KMY_REGION_NS = MY_REGION_NS
(  211) IF(PRESENT(KMY_REGION_EW))   KMY_REGION_EW = MY_REGION_EW
(  212) IF(PRESENT(LDLAM))       LDLAM      = G%LAM
(  213) IF(PRESENT(KDEF_RESOL))  KDEF_RESOL = NDEF_RESOL 
(  214) 
(  215) IF(PRESENT(KGPTOTL)) THEN
(  216)   IF(UBOUND(KGPTOTL,1) < N_REGIONS_NS) THEN
(  217)     CALL ABORT_TRANS('TRANS_INQ: KGPTOTL DIM 1 TOO SMALL')
(  218)   ELSEIF(UBOUND(KGPTOTL,2) <  N_REGIONS_EW) THEN
(  219)     CALL ABORT_TRANS('TRANS_INQ: KGPTOTL DIM 2 TOO SMALL')
(  220)   ELSE
(  221)     KGPTOTL(1:N_REGIONS_NS,1:N_REGIONS_EW) = D%NGPTOTL(:,:)
(  222)   ENDIF
(  223) ENDIF
(  224) 
(  225) IF(PRESENT(KMYMS)) THEN
(  226)   IF(D%LGRIDONLY) THEN
(  227)     CALL ABORT_TRANS('TRANS_INQ: KMYMS REQUIRED BUT LGRIDONLY=T')
(  228)   ENDIF
(  229)   IF(UBOUND(KMYMS,1) < D%NUMP) THEN
(  230)     CALL ABORT_TRANS('TRANS_INQ: KMYMS TOO SMALL')
(  231)   ELSE
(  232)     KMYMS(1:D%NUMP) = D%MYMS(:)
(  233)   ENDIF
(  234) ENDIF
(  235) 
(  236) IF(PRESENT(KASM0)) THEN
(  237)   IF(D%LGRIDONLY) THEN
(  238)     CALL ABORT_TRANS('TRANS_INQ: KASM0 REQUIRED BUT LGRIDONLY=T')
(  239)   ENDIF
(  240)   IF(UBOUND(KASM0,1) < R%NSMAX) THEN
(  241)     CALL ABORT_TRANS('TRANS_INQ: KASM0 TOO SMALL')
(  242)   ELSE
(  243)     KASM0(0:R%NSMAX) = D%NASM0(:)
(  244)   ENDIF
(  245) ENDIF
(  246) 
(  247) IF(PRESENT(KUMPP)) THEN
(  248)   IF(D%LGRIDONLY) THEN
(  249)     CALL ABORT_TRANS('TRANS_INQ: KUMPP REQUIRED BUT LGRIDONLY=T')
(  250)   ENDIF
(  251)   IF(UBOUND(KUMPP,1) < NPRTRW) THEN
(  252)     CALL ABORT_TRANS('TRANS_INQ: KUMPP TOO SMALL')
(  253)   ELSE
(  254)     KUMPP(1:NPRTRW) = D%NUMPP(:)
(  255)   ENDIF
(  256) ENDIF
(  257) 
(  258) IF(PRESENT(KPOSSP)) THEN
(  259)   IF(D%LGRIDONLY) THEN
(  260)     CALL ABORT_TRANS('TRANS_INQ: KPOSSP REQUIRED BUT LGRIDONLY=T')
(  261)   ENDIF
(  262)   IF(UBOUND(KPOSSP,1) < NPRTRW+1) THEN
(  263)     CALL ABORT_TRANS('TRANS_INQ: KPOSSP TOO SMALL')






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 6

(  264)   ELSE
(  265)     KPOSSP(1:NPRTRW+1) = D%NPOSSP(:)
(  266)   ENDIF
(  267) ENDIF
(  268) 
(  269) IF(PRESENT(KPTRMS)) THEN
(  270)   IF(D%LGRIDONLY) THEN
(  271)     CALL ABORT_TRANS('TRANS_INQ: KPTRMS REQUIRED BUT LGRIDONLY=T')
(  272)   ENDIF
(  273)   IF(UBOUND(KPTRMS,1) < NPRTRW) THEN
(  274)     CALL ABORT_TRANS('TRANS_INQ: KPTRMS TOO SMALL')
(  275)   ELSE
(  276)     KPTRMS(1:NPRTRW) = D%NPTRMS(:)
(  277)   ENDIF
(  278) ENDIF
(  279) 
(  280) IF(PRESENT(KALLMS)) THEN
(  281)   IF(D%LGRIDONLY) THEN
(  282)     CALL ABORT_TRANS('TRANS_INQ: KALLMS REQUIRED BUT LGRIDONLY=T')
(  283)   ENDIF
(  284)   IF(UBOUND(KALLMS,1) < R%NSMAX+1) THEN
(  285)     CALL ABORT_TRANS('TRANS_INQ: KALLMS TOO SMALL')
(  286)   ELSE
(  287)     KALLMS(1:R%NSMAX+1) = D%NALLMS(:)
(  288)   ENDIF
(  289) ENDIF
(  290) 
(  291) IF(PRESENT(KDIM0G)) THEN
(  292)   IF(D%LGRIDONLY) THEN
(  293)     CALL ABORT_TRANS('TRANS_INQ: KDIM0G REQUIRED BUT LGRIDONLY=T')
(  294)   ENDIF
(  295)   IF(UBOUND(KDIM0G,1) < R%NSMAX) THEN
(  296)     CALL ABORT_TRANS('TRANS_INQ: KDIM0G TOO SMALL')
(  297)   ELSE
(  298)     KDIM0G(0:R%NSMAX) = D%NDIM0G(0:R%NSMAX)
(  299)   ENDIF
(  300) ENDIF
(  301) 
(  302) IF(PRESENT(KFRSTLAT)) THEN
(  303)   IF(UBOUND(KFRSTLAT,1) < N_REGIONS_NS) THEN
(  304)     CALL ABORT_TRANS('TRANS_INQ: KFRSTLAT TOO SMALL')
(  305)   ELSE
(  306)     KFRSTLAT(1:N_REGIONS_NS) = D%NFRSTLAT(:)
(  307)   ENDIF
(  308) ENDIF
(  309) 
(  310) IF(PRESENT(KLSTLAT)) THEN
(  311)   IF(UBOUND(KLSTLAT,1) < N_REGIONS_NS) THEN
(  312)     CALL ABORT_TRANS('TRANS_INQ: KLSTLAT TOO SMALL')
(  313)   ELSE
(  314)     KLSTLAT(1:N_REGIONS_NS) = D%NLSTLAT(:)
(  315)   ENDIF
(  316) ENDIF
(  317) 
(  318) IF(PRESENT(KPTRLAT)) THEN
(  319)   IF(UBOUND(KPTRLAT,1) < R%NDGL) THEN
(  320)     CALL ABORT_TRANS('TRANS_INQ: KPTRLAT TOO SMALL')
(  321)   ELSE






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 7

(  322)     KPTRLAT(1:R%NDGL) = D%NPTRLAT(:)
(  323)   ENDIF
(  324) ENDIF
(  325) 
(  326) IF(PRESENT(KPTRFRSTLAT)) THEN
(  327)   IF(UBOUND(KPTRFRSTLAT,1) < N_REGIONS_NS) THEN
(  328)     CALL ABORT_TRANS('TRANS_INQ: KPTRFRSTLAT TOO SMALL')
(  329)   ELSE
(  330)     KPTRFRSTLAT(1:N_REGIONS_NS) = D%NPTRFRSTLAT(:)
(  331)   ENDIF
(  332) ENDIF
(  333) 
(  334) IF(PRESENT(KPTRLSTLAT)) THEN
(  335)   IF(UBOUND(KPTRLSTLAT,1) < N_REGIONS_NS) THEN
(  336)     CALL ABORT_TRANS('TRANS_INQ: KPTRLSTLAT TOO SMALL')
(  337)   ELSE
(  338)     KPTRLSTLAT(1:N_REGIONS_NS) = D%NPTRLSTLAT(:)
(  339)   ENDIF
(  340) ENDIF
(  341) 
(  342) IF(PRESENT(KSTA)) THEN
(  343)   IF(UBOUND(KSTA,1) < R%NDGL+N_REGIONS_NS-1) THEN
(  344)     CALL ABORT_TRANS('TRANS_INQ: KSTA DIM 1 TOO SMALL')
(  345)   ELSEIF(UBOUND(KSTA,2) < N_REGIONS_EW) THEN
(  346)     CALL ABORT_TRANS('TRANS_INQ: KSTA DIM 2 TOO SMALL')
(  347)   ELSE
(  348)     KSTA(1:R%NDGL+N_REGIONS_NS-1,1:N_REGIONS_EW) = D%NSTA(:,:)
(  349)   ENDIF
(  350) ENDIF
(  351) 
(  352) IF(PRESENT(KONL)) THEN
(  353)   IF(UBOUND(KONL,1) < R%NDGL+N_REGIONS_NS-1) THEN
(  354)     CALL ABORT_TRANS('TRANS_INQ: KONL DIM 1 TOO SMALL')
(  355)   ELSEIF(UBOUND(KONL,2) < N_REGIONS_EW) THEN
(  356)     CALL ABORT_TRANS('TRANS_INQ: KONL DIM 2 TOO SMALL')
(  357)   ELSE
(  358)     KONL(1:R%NDGL+N_REGIONS_NS-1,1:N_REGIONS_EW) = D%NONL(:,:)
(  359)   ENDIF
(  360) ENDIF
(  361) 
(  362) IF(PRESENT(LDSPLITLAT)) THEN
(  363)   IF(UBOUND(LDSPLITLAT,1) < R%NDGL) THEN
(  364)     CALL ABORT_TRANS('TRANS_INQ: LDSPLITLAT TOO SMALL')
(  365)   ELSE
(  366)     LDSPLITLAT(1:R%NDGL) = D%LSPLITLAT(:)
(  367)   ENDIF
(  368) ENDIF
(  369) 
(  370) IF(PRESENT(KULTPP)) THEN
(  371)   IF(D%LGRIDONLY) THEN
(  372)     CALL ABORT_TRANS('TRANS_INQ: KULTPP REQUIRED BUT LGRIDONLY=T')
(  373)   ENDIF
(  374)   IF(UBOUND(KULTPP,1) < NPRTRNS) THEN
(  375)     CALL ABORT_TRANS('TRANS_INQ: KULTPP TOO SMALL')
(  376)   ELSE
(  377)     KULTPP(1:NPRTRNS) = D%NULTPP(:)
(  378)   ENDIF
(  379) ENDIF






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 8

(  380) 
(  381) IF(PRESENT(KPTRLS)) THEN
(  382)   IF(D%LGRIDONLY) THEN
(  383)     CALL ABORT_TRANS('TRANS_INQ: KPTRLS REQUIRED BUT LGRIDONLY=T')
(  384)   ENDIF
(  385)   IF(UBOUND(KPTRLS,1) < NPRTRNS) THEN
(  386)     CALL ABORT_TRANS('TRANS_INQ: KPTRLS TOO SMALL')
(  387)   ELSE
(  388)     KPTRLS(1:NPRTRNS) = D%NPTRLS(:)
(  389)   ENDIF
(  390) ENDIF
(  391) 
(  392) IF(PRESENT(KNMENG)) THEN
(  393)   IF(UBOUND(KNMENG,1) < R%NDGL) THEN
(  394)     CALL ABORT_TRANS('TRANS_INQ: KNMENG TOO SMALL')
(  395)   ELSE
(  396)     KNMENG(1:R%NDGL) = G%NMEN(1:R%NDGL)
(  397)   ENDIF
(  398) ENDIF
(  399) 
(  400) IF(PRESENT(PMU)) THEN
(  401)   IF(UBOUND(PMU,1) < R%NDGL) THEN
(  402)     CALL ABORT_TRANS('TRANS_INQ: PMU TOO SMALL')
(  403)   ELSE
(  404)     PMU(1:R%NDGL) = F%RMU
(  405)   ENDIF
(  406) ENDIF
(  407) 
(  408) IF(PRESENT(PGW)) THEN
(  409)   IF(UBOUND(PGW,1) < R%NDGL) THEN
(  410)     CALL ABORT_TRANS('TRANS_INQ: PGW TOO SMALL')
(  411)   ELSE
(  412)     PGW(1:R%NDGL) = REAl(F%RW,JPRB)
(  413)   ENDIF
(  414) ENDIF
(  415) 
(  416) IF(PRESENT(PRPNM)) THEN
(  417) 
(  418)   IF( .NOT. S%LKEEPRPNM ) THEN
(  419)     CALL ABORT_TRANS('TRANS_INQ: PRPNM REQUIRED BUT S%LKEEPRPNM=F')
(  420)   ENDIF
(  421)   
(  422)   IF(D%LGRIDONLY) THEN
(  423)     CALL ABORT_TRANS('TRANS_INQ: PRPNM REQUIRED BUT LGRIDONLY=T')
(  424)   ENDIF
(  425)   IU1 = UBOUND(PRPNM,1)
(  426)   IU2 = UBOUND(PRPNM,2)
(  427)   IF(IU1 < R%NDGNH) THEN
(  428)     CALL ABORT_TRANS('TRANS_INQ:FIRST DIM. OF PRNM TOO SMALL')
(  429)   ELSE
(  430) !    IU1 = MIN(IU1,R%NLEI3)
(  431) !    IU2 = MIN(IU2,D%NSPOLEGL)
(  432) !    PRPNM(1:IU1,1:IU2) = F%RPNM(1:IU1,1:IU2)
(  433) 
(  434)     DO JMLOC=1,D%NUMP,NPRTRV
(  435)       IPRTRV=MIN(NPRTRV,D%NUMP-JMLOC+1)
(  436)       DO JSETV=1,IPRTRV
(  437)         IMLOC=JMLOC+JSETV-1






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 9

(  438)         IM = D%MYMS(IMLOC)
(  439)         ISL = MAX(R%NDGNH-G%NDGLU(IM)+1,1)
(  440)         IA  = 1+MOD(R%NSMAX-IM+2,2)
(  441)         ILA = (R%NSMAX-IM+2)/2
(  442)         IS  = 1+MOD(R%NSMAX-IM+1,2)
(  443)         ILS = (R%NSMAX-IM+3)/2
(  444)         IDGLU = MIN(R%NDGNH,G%NDGLU(IM))
(  445)         DO J=1,ILA
(  446)           DO I=1,IDGLU
(  447)             PRPNM(ISL+I-1,D%NPMS(IM)+IA+(J-1)*2) = REAL(S%FA(IMLOC)%RPNMA(I,J),JPRB)
(  448)           ENDDO
(  449)         ENDDO
(  450)         DO J=1,ILS
(  451)           DO I=1,IDGLU
(  452)             PRPNM(ISL+I-1,D%NPMS(IM)+IS+(J-1)*2) = REAL(S%FA(IMLOC)%RPNMS(I,J),JPRB)
(  453)           ENDDO
(  454)         ENDDO
(  455)       ENDDO
(  456)     ENDDO
(  457)   ENDIF
(  458) ENDIF
(  459) IF(PRESENT(KLEI3)) THEN
(  460)   KLEI3=R%NLEI3
(  461) ENDIF
(  462) IF(PRESENT(KSPOLEGL)) THEN
(  463)   KSPOLEGL=D%NSPOLEGL
(  464) ENDIF
(  465) IF(PRESENT(KPMS)) THEN
(  466)   IF(D%LGRIDONLY) THEN
(  467)     CALL ABORT_TRANS('TRANS_INQ: KPMS REQUIRED BUT LGRIDONLY=T')
(  468)   ENDIF
(  469)   IF(UBOUND(KPMS,1) < R%NSMAX) THEN
(  470)     CALL ABORT_TRANS('TRANS_INQ: KPMS TOO SMALL')
(  471)   ELSE
(  472)     KPMS(0:R%NSMAX) = D%NPMS(0:R%NSMAX)
(  473)   ENDIF
(  474) ENDIF
(  475) 
(  476) IF(PRESENT(KSMAX)) KSMAX = R%NSMAX
(  477) IF(PRESENT(PLAPIN)) THEN
(  478)   IF(D%LGRIDONLY) THEN
(  479)     CALL ABORT_TRANS('TRANS_INQ: PLAPIN REQUIRED BUT LGRIDONLY=T')
(  480)   ENDIF
(  481)   IF(UBOUND(PLAPIN,1) < R%NSMAX+2) THEN
(  482)     CALL ABORT_TRANS('TRANS_INQ: PLAPIN TOO SMALL')
(  483)   ELSEIF (LBOUND(PLAPIN,1) /= -1) THEN
(  484)     CALL ABORT_TRANS('TRANS_INQ: LOWER BOUND OF PLAPIN SHOULD BE -1')
(  485)   ELSE
(  486)     PLAPIN(-1:R%NSMAX+2) = REAL(F%RLAPIN(:),JPRB)
(  487)   ENDIF
(  488) ENDIF
(  489) IF(PRESENT(KNVALUE)) THEN
(  490)   IF(D%LGRIDONLY) THEN
(  491)     CALL ABORT_TRANS('TRANS_INQ: KNVALUE REQUIRED BUT LGRIDONLY=T')
(  492)   ENDIF
(  493)   IF(SIZE(KNVALUE) < D%NSPEC2) THEN
(  494)     CALL ABORT_TRANS('TRANS_INQ: KNVALUE TOO SMALL')
(  495)   ELSE






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 10

(  496)     IC=1
(  497)     DO JMLOC=1,D%NUMP
(  498)       DO JN=D%MYMS(JMLOC),R%NSMAX
(  499)         KNVALUE(IC  )=JN
(  500)         KNVALUE(IC+1)=JN
(  501)         IC=IC+2
(  502)       ENDDO
(  503)     ENDDO
(  504)   ENDIF
(  505) ENDIF
(  506) 
(  507) 
(  508) IF(PRESENT(KDGLU)) THEN
(  509)   IF(UBOUND(KDGLU,1) < R%NSMAX) THEN
(  510)     CALL ABORT_TRANS('TRANS_INQ: KDGLU TOO SMALL')
(  511)   ELSE
(  512)     KDGLU(0:R%NSMAX) = G%NDGLU(0:R%NSMAX)
(  513)   ENDIF
(  514) ENDIF
(  515) !     ------------------------------------------------------------------
(  516) 
(  517) !endif INTERFACE
(  518) 
(  519) END SUBROUTINE TRANS_INQ
(  520) 
(  521) 
(  522) 
(  523) 
(  524) 
(  525) 


































NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 11

(    1) # 1 "trans_inq.F90"
(    1) SUBROUTINE TRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    2)                     &KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    3)                     &KMYMS,KASM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    4)                     &KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    5)                     &KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    6)                     &KULTPP,KPTRLS,KNMENG,&
(    7)                     &KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    8)                     &LDSPLITLAT,&
(    9)                     &KSMAX,PLAPIN,KNVALUE,KDEF_RESOL,LDLAM,&
(   10)                     &PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KDGLU)
(   11) # 12 "trans_inq.F90"
(   12) !**** *TRANS_INQ* - Extract information from the transform package
(   13) # 14 "trans_inq.F90"
(   14) !     Purpose.
(   15) !     --------
(   16) !     Interface routine for extracting information from the T.P.
(   17) # 18 "trans_inq.F90"
(   18) !**   Interface.
(   19) !     ----------
(   20) !     CALL TRANS_INQ(...)
(   21) !     Explicit arguments : All arguments are optional.
(   22) !     --------------------
(   23) !     KRESOL   - resolution tag for which info is required ,default is the
(   24) !                first defined resulution (input)
(   25) # 26 "trans_inq.F90"
(   26) !                   MULTI-TRANSFORMS MANAGEMENT
(   27) !     KDEF_RESOL - number or resolutions defined
(   28) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   29) # 30 "trans_inq.F90"
(   30) !                   SPECTRAL SPACE
(   31) !     KSPEC    - number of complex spectral coefficients on this PE
(   32) !     KSPEC2   - 2*KSPEC
(   33) !     KSPEC2G  - global KSPEC2
(   34) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   35) !     KNUMP    - Number of spectral waves handled by this PE
(   36) !     KGPTOT   - Total number of grid columns on this PE
(   37) !     KGPTOTG  - Total number of grid columns on the Globe
(   38) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   39) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   40) !     KMYMS    - This PEs spectral zonal wavenumbers
(   41) !     KASM0    - Address in a spectral array of (m, n=m)
(   42) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   43) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   44) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   45) !     KALLMS   - Wave numbers for all wave-set concatenated together
(   46) !                to give all wave numbers in wave-set order
(   47) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   48) !     KSMAX    - spectral truncation
(   49) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   50) # 51 "trans_inq.F90"
(   51) !                 GRIDPOINT SPACE
(   52) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   53) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   54) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   55) !     KPTRLAT     - Pointer to the start of each latitude
(   56) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in
(   57) !                   NSTA and NONL arrays






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 12

(   58) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   59) !                   NSTA and NONL arrays
(   60) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   61) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   62) !     KSTA        - Position of first grid column for the latitudes on a
(   63) !                   processor. The information is available for all processors.
(   64) !                   The b-sets are distinguished by the last dimension of
(   65) !                   nsta().The latitude band for each a-set is addressed by
(   66) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and
(   67) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   68) !                   Each split latitude has two entries in nsta(,:) which
(   69) !                   necessitates the rather complex addressing of nsta(,:)
(   70) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   71) !     KONL        - Number of grid columns for the latitudes on a processor.
(   72) !                   Similar to nsta() in data structure.
(   73) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over
(   74) !                   two a-sets
(   75) # 76 "trans_inq.F90"
(   76) !                FOURIER SPACE
(   77) !     KULTPP   - number of latitudes for which each a-set is calculating
(   78) !                the FFT's.
(   79) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   80) !                it performs the Fourier calculations
(   81) !     KNMENG   - associated (with NLOENG) cut-off zonal wavenumber
(   82) # 83 "trans_inq.F90"
(   83) !                 LEGENDRE
(   84) !     PMU      - sin(Gaussian latitudes)
(   85) !     PGW      - Gaussian weights
(   86) !     PRPNM    - Legendre polynomials
(   87) !     KLEI3    - First dimension of Legendre polynomials
(   88) !     KSPOLEGL - Second dimension of Legendre polynomials
(   89) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   90) !     PLAPIN   - Eigen-values of the inverse Laplace operator
(   91) !     KDGLU    - Number of active points in an hemisphere for a given wavenumber "m"
(   92) # 93 "trans_inq.F90"
(   93) !     Method.
(   94) !     -------
(   95) # 96 "trans_inq.F90"
(   96) !     Externals.  SET_RESOL - set resolution
(   97) !     ----------
(   98) # 99 "trans_inq.F90"
(   99) !     Author.
(  100) !     -------
(  101) !        Mats Hamrud *ECMWF*
(  102) # 103 "trans_inq.F90"
(  103) !     Modifications.
(  104) !     --------------
(  105) !        Original : 00-03-03
(  106) !        M. Hortal : 2001-03-05 Dimensions of the Legendre polynomials
(  107) !        R. El Khatib 08-Aug-2012 KSMAX,PLAPIN,KNVALUE,LDLAM,KDEF_RESOL
(  108) # 109 "trans_inq.F90"
(  109) !     ------------------------------------------------------------------
(  110) # 111 "trans_inq.F90"
(  111) USE PARKIND1  ,ONLY : JPIM     ,JPRB, JPRD
(  112) # 113 "trans_inq.F90"
(  113) !ifndef INTERFACE
(  114) # 115 "trans_inq.F90"
(  115) USE TPM_GEN         ,ONLY : NDEF_RESOL






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 13

(  116) USE TPM_DIM         ,ONLY : R
(  117) USE TPM_DISTR       ,ONLY : D, NPRTRNS, NPRTRW, MYSETV, MYSETW, NPRTRV
(  118) USE TPM_GEOMETRY    ,ONLY : G
(  119) USE TPM_FIELDS      ,ONLY : F
(  120) USE TPM_FLT
(  121) # 122 "trans_inq.F90"
(  122) USE SET_RESOL_MOD   ,ONLY : SET_RESOL
(  123) USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS
(  124) USE EQ_REGIONS_MOD  ,ONLY : MY_REGION_EW, MY_REGION_NS, &
(  125)      &                      N_REGIONS_EW, N_REGIONS_NS
(  126) # 127 "trans_inq.F90"
(  127) !endif INTERFACE
(  128) # 129 "trans_inq.F90"
(  129) IMPLICIT NONE
(  130) # 131 "trans_inq.F90"
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(  132) # 133 "trans_inq.F90"
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2G
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2MX
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNUMP
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOT
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTG
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTMX
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTL(:,:)
(  142) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLOFF
(  143) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFLOFF
(  144) # 145 "trans_inq.F90"
(  145) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYMS(:)
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KASM0(0:)
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KUMPP(:)
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPOSSP(:)
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRMS(:)
(  150) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KALLMS(:)
(  151) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDIM0G(0:)
(  152) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLAT(:)
(  153) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLSTLAT(:)
(  154) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLAT(:)
(  155) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFRSTLAT(:)
(  156) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLSTLAT(:)
(  157) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSTA(:,:)
(  158) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KONL(:,:)
(  159) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  160) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  163) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  164) LOGICAL   ,OPTIONAL, INTENT(OUT) :: LDSPLITLAT(:)
(  165) # 166 "trans_inq.F90"
(  166) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KULTPP(:)
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLS(:)
(  168) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNMENG(:)
(  169) # 170 "trans_inq.F90"
(  170) REAL(KIND=JPRD)    ,OPTIONAL, INTENT(OUT) :: PMU(:)
(  171) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGW(:)
(  172) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PRPNM(:,:)
(  173) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLEI3






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 14

(  174) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPOLEGL
(  175) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPMS(0:)
(  176) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDGLU(0:)
(  177) # 178 "trans_inq.F90"
(  178) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PLAPIN(-1:)
(  179) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  180) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  181) # 182 "trans_inq.F90"
(  182) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  183) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  184) # 185 "trans_inq.F90"
(  185) !ifndef INTERFACE
(  186) # 187 "trans_inq.F90"
(  187) INTEGER(KIND=JPIM) :: IU1,IU2
(  188) INTEGER(KIND=JPIM) :: IC, JN, JMLOC
(  189) INTEGER(KIND=JPIM) :: IPRTRV,JSETV,IMLOC,IM,ISL,IA,ILA,IS,ILS,IDGLU,J,I
(  190) !     ------------------------------------------------------------------
(  191) # 193 "trans_inq.F90"
(  193) ! Set current resolution
(  194) CALL SET_RESOL(KRESOL)
(  195) # 196 "trans_inq.F90"
(  196) IF(PRESENT(KSPEC))     KSPEC     = D%NSPEC
(  197) IF(PRESENT(KSPEC2))    KSPEC2    = D%NSPEC2
(  198) IF(PRESENT(KSPEC2G))   KSPEC2G   = R%NSPEC2_G
(  199) IF(PRESENT(KSPEC2MX))  KSPEC2MX  = D%NSPEC2MX
(  200) IF(PRESENT(KNUMP))     KNUMP     = D%NUMP
(  201) IF(PRESENT(KGPTOT))    KGPTOT    = D%NGPTOT
(  202) IF(PRESENT(KGPTOTG))   KGPTOTG   = D%NGPTOTG
(  203) IF(PRESENT(KGPTOTMX))  KGPTOTMX  = D%NGPTOTMX
(  204) IF(PRESENT(KFRSTLOFF)) KFRSTLOFF = D%NFRSTLOFF
(  205) IF(PRESENT(KPTRFLOFF)) KPTRFLOFF = D%NPTRFLOFF
(  206) IF(PRESENT(KPTRFLOFF)) KPTRFLOFF = D%NPTRFLOFF
(  207) IF(PRESENT(KPRTRW))    KPRTRW    = NPRTRW
(  208) IF(PRESENT(KMYSETW))   KMYSETW   = MYSETW
(  209) IF(PRESENT(KMYSETV))   KMYSETV   = MYSETV
(  210) IF(PRESENT(KMY_REGION_NS))   KMY_REGION_NS = MY_REGION_NS
(  211) IF(PRESENT(KMY_REGION_EW))   KMY_REGION_EW = MY_REGION_EW
(  212) IF(PRESENT(LDLAM))       LDLAM      = G%LAM
(  213) IF(PRESENT(KDEF_RESOL))  KDEF_RESOL = NDEF_RESOL 
(  214) # 215 "trans_inq.F90"
(  215) IF(PRESENT(KGPTOTL)) THEN
(  216)   IF(UBOUND(KGPTOTL,1) < N_REGIONS_NS) THEN
(  217)     CALL ABORT_TRANS('TRANS_INQ: KGPTOTL DIM 1 TOO SMALL')
(  218)   ELSEIF(UBOUND(KGPTOTL,2) <  N_REGIONS_EW) THEN
(  219)     CALL ABORT_TRANS('TRANS_INQ: KGPTOTL DIM 2 TOO SMALL')
(  220)   ELSE
(  221)     KGPTOTL(1:N_REGIONS_NS,1:N_REGIONS_EW) = D%NGPTOTL(:,:)
(  222)   ENDIF
(  223) ENDIF
(  224) # 225 "trans_inq.F90"
(  225) IF(PRESENT(KMYMS)) THEN
(  226)   IF(D%LGRIDONLY) THEN
(  227)     CALL ABORT_TRANS('TRANS_INQ: KMYMS REQUIRED BUT LGRIDONLY=T')
(  228)   ENDIF
(  229)   IF(UBOUND(KMYMS,1) < D%NUMP) THEN
(  230)     CALL ABORT_TRANS('TRANS_INQ: KMYMS TOO SMALL')
(  231)   ELSE
(  232)     KMYMS(1:D%NUMP) = D%MYMS(:)






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 15

(  233)   ENDIF
(  234) ENDIF
(  235) # 236 "trans_inq.F90"
(  236) IF(PRESENT(KASM0)) THEN
(  237)   IF(D%LGRIDONLY) THEN
(  238)     CALL ABORT_TRANS('TRANS_INQ: KASM0 REQUIRED BUT LGRIDONLY=T')
(  239)   ENDIF
(  240)   IF(UBOUND(KASM0,1) < R%NSMAX) THEN
(  241)     CALL ABORT_TRANS('TRANS_INQ: KASM0 TOO SMALL')
(  242)   ELSE
(  243)     KASM0(0:R%NSMAX) = D%NASM0(:)
(  244)   ENDIF
(  245) ENDIF
(  246) # 247 "trans_inq.F90"
(  247) IF(PRESENT(KUMPP)) THEN
(  248)   IF(D%LGRIDONLY) THEN
(  249)     CALL ABORT_TRANS('TRANS_INQ: KUMPP REQUIRED BUT LGRIDONLY=T')
(  250)   ENDIF
(  251)   IF(UBOUND(KUMPP,1) < NPRTRW) THEN
(  252)     CALL ABORT_TRANS('TRANS_INQ: KUMPP TOO SMALL')
(  253)   ELSE
(  254)     KUMPP(1:NPRTRW) = D%NUMPP(:)
(  255)   ENDIF
(  256) ENDIF
(  257) # 258 "trans_inq.F90"
(  258) IF(PRESENT(KPOSSP)) THEN
(  259)   IF(D%LGRIDONLY) THEN
(  260)     CALL ABORT_TRANS('TRANS_INQ: KPOSSP REQUIRED BUT LGRIDONLY=T')
(  261)   ENDIF
(  262)   IF(UBOUND(KPOSSP,1) < NPRTRW+1) THEN
(  263)     CALL ABORT_TRANS('TRANS_INQ: KPOSSP TOO SMALL')
(  264)   ELSE
(  265)     KPOSSP(1:NPRTRW+1) = D%NPOSSP(:)
(  266)   ENDIF
(  267) ENDIF
(  268) # 269 "trans_inq.F90"
(  269) IF(PRESENT(KPTRMS)) THEN
(  270)   IF(D%LGRIDONLY) THEN
(  271)     CALL ABORT_TRANS('TRANS_INQ: KPTRMS REQUIRED BUT LGRIDONLY=T')
(  272)   ENDIF
(  273)   IF(UBOUND(KPTRMS,1) < NPRTRW) THEN
(  274)     CALL ABORT_TRANS('TRANS_INQ: KPTRMS TOO SMALL')
(  275)   ELSE
(  276)     KPTRMS(1:NPRTRW) = D%NPTRMS(:)
(  277)   ENDIF
(  278) ENDIF
(  279) # 280 "trans_inq.F90"
(  280) IF(PRESENT(KALLMS)) THEN
(  281)   IF(D%LGRIDONLY) THEN
(  282)     CALL ABORT_TRANS('TRANS_INQ: KALLMS REQUIRED BUT LGRIDONLY=T')
(  283)   ENDIF
(  284)   IF(UBOUND(KALLMS,1) < R%NSMAX+1) THEN
(  285)     CALL ABORT_TRANS('TRANS_INQ: KALLMS TOO SMALL')
(  286)   ELSE
(  287)     KALLMS(1:R%NSMAX+1) = D%NALLMS(:)
(  288)   ENDIF
(  289) ENDIF
(  290) # 291 "trans_inq.F90"






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 16

(  291) IF(PRESENT(KDIM0G)) THEN
(  292)   IF(D%LGRIDONLY) THEN
(  293)     CALL ABORT_TRANS('TRANS_INQ: KDIM0G REQUIRED BUT LGRIDONLY=T')
(  294)   ENDIF
(  295)   IF(UBOUND(KDIM0G,1) < R%NSMAX) THEN
(  296)     CALL ABORT_TRANS('TRANS_INQ: KDIM0G TOO SMALL')
(  297)   ELSE
(  298)     KDIM0G(0:R%NSMAX) = D%NDIM0G(0:R%NSMAX)
(  299)   ENDIF
(  300) ENDIF
(  301) # 302 "trans_inq.F90"
(  302) IF(PRESENT(KFRSTLAT)) THEN
(  303)   IF(UBOUND(KFRSTLAT,1) < N_REGIONS_NS) THEN
(  304)     CALL ABORT_TRANS('TRANS_INQ: KFRSTLAT TOO SMALL')
(  305)   ELSE
(  306)     KFRSTLAT(1:N_REGIONS_NS) = D%NFRSTLAT(:)
(  307)   ENDIF
(  308) ENDIF
(  309) # 310 "trans_inq.F90"
(  310) IF(PRESENT(KLSTLAT)) THEN
(  311)   IF(UBOUND(KLSTLAT,1) < N_REGIONS_NS) THEN
(  312)     CALL ABORT_TRANS('TRANS_INQ: KLSTLAT TOO SMALL')
(  313)   ELSE
(  314)     KLSTLAT(1:N_REGIONS_NS) = D%NLSTLAT(:)
(  315)   ENDIF
(  316) ENDIF
(  317) # 318 "trans_inq.F90"
(  318) IF(PRESENT(KPTRLAT)) THEN
(  319)   IF(UBOUND(KPTRLAT,1) < R%NDGL) THEN
(  320)     CALL ABORT_TRANS('TRANS_INQ: KPTRLAT TOO SMALL')
(  321)   ELSE
(  322)     KPTRLAT(1:R%NDGL) = D%NPTRLAT(:)
(  323)   ENDIF
(  324) ENDIF
(  325) # 326 "trans_inq.F90"
(  326) IF(PRESENT(KPTRFRSTLAT)) THEN
(  327)   IF(UBOUND(KPTRFRSTLAT,1) < N_REGIONS_NS) THEN
(  328)     CALL ABORT_TRANS('TRANS_INQ: KPTRFRSTLAT TOO SMALL')
(  329)   ELSE
(  330)     KPTRFRSTLAT(1:N_REGIONS_NS) = D%NPTRFRSTLAT(:)
(  331)   ENDIF
(  332) ENDIF
(  333) # 334 "trans_inq.F90"
(  334) IF(PRESENT(KPTRLSTLAT)) THEN
(  335)   IF(UBOUND(KPTRLSTLAT,1) < N_REGIONS_NS) THEN
(  336)     CALL ABORT_TRANS('TRANS_INQ: KPTRLSTLAT TOO SMALL')
(  337)   ELSE
(  338)     KPTRLSTLAT(1:N_REGIONS_NS) = D%NPTRLSTLAT(:)
(  339)   ENDIF
(  340) ENDIF
(  341) # 342 "trans_inq.F90"
(  342) IF(PRESENT(KSTA)) THEN
(  343)   IF(UBOUND(KSTA,1) < R%NDGL+N_REGIONS_NS-1) THEN
(  344)     CALL ABORT_TRANS('TRANS_INQ: KSTA DIM 1 TOO SMALL')
(  345)   ELSEIF(UBOUND(KSTA,2) < N_REGIONS_EW) THEN
(  346)     CALL ABORT_TRANS('TRANS_INQ: KSTA DIM 2 TOO SMALL')
(  347)   ELSE
(  348)     KSTA(1:R%NDGL+N_REGIONS_NS-1,1:N_REGIONS_EW) = D%NSTA(:,:)






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 17

(  349)   ENDIF
(  350) ENDIF
(  351) # 352 "trans_inq.F90"
(  352) IF(PRESENT(KONL)) THEN
(  353)   IF(UBOUND(KONL,1) < R%NDGL+N_REGIONS_NS-1) THEN
(  354)     CALL ABORT_TRANS('TRANS_INQ: KONL DIM 1 TOO SMALL')
(  355)   ELSEIF(UBOUND(KONL,2) < N_REGIONS_EW) THEN
(  356)     CALL ABORT_TRANS('TRANS_INQ: KONL DIM 2 TOO SMALL')
(  357)   ELSE
(  358)     KONL(1:R%NDGL+N_REGIONS_NS-1,1:N_REGIONS_EW) = D%NONL(:,:)
(  359)   ENDIF
(  360) ENDIF
(  361) # 362 "trans_inq.F90"
(  362) IF(PRESENT(LDSPLITLAT)) THEN
(  363)   IF(UBOUND(LDSPLITLAT,1) < R%NDGL) THEN
(  364)     CALL ABORT_TRANS('TRANS_INQ: LDSPLITLAT TOO SMALL')
(  365)   ELSE
(  366)     LDSPLITLAT(1:R%NDGL) = D%LSPLITLAT(:)
(  367)   ENDIF
(  368) ENDIF
(  369) # 370 "trans_inq.F90"
(  370) IF(PRESENT(KULTPP)) THEN
(  371)   IF(D%LGRIDONLY) THEN
(  372)     CALL ABORT_TRANS('TRANS_INQ: KULTPP REQUIRED BUT LGRIDONLY=T')
(  373)   ENDIF
(  374)   IF(UBOUND(KULTPP,1) < NPRTRNS) THEN
(  375)     CALL ABORT_TRANS('TRANS_INQ: KULTPP TOO SMALL')
(  376)   ELSE
(  377)     KULTPP(1:NPRTRNS) = D%NULTPP(:)
(  378)   ENDIF
(  379) ENDIF
(  380) # 381 "trans_inq.F90"
(  381) IF(PRESENT(KPTRLS)) THEN
(  382)   IF(D%LGRIDONLY) THEN
(  383)     CALL ABORT_TRANS('TRANS_INQ: KPTRLS REQUIRED BUT LGRIDONLY=T')
(  384)   ENDIF
(  385)   IF(UBOUND(KPTRLS,1) < NPRTRNS) THEN
(  386)     CALL ABORT_TRANS('TRANS_INQ: KPTRLS TOO SMALL')
(  387)   ELSE
(  388)     KPTRLS(1:NPRTRNS) = D%NPTRLS(:)
(  389)   ENDIF
(  390) ENDIF
(  391) # 392 "trans_inq.F90"
(  392) IF(PRESENT(KNMENG)) THEN
(  393)   IF(UBOUND(KNMENG,1) < R%NDGL) THEN
(  394)     CALL ABORT_TRANS('TRANS_INQ: KNMENG TOO SMALL')
(  395)   ELSE
(  396)     KNMENG(1:R%NDGL) = G%NMEN(1:R%NDGL)
(  397)   ENDIF
(  398) ENDIF
(  399) # 400 "trans_inq.F90"
(  400) IF(PRESENT(PMU)) THEN
(  401)   IF(UBOUND(PMU,1) < R%NDGL) THEN
(  402)     CALL ABORT_TRANS('TRANS_INQ: PMU TOO SMALL')
(  403)   ELSE
(  404)     PMU(1:R%NDGL) = F%RMU
(  405)   ENDIF
(  406) ENDIF






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 18

(  407) # 408 "trans_inq.F90"
(  408) IF(PRESENT(PGW)) THEN
(  409)   IF(UBOUND(PGW,1) < R%NDGL) THEN
(  410)     CALL ABORT_TRANS('TRANS_INQ: PGW TOO SMALL')
(  411)   ELSE
(  412)     PGW(1:R%NDGL) = REAl(F%RW,JPRB)
(  413)   ENDIF
(  414) ENDIF
(  415) # 416 "trans_inq.F90"
(  416) IF(PRESENT(PRPNM)) THEN
(  417) # 418 "trans_inq.F90"
(  418)   IF( .NOT. S%LKEEPRPNM ) THEN
(  419)     CALL ABORT_TRANS('TRANS_INQ: PRPNM REQUIRED BUT S%LKEEPRPNM=F')
(  420)   ENDIF
(  421)   
(  422)   IF(D%LGRIDONLY) THEN
(  423)     CALL ABORT_TRANS('TRANS_INQ: PRPNM REQUIRED BUT LGRIDONLY=T')
(  424)   ENDIF
(  425)   IU1 = UBOUND(PRPNM,1)
(  426)   IU2 = UBOUND(PRPNM,2)
(  427)   IF(IU1 < R%NDGNH) THEN
(  428)     CALL ABORT_TRANS('TRANS_INQ:FIRST DIM. OF PRNM TOO SMALL')
(  429)   ELSE
(  430) !    IU1 = MIN(IU1,R%NLEI3)
(  431) !    IU2 = MIN(IU2,D%NSPOLEGL)
(  432) !    PRPNM(1:IU1,1:IU2) = F%RPNM(1:IU1,1:IU2)
(  433) # 434 "trans_inq.F90"
(  434)     DO JMLOC=1,D%NUMP,NPRTRV
(  435)       IPRTRV=MIN(NPRTRV,D%NUMP-JMLOC+1)
(  436)       DO JSETV=1,IPRTRV
(  437)         IMLOC=JMLOC+JSETV-1
(  438)         IM = D%MYMS(IMLOC)
(  439)         ISL = MAX(R%NDGNH-G%NDGLU(IM)+1,1)
(  440)         IA  = 1+MOD(R%NSMAX-IM+2,2)
(  441)         ILA = (R%NSMAX-IM+2)/2
(  442)         IS  = 1+MOD(R%NSMAX-IM+1,2)
(  443)         ILS = (R%NSMAX-IM+3)/2
(  444)         IDGLU = MIN(R%NDGNH,G%NDGLU(IM))
(  445)         DO J=1,ILA
(  446)           DO I=1,IDGLU
(  447)             PRPNM(ISL+I-1,D%NPMS(IM)+IA+(J-1)*2) = REAL(S%FA(IMLOC)%RPNMA(I,J),JPRB)
(  448)           ENDDO
(  449)         ENDDO
(  450)         DO J=1,ILS
(  451)           DO I=1,IDGLU
(  452)             PRPNM(ISL+I-1,D%NPMS(IM)+IS+(J-1)*2) = REAL(S%FA(IMLOC)%RPNMS(I,J),JPRB)
(  453)           ENDDO
(  454)         ENDDO
(  455)       ENDDO
(  456)     ENDDO
(  457)   ENDIF
(  458) ENDIF
(  459) IF(PRESENT(KLEI3)) THEN
(  460)   KLEI3=R%NLEI3
(  461) ENDIF
(  462) IF(PRESENT(KSPOLEGL)) THEN
(  463)   KSPOLEGL=D%NSPOLEGL
(  464) ENDIF






NVFORTRAN (Version    20.11)          02/16/2022  17:31:06      page 19

(  465) IF(PRESENT(KPMS)) THEN
(  466)   IF(D%LGRIDONLY) THEN
(  467)     CALL ABORT_TRANS('TRANS_INQ: KPMS REQUIRED BUT LGRIDONLY=T')
(  468)   ENDIF
(  469)   IF(UBOUND(KPMS,1) < R%NSMAX) THEN
(  470)     CALL ABORT_TRANS('TRANS_INQ: KPMS TOO SMALL')
(  471)   ELSE
(  472)     KPMS(0:R%NSMAX) = D%NPMS(0:R%NSMAX)
(  473)   ENDIF
(  474) ENDIF
(  475) # 476 "trans_inq.F90"
(  476) IF(PRESENT(KSMAX)) KSMAX = R%NSMAX
(  477) IF(PRESENT(PLAPIN)) THEN
(  478)   IF(D%LGRIDONLY) THEN
(  479)     CALL ABORT_TRANS('TRANS_INQ: PLAPIN REQUIRED BUT LGRIDONLY=T')
(  480)   ENDIF
(  481)   IF(UBOUND(PLAPIN,1) < R%NSMAX+2) THEN
(  482)     CALL ABORT_TRANS('TRANS_INQ: PLAPIN TOO SMALL')
(  483)   ELSEIF (LBOUND(PLAPIN,1) /= -1) THEN
(  484)     CALL ABORT_TRANS('TRANS_INQ: LOWER BOUND OF PLAPIN SHOULD BE -1')
(  485)   ELSE
(  486)     PLAPIN(-1:R%NSMAX+2) = REAL(F%RLAPIN(:),JPRB)
(  487)   ENDIF
(  488) ENDIF
(  489) IF(PRESENT(KNVALUE)) THEN
(  490)   IF(D%LGRIDONLY) THEN
(  491)     CALL ABORT_TRANS('TRANS_INQ: KNVALUE REQUIRED BUT LGRIDONLY=T')
(  492)   ENDIF
(  493)   IF(SIZE(KNVALUE) < D%NSPEC2) THEN
(  494)     CALL ABORT_TRANS('TRANS_INQ: KNVALUE TOO SMALL')
(  495)   ELSE
(  496)     IC=1
(  497)     DO JMLOC=1,D%NUMP
(  498)       DO JN=D%MYMS(JMLOC),R%NSMAX
(  499)         KNVALUE(IC  )=JN
(  500)         KNVALUE(IC+1)=JN
(  501)         IC=IC+2
(  502)       ENDDO
(  503)     ENDDO
(  504)   ENDIF
(  505) ENDIF
(  506) # 508 "trans_inq.F90"
(  508) IF(PRESENT(KDGLU)) THEN
(  509)   IF(UBOUND(KDGLU,1) < R%NSMAX) THEN
(  510)     CALL ABORT_TRANS('TRANS_INQ: KDGLU TOO SMALL')
(  511)   ELSE
(  512)     KDGLU(0:R%NSMAX) = G%NDGLU(0:R%NSMAX)
(  513)   ENDIF
(  514) ENDIF
(  515) !     ------------------------------------------------------------------
(  516) # 517 "trans_inq.F90"
(  517) !endif INTERFACE
(  518) # 519 "trans_inq.F90"
(  519) END SUBROUTINE TRANS_INQ
