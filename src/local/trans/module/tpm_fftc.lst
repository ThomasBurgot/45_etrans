


NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/include
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/lib
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: tpm_fftc.F90

(    1) MODULE TPM_FFTC
(    2) 
(    3) !   Author.
(    4) !   -------
(    5) !     George Mozdzynski
(    6) !
(    7) !   Modifications.
(    8) !   -------------- 
(    9) !     Original      October 2014
(   10) 
(   11) USE, INTRINSIC :: ISO_C_BINDING
(   12) 
(   13) USE PARKIND1, ONLY: JPIB, JPIM, JPRBT
(   14) USE MPL_MODULE, ONLY : MPL_MYRANK
(   15) 
(   16) IMPLICIT NONE
(   17) 
(   18) SAVE
(   19) 
(   20) PRIVATE
(   21) PUBLIC CREATE_PLAN_FFT, DESTROY_PLAN_FFT, DESTROY_ALL_PLANS_FFT, INIT_PLANS_FFT, &
(   22)       & FFTC_RESOL, TC
(   23) 
(   24) TYPE FFTC_TYPE
(   25)   INTEGER(KIND=JPIM),POINTER :: N_PLANS(:)
(   26)   TYPE(FFTC_PLAN),POINTER :: FFTC_PLANS(:)
(   27)   INTEGER(KIND=JPIM) :: N_MAX=0
(   28)   INTEGER(KIND=JPIM) :: N_MAX_PLANS=8
(   29) END TYPE FFTC_TYPE
(   30) 
(   31) 
(   32) TYPE FFTC_PLAN
(   33)   INTEGER(KIND=JPIM) :: NPLAN_ID=123456






NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 2

(   34)   INTEGER(KIND=JPIM) :: NPLAN
(   35)   INTEGER(KIND=JPIM) :: NLOT
(   36)   INTEGER(KIND=JPIM) :: NTYPE
(   37)   INTEGER(KIND=JPIM) :: NISTRIDE
(   38)   INTEGER(KIND=JPIM) :: NIDIST
(   39)   INTEGER(KIND=JPIM) :: NOSTRIDE
(   40)   INTEGER(KIND=JPIM) :: NODIST
(   41)   TYPE(FFTC_PLAN),POINTER :: NEXT_PLAN => NULL()
(   42) END TYPE FFTC_PLAN
(   43) 
(   44) TYPE(FFTC_TYPE),ALLOCATABLE,TARGET :: FFTC_RESOL(:)
(   45) TYPE(FFTC_TYPE),POINTER     :: TC
(   46) 
(   47) ! ------------------------------------------------------------------
(   48) CONTAINS
(   49) ! ------------------------------------------------------------------
(   50) 
(   51) 
(   52) SUBROUTINE INIT_PLANS_FFT(KDLON)
(   53) INTEGER(KIND=JPIM),INTENT(IN) :: KDLON
(   54) 
(   55) TC%N_MAX=KDLON
(   56) ALLOCATE(TC%FFTC_PLANS(TC%N_MAX))
(   57) ALLOCATE(TC%N_PLANS(TC%N_MAX))
(   58) TC%N_PLANS(:)=0
(   59) RETURN  
(   60) END SUBROUTINE INIT_PLANS_FFT
(   61) 
(   62) 
(   63) SUBROUTINE CREATE_PLAN_FFT (KPLAN, KTYPE, KN, KLOT, KISTRIDE, KIDIST, KOSTRIDE, KODIST)
(   64) INTEGER(KIND=JPIM),INTENT(OUT) :: KPLAN
(   65) INTEGER(KIND=JPIM),INTENT(IN)  :: KTYPE, KN, KLOT
(   66) INTEGER(KIND=JPIM), OPTIONAL, INTENT (IN) :: KISTRIDE, KIDIST
(   67) INTEGER(KIND=JPIM), OPTIONAL, INTENT (IN) :: KOSTRIDE, KODIST
(   68) 
(   69) INTEGER(KIND=JPIM) :: IPLAN
(   70) INTEGER(KIND=JPIM) :: JL, JN
(   71) LOGICAL :: LLFOUND
(   72) LOGICAL :: LLRESTRICT_PLANS=.TRUE.
(   73) TYPE(FFTC_PLAN),POINTER :: CURR_FFTC_PLAN, START_FFTC_PLAN
(   74) 
(   75) INTEGER (KIND=JPIM) :: IISTRIDE, IIDIST, IOSTRIDE, IODIST
(   76) 
(   77) INTERFACE
(   78)   SUBROUTINE CREATE_PLAN_FFTC (KPLAN, KN, KISTRIDE, KIDIST, KOSTRIDE, KODIST, KTYPE, KLOT) &
(   79)            & BIND(C,NAME="create_plan_fftc_")
(   80)    USE, INTRINSIC :: ISO_C_BINDING
(   81)    INTEGER(C_INT) :: KPLAN
(   82)    INTEGER(C_INT) :: KTYPE, KN, KLOT, KISTRIDE, KIDIST, KOSTRIDE, KODIST
(   83)   END SUBROUTINE CREATE_PLAN_FFTC
(   84) END INTERFACE
(   85) 
(   86) IISTRIDE = KLOT; IF (PRESENT (KISTRIDE)) IISTRIDE = KISTRIDE
(   87) IIDIST   =    1; IF (PRESENT (KIDIST  )) IIDIST   = KIDIST   
(   88) IOSTRIDE = KLOT; IF (PRESENT (KOSTRIDE)) IOSTRIDE = KOSTRIDE
(   89) IODIST   =    1; IF (PRESENT (KODIST  )) IODIST   = KODIST   
(   90) 
(   91) IF( KN > TC%N_MAX )THEN






NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 3

(   92)   CALL ABOR1('CREATE_PLAN_FFT: KN > N_MAX THAT WAS INITIALISED IN INIT_PLANS_FFTC')
(   93) ENDIF
(   94) 
(   95) !!$OMP CRITICAL
(   96) LLFOUND=.FALSE.
(   97) IF( TC%FFTC_PLANS(KN)%NPLAN_ID /= 123456 )THEN
(   98)   WRITE(*,'("CREATE_PLAN_FFT.1: PLAN_ID=",I10)')TC%FFTC_PLANS(KN)%NPLAN_ID
(   99)   CALL ABOR1('CREATE_PLAN_FFT.1: NPLAN_ID /= 123456')
(  100) ENDIF
(  101) CURR_FFTC_PLAN=>TC%FFTC_PLANS(KN)
(  102) IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
(  103)   WRITE(*,'("CREATE_PLAN_FFT.2: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
(  104)   CALL ABOR1('CREATE_PLAN_FFT.2: NPLAN_ID /= 123456')
(  105) ENDIF
(  106) ! search for plan in existing plans
(  107) DO JL=1,TC%N_PLANS(KN)
(  108)   IF( KLOT == CURR_FFTC_PLAN%NLOT .AND. KTYPE == CURR_FFTC_PLAN%NTYPE .AND. &
(  109)     & IISTRIDE == CURR_FFTC_PLAN%NISTRIDE .AND. IIDIST == CURR_FFTC_PLAN%NIDIST .AND. &
(  110)     & IOSTRIDE == CURR_FFTC_PLAN%NOSTRIDE .AND. IODIST == CURR_FFTC_PLAN%NODIST )THEN
(  111)     LLFOUND=.TRUE.
(  112)     IPLAN=CURR_FFTC_PLAN%NPLAN
(  113)     EXIT
(  114)   ELSEIF( JL /= TC%N_PLANS(KN) )THEN
(  115)     CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN
(  116)     IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
(  117)       WRITE(*,'("CREATE_PLAN_FFT.3: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
(  118)       CALL ABOR1('CREATE_PLAN_FFT.3: NPLAN_ID /= 123456')
(  119)     ENDIF
(  120)   ENDIF
(  121) ENDDO
(  122) IF( .NOT.LLFOUND )THEN
(  123)   IF( LLRESTRICT_PLANS )THEN
(  124)     IF( TC%N_PLANS(KN) == TC%N_MAX_PLANS )THEN
(  125)       ! destroy the plan at the start of the list
(  126) !     WRITE(*,'("CREATE_PLAN_FFT: BEG: DESTROYING A PLAN AT THE START OF THE LIST")')
(  127)       CALL DESTROY_PLAN_FFT(TC%FFTC_PLANS(KN)%NPLAN)
(  128)       TC%FFTC_PLANS(KN)%NPLAN_ID=999999
(  129)       START_FFTC_PLAN=>TC%FFTC_PLANS(KN)
(  130)       TC%FFTC_PLANS(KN)=TC%FFTC_PLANS(KN)%NEXT_PLAN
(  131)       ! DEALLOCATE(START_FFTC_PLAN)
(  132)       TC%N_PLANS(KN)=TC%N_PLANS(KN)-1
(  133) !     WRITE(*,'("CREATE_PLAN_FFT: END: DESTROYING A PLAN AT THE START OF THE LIST")')
(  134)     ENDIF
(  135)   ENDIF
(  136)   CALL CREATE_PLAN_FFTC(IPLAN, KTYPE=KTYPE, KN=KN, KLOT=KLOT, KISTRIDE=IISTRIDE, &
(  137)                       & KIDIST=IIDIST, KOSTRIDE=IOSTRIDE, KODIST=IODIST)
(  138)   KPLAN=IPLAN
(  139)   TC%N_PLANS(KN)=TC%N_PLANS(KN)+1
(  140)   IF( TC%N_PLANS(KN) /= 1 )THEN
(  141)     ALLOCATE(CURR_FFTC_PLAN%NEXT_PLAN)
(  142)     CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN
(  143)   ENDIF
(  144)   IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
(  145)     WRITE(*,'("CREATE_PLAN_FFT.4: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
(  146)     CALL ABOR1('CREATE_PLAN_FFT.4: NPLAN_ID /= 123456')
(  147)   ENDIF
(  148)   CURR_FFTC_PLAN%NPLAN    = IPLAN
(  149)   CURR_FFTC_PLAN%NLOT     = KLOT






NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 4

(  150)   CURR_FFTC_PLAN%NTYPE    = KTYPE
(  151)   CURR_FFTC_PLAN%NISTRIDE = IISTRIDE
(  152)   CURR_FFTC_PLAN%NIDIST   = IIDIST
(  153)   CURR_FFTC_PLAN%NOSTRIDE = IOSTRIDE
(  154)   CURR_FFTC_PLAN%NODIST   = IODIST
(  155)   CURR_FFTC_PLAN%NEXT_PLAN=>NULL()
(  156) ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
(  157) !  & " NEW IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
(  158) ELSE
(  159)   KPLAN=IPLAN
(  160) ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
(  161) !  & " CUR IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
(  162) ENDIF
(  163) !!$OMP END CRITICAL
(  164) 
(  165) RETURN
(  166) END SUBROUTINE CREATE_PLAN_FFT
(  167) 
(  168) 
(  169) SUBROUTINE DESTROY_PLAN_FFT(KPLAN)
(  170) INTEGER(KIND=JPIM),INTENT(IN) :: KPLAN
(  171) !!$OMP CRITICAL
(  172) !!$ACC host_data use_device(KPLAN)
(  173) CALL DESTROY_PLAN_FFTC(KPLAN)
(  174) !!$ACC end host_data
(  175) !!$OMP END CRITICAL
(  176) RETURN
(  177) END SUBROUTINE DESTROY_PLAN_FFT
(  178) 
(  179) 
(  180) SUBROUTINE DESTROY_ALL_PLANS_FFT
(  181) INTEGER(KIND=JPIM) :: JL, JN
(  182) TYPE(FFTC_PLAN),POINTER :: CURR_FFTC_PLAN
(  183) DO JN=1,TC%N_MAX
(  184)   CURR_FFTC_PLAN=>TC%FFTC_PLANS(JN)
(  185) ! DO JL=1,TC%N_PLANS(JN)
(  186) !   !$ACC host_data use_device(CURR_FFTC_PLAN%NPLAN)
(  187) !   CALL DESTROY_PLAN_FFTC(CURR_FFTC_PLAN%NPLAN)
(  188) !   !$ACC end host_data
(  189) !   CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN 
(  190) ! ENDDO
(  191) ENDDO
(  192) WRITE(*,'("DESTROY_ALL_PLANS_FFTC: MPL_RANK=",I6," SUM(TC%N_PLANS(:))=",I10)')&
(  193)   & MPL_MYRANK(), SUM(TC%N_PLANS(:))
(  194) DEALLOCATE(TC%FFTC_PLANS)
(  195) DEALLOCATE(TC%N_PLANS)
(  196) RETURN
(  197) END SUBROUTINE DESTROY_ALL_PLANS_FFT
(  198) 
(  199) 
(  200) END MODULE TPM_FFTC













NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 5

(    1) # 1 "tpm_fftc.F90"
(    1) MODULE TPM_FFTC
(    2) # 3 "tpm_fftc.F90"
(    3) !   Author.
(    4) !   -------
(    5) !     George Mozdzynski
(    6) !
(    7) !   Modifications.
(    8) !   -------------- 
(    9) !     Original      October 2014
(   10) # 11 "tpm_fftc.F90"
(   11) USE, INTRINSIC :: ISO_C_BINDING
(   12) # 13 "tpm_fftc.F90"
(   13) USE PARKIND1, ONLY: JPIB, JPIM, JPRBT
(   14) USE MPL_MODULE, ONLY : MPL_MYRANK
(   15) # 16 "tpm_fftc.F90"
(   16) IMPLICIT NONE
(   17) # 18 "tpm_fftc.F90"
(   18) SAVE
(   19) # 20 "tpm_fftc.F90"
(   20) PRIVATE
(   21) PUBLIC CREATE_PLAN_FFT, DESTROY_PLAN_FFT, DESTROY_ALL_PLANS_FFT, INIT_PLANS_FFT, &
(   22)       & FFTC_RESOL, TC
(   23) # 24 "tpm_fftc.F90"
(   24) TYPE FFTC_TYPE
(   25)   INTEGER(KIND=JPIM),POINTER :: N_PLANS(:)
(   26)   TYPE(FFTC_PLAN),POINTER :: FFTC_PLANS(:)
(   27)   INTEGER(KIND=JPIM) :: N_MAX=0
(   28)   INTEGER(KIND=JPIM) :: N_MAX_PLANS=8
(   29) END TYPE FFTC_TYPE
(   30) # 32 "tpm_fftc.F90"
(   32) TYPE FFTC_PLAN
(   33)   INTEGER(KIND=JPIM) :: NPLAN_ID=123456
(   34)   INTEGER(KIND=JPIM) :: NPLAN
(   35)   INTEGER(KIND=JPIM) :: NLOT
(   36)   INTEGER(KIND=JPIM) :: NTYPE
(   37)   INTEGER(KIND=JPIM) :: NISTRIDE
(   38)   INTEGER(KIND=JPIM) :: NIDIST
(   39)   INTEGER(KIND=JPIM) :: NOSTRIDE
(   40)   INTEGER(KIND=JPIM) :: NODIST
(   41)   TYPE(FFTC_PLAN),POINTER :: NEXT_PLAN => NULL()
(   42) END TYPE FFTC_PLAN
(   43) # 44 "tpm_fftc.F90"
(   44) TYPE(FFTC_TYPE),ALLOCATABLE,TARGET :: FFTC_RESOL(:)
(   45) TYPE(FFTC_TYPE),POINTER     :: TC
(   46) # 47 "tpm_fftc.F90"
(   47) ! ------------------------------------------------------------------
(   48) CONTAINS
(   49) ! ------------------------------------------------------------------
(   50) # 52 "tpm_fftc.F90"
(   52) SUBROUTINE INIT_PLANS_FFT(KDLON)
(   53) INTEGER(KIND=JPIM),INTENT(IN) :: KDLON
(   54) # 55 "tpm_fftc.F90"
(   55) TC%N_MAX=KDLON
(   56) ALLOCATE(TC%FFTC_PLANS(TC%N_MAX))
(   57) ALLOCATE(TC%N_PLANS(TC%N_MAX))
(   58) TC%N_PLANS(:)=0
(   59) RETURN  






NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 6

(   60) END SUBROUTINE INIT_PLANS_FFT
(   61) # 63 "tpm_fftc.F90"
(   63) SUBROUTINE CREATE_PLAN_FFT (KPLAN, KTYPE, KN, KLOT, KISTRIDE, KIDIST, KOSTRIDE, KODIST)
(   64) INTEGER(KIND=JPIM),INTENT(OUT) :: KPLAN
(   65) INTEGER(KIND=JPIM),INTENT(IN)  :: KTYPE, KN, KLOT
(   66) INTEGER(KIND=JPIM), OPTIONAL, INTENT (IN) :: KISTRIDE, KIDIST
(   67) INTEGER(KIND=JPIM), OPTIONAL, INTENT (IN) :: KOSTRIDE, KODIST
(   68) # 69 "tpm_fftc.F90"
(   69) INTEGER(KIND=JPIM) :: IPLAN
(   70) INTEGER(KIND=JPIM) :: JL, JN
(   71) LOGICAL :: LLFOUND
(   72) LOGICAL :: LLRESTRICT_PLANS=.TRUE.
(   73) TYPE(FFTC_PLAN),POINTER :: CURR_FFTC_PLAN, START_FFTC_PLAN
(   74) # 75 "tpm_fftc.F90"
(   75) INTEGER (KIND=JPIM) :: IISTRIDE, IIDIST, IOSTRIDE, IODIST
(   76) # 77 "tpm_fftc.F90"
(   77) INTERFACE
(   78)   SUBROUTINE CREATE_PLAN_FFTC (KPLAN, KN, KISTRIDE, KIDIST, KOSTRIDE, KODIST, KTYPE, KLOT) &
(   79)            & BIND(C,NAME="create_plan_fftc_")
(   80)    USE, INTRINSIC :: ISO_C_BINDING
(   81)    INTEGER(C_INT) :: KPLAN
(   82)    INTEGER(C_INT) :: KTYPE, KN, KLOT, KISTRIDE, KIDIST, KOSTRIDE, KODIST
(   83)   END SUBROUTINE CREATE_PLAN_FFTC
(   84) END INTERFACE
(   85) # 86 "tpm_fftc.F90"
(   86) IISTRIDE = KLOT; IF (PRESENT (KISTRIDE)) IISTRIDE = KISTRIDE
(   87) IIDIST   =    1; IF (PRESENT (KIDIST  )) IIDIST   = KIDIST   
(   88) IOSTRIDE = KLOT; IF (PRESENT (KOSTRIDE)) IOSTRIDE = KOSTRIDE
(   89) IODIST   =    1; IF (PRESENT (KODIST  )) IODIST   = KODIST   
(   90) # 91 "tpm_fftc.F90"
(   91) IF( KN > TC%N_MAX )THEN
(   92)   CALL ABOR1('CREATE_PLAN_FFT: KN > N_MAX THAT WAS INITIALISED IN INIT_PLANS_FFTC')
(   93) ENDIF
(   94) # 95 "tpm_fftc.F90"
(   95) !!$OMP CRITICAL
(   96) LLFOUND=.FALSE.
(   97) IF( TC%FFTC_PLANS(KN)%NPLAN_ID /= 123456 )THEN
(   98)   WRITE(*,'("CREATE_PLAN_FFT.1: PLAN_ID=",I10)')TC%FFTC_PLANS(KN)%NPLAN_ID
(   99)   CALL ABOR1('CREATE_PLAN_FFT.1: NPLAN_ID /= 123456')
(  100) ENDIF
(  101) CURR_FFTC_PLAN=>TC%FFTC_PLANS(KN)
(  102) IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
(  103)   WRITE(*,'("CREATE_PLAN_FFT.2: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
(  104)   CALL ABOR1('CREATE_PLAN_FFT.2: NPLAN_ID /= 123456')
(  105) ENDIF
(  106) ! search for plan in existing plans
(  107) DO JL=1,TC%N_PLANS(KN)
(  108)   IF( KLOT == CURR_FFTC_PLAN%NLOT .AND. KTYPE == CURR_FFTC_PLAN%NTYPE .AND. &
(  109)     & IISTRIDE == CURR_FFTC_PLAN%NISTRIDE .AND. IIDIST == CURR_FFTC_PLAN%NIDIST .AND. &
(  110)     & IOSTRIDE == CURR_FFTC_PLAN%NOSTRIDE .AND. IODIST == CURR_FFTC_PLAN%NODIST )THEN
(  111)     LLFOUND=.TRUE.
(  112)     IPLAN=CURR_FFTC_PLAN%NPLAN
(  113)     EXIT
(  114)   ELSEIF( JL /= TC%N_PLANS(KN) )THEN
(  115)     CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN
(  116)     IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
(  117)       WRITE(*,'("CREATE_PLAN_FFT.3: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
(  118)       CALL ABOR1('CREATE_PLAN_FFT.3: NPLAN_ID /= 123456')






NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 7

(  119)     ENDIF
(  120)   ENDIF
(  121) ENDDO
(  122) IF( .NOT.LLFOUND )THEN
(  123)   IF( LLRESTRICT_PLANS )THEN
(  124)     IF( TC%N_PLANS(KN) == TC%N_MAX_PLANS )THEN
(  125)       ! destroy the plan at the start of the list
(  126) !     WRITE(*,'("CREATE_PLAN_FFT: BEG: DESTROYING A PLAN AT THE START OF THE LIST")')
(  127)       CALL DESTROY_PLAN_FFT(TC%FFTC_PLANS(KN)%NPLAN)
(  128)       TC%FFTC_PLANS(KN)%NPLAN_ID=999999
(  129)       START_FFTC_PLAN=>TC%FFTC_PLANS(KN)
(  130)       TC%FFTC_PLANS(KN)=TC%FFTC_PLANS(KN)%NEXT_PLAN
(  131)       ! DEALLOCATE(START_FFTC_PLAN)
(  132)       TC%N_PLANS(KN)=TC%N_PLANS(KN)-1
(  133) !     WRITE(*,'("CREATE_PLAN_FFT: END: DESTROYING A PLAN AT THE START OF THE LIST")')
(  134)     ENDIF
(  135)   ENDIF
(  136)   CALL CREATE_PLAN_FFTC(IPLAN, KTYPE=KTYPE, KN=KN, KLOT=KLOT, KISTRIDE=IISTRIDE, &
(  137)                       & KIDIST=IIDIST, KOSTRIDE=IOSTRIDE, KODIST=IODIST)
(  138)   KPLAN=IPLAN
(  139)   TC%N_PLANS(KN)=TC%N_PLANS(KN)+1
(  140)   IF( TC%N_PLANS(KN) /= 1 )THEN
(  141)     ALLOCATE(CURR_FFTC_PLAN%NEXT_PLAN)
(  142)     CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN
(  143)   ENDIF
(  144)   IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
(  145)     WRITE(*,'("CREATE_PLAN_FFT.4: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
(  146)     CALL ABOR1('CREATE_PLAN_FFT.4: NPLAN_ID /= 123456')
(  147)   ENDIF
(  148)   CURR_FFTC_PLAN%NPLAN    = IPLAN
(  149)   CURR_FFTC_PLAN%NLOT     = KLOT
(  150)   CURR_FFTC_PLAN%NTYPE    = KTYPE
(  151)   CURR_FFTC_PLAN%NISTRIDE = IISTRIDE
(  152)   CURR_FFTC_PLAN%NIDIST   = IIDIST
(  153)   CURR_FFTC_PLAN%NOSTRIDE = IOSTRIDE
(  154)   CURR_FFTC_PLAN%NODIST   = IODIST
(  155)   CURR_FFTC_PLAN%NEXT_PLAN=>NULL()
(  156) ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
(  157) !  & " NEW IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
(  158) ELSE
(  159)   KPLAN=IPLAN
(  160) ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
(  161) !  & " CUR IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
(  162) ENDIF
(  163) !!$OMP END CRITICAL
(  164) # 165 "tpm_fftc.F90"
(  165) RETURN
(  166) END SUBROUTINE CREATE_PLAN_FFT
(  167) # 169 "tpm_fftc.F90"
(  169) SUBROUTINE DESTROY_PLAN_FFT(KPLAN)
(  170) INTEGER(KIND=JPIM),INTENT(IN) :: KPLAN
(  171) !!$OMP CRITICAL
(  172) !!$ACC host_data use_device(KPLAN)
(  173) CALL DESTROY_PLAN_FFTC(KPLAN)
(  174) !!$ACC end host_data
(  175) !!$OMP END CRITICAL
(  176) RETURN
(  177) END SUBROUTINE DESTROY_PLAN_FFT






NVFORTRAN (Version    20.11)          02/16/2022  17:28:29      page 8

(  178) # 180 "tpm_fftc.F90"
(  180) SUBROUTINE DESTROY_ALL_PLANS_FFT
(  181) INTEGER(KIND=JPIM) :: JL, JN
(  182) TYPE(FFTC_PLAN),POINTER :: CURR_FFTC_PLAN
(  183) DO JN=1,TC%N_MAX
(  184)   CURR_FFTC_PLAN=>TC%FFTC_PLANS(JN)
(  185) ! DO JL=1,TC%N_PLANS(JN)
(  186) !   !$ACC host_data use_device(CURR_FFTC_PLAN%NPLAN)
(  187) !   CALL DESTROY_PLAN_FFTC(CURR_FFTC_PLAN%NPLAN)
(  188) !   !$ACC end host_data
(  189) !   CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN 
(  190) ! ENDDO
(  191) ENDDO
(  192) WRITE(*,'("DESTROY_ALL_PLANS_FFTC: MPL_RANK=",I6," SUM(TC%N_PLANS(:))=",I10)')&
(  193)   & MPL_MYRANK(), SUM(TC%N_PLANS(:))
(  194) DEALLOCATE(TC%FFTC_PLANS)
(  195) DEALLOCATE(TC%N_PLANS)
(  196) RETURN
(  197) END SUBROUTINE DESTROY_ALL_PLANS_FFT
(  198) # 200 "tpm_fftc.F90"
(  200) END MODULE TPM_FFTC
