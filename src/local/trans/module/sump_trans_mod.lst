


NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/include
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/lib
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: sump_trans_mod.F90

(    1) MODULE SUMP_TRANS_MOD
(    2) CONTAINS
(    3) SUBROUTINE SUMP_TRANS
(    4) 
(    5) ! Set up distributed environment for the transform package (part 2)
(    6) 
(    7) ! Modifications :
(    8) ! P.Marguinaud : 11-Sep-2012 : Fix twice allocated pointer
(    9) 
(   10) USE PARKIND1  ,ONLY : JPIM     ,JPRBT,  JPRD
(   11) 
(   12) USE TPM_GEN         ,ONLY : NOUT, NPRINTLEV
(   13) USE TPM_DIM         ,ONLY : R
(   14) USE TPM_GEOMETRY    ,ONLY : G
(   15) USE TPM_DISTR       ,ONLY : D, LEQ_REGIONS, MYSETW, NPRTRNS, NPRTRW, NPROC, MYPROC
(   16) 
(   17) !USE SUWAVEDI_MOD
(   18) !USE PE2SET_MOD
(   19) USE SUMPLATF_MOD    ,ONLY : SUMPLATF
(   20) USE SUMPLAT_MOD     ,ONLY : SUMPLAT
(   21) USE SUSTAONL_MOD    ,ONLY : SUSTAONL
(   22) USE MYSENDSET_MOD   ,ONLY : MYSENDSET
(   23) USE MYRECVSET_MOD   ,ONLY : MYRECVSET
(   24) USE EQ_REGIONS_MOD  ,ONLY : MY_REGION_NS, MY_REGION_EW,           &
(   25)      &                      N_REGIONS, N_REGIONS_EW, N_REGIONS_NS
(   26) !
(   27) 
(   28) IMPLICIT NONE
(   29) 
(   30) INTEGER(KIND=JPIM) :: JM
(   31) INTEGER(KIND=JPIM) :: JGL,IGL,IPLAT,ISENDSET,IRECVSET,JML,IPOS,IM






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 2

(   32) INTEGER(KIND=JPIM) :: I1,I2,I3,IAUX0,IAUX1,JA1
(   33) INTEGER(KIND=JPIM) :: IGPTOT,IMEDIAP,IRESTM,JA,JB,IOFF
(   34) INTEGER(KIND=JPIM),ALLOCATABLE :: IGPTOTL(:,:)
(   35) 
(   36) REAL(KIND=JPRBT),ALLOCATABLE :: ZDUM(:)
(   37) REAL(KIND=JPRBT) :: ZMEDIAP
(   38) REAL(KIND=JPRD)    :: ZTIME0,ZTIME1,ZTIME2
(   39) 
(   40) LOGICAL    :: LLP1,LLP2
(   41) 
(   42) !     ------------------------------------------------------------------
(   43) 
(   44) 
(   45) LLP1 = NPRINTLEV>0
(   46) LLP2 = NPRINTLEV>1
(   47) IF(LLP1) WRITE(NOUT,*) '=== ENTER ROUTINE SUMP_TRANS ==='
(   48) 
(   49) IF(.NOT.D%LGRIDONLY) THEN
(   50)   ALLOCATE(D%NULTPP(NPRTRNS))
(   51)   IF(LLP2)WRITE(NOUT,9) 'D%NULTPP   ',SIZE(D%NULTPP   ),SHAPE(D%NULTPP   )
(   52)   ALLOCATE(D%NPTRLS(NPRTRNS))
(   53)   IF(LLP2)WRITE(NOUT,9) 'D%NPTRLS   ',SIZE(D%NPTRLS   ),SHAPE(D%NPTRLS   )
(   54)   ALLOCATE(D%NPROCL(R%NDGL))
(   55)   IF(LLP2)WRITE(NOUT,9) 'D%NPROCL   ',SIZE(D%NPROCL   ),SHAPE(D%NPROCL   )
(   56) 
(   57)   CALL SUMPLATF(R%NDGL,NPRTRNS,MYSETW,D%NULTPP,D%NPROCL,D%NPTRLS)
(   58)   D%NDGL_FS = D%NULTPP(MYSETW)
(   59) 
(   60) ! Help arrays for spectral to fourier space transposition
(   61)   ALLOCATE(D%NLTSGTB (NPRTRNS+1))
(   62)   IF(LLP2)WRITE(NOUT,9) 'D%NLTSGTB ',SIZE(D%NLTSGTB),SHAPE(D%NLTSGTB)
(   63)   ALLOCATE(D%NLTSFTB (NPRTRNS+1))
(   64)   IF(LLP2)WRITE(NOUT,9) 'D%NLTSFTB ',SIZE(D%NLTSFTB),SHAPE(D%NLTSFTB)
(   65)   ALLOCATE(D%NSTAGT0B(NPRTRNS+1))
(   66)   IF(LLP2)WRITE(NOUT,9) 'D%NSTAGT0B ',SIZE(D%NSTAGT0B),SHAPE(D%NSTAGT0B)
(   67)   ALLOCATE(D%NSTAGT1B(NPRTRNS+1))
(   68)   IF(LLP2)WRITE(NOUT,9) 'D%NSTAGT1B ',SIZE(D%NSTAGT1B),SHAPE(D%NSTAGT1B)
(   69)   ALLOCATE(D%MSTABF  (NPRTRNS+1))
(   70)   IF(LLP2)WRITE(NOUT,9) 'D%MSTABF ',SIZE(D%MSTABF),SHAPE(D%MSTABF)
(   71) 
(   72)   D%NLTSGTB(:) = 0
(   73)   DO JGL=1,D%NDGL_FS
(   74)     IGL = D%NPTRLS(MYSETW)+JGL-1
(   75)     DO JM=0,G%NMEN(IGL)
(   76)       D%NLTSGTB(D%NPROCM(JM)) = D%NLTSGTB(D%NPROCM(JM))+1
(   77)     ENDDO
(   78)   ENDDO
(   79)   DO JA=1,NPRTRW
(   80)     IPLAT = 0
(   81)     DO JGL=1,D%NULTPP(JA)
(   82)       IGL = D%NPTRLS(JA)+JGL-1
(   83)       DO JM=1,D%NUMP
(   84)         IF(IGL > R%NDGNH-G%NDGLU(D%MYMS(JM)) .AND. IGL <= R%NDGNH+G%NDGLU(D%MYMS(JM))) THEN
(   85)           IPLAT = IPLAT + 1
(   86)         ENDIF
(   87)       ENDDO
(   88)     ENDDO
(   89)     D%NLTSFTB(JA) = IPLAT






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 3

(   90)   ENDDO
(   91)   
(   92)   DO JA=1,NPRTRW-1
(   93)     ISENDSET = MYSENDSET(NPRTRW,MYSETW,JA)
(   94)     IRECVSET = MYRECVSET(NPRTRW,MYSETW,JA)
(   95)     D%MSTABF(IRECVSET) = ISENDSET
(   96)   ENDDO
(   97)   D%MSTABF(MYSETW) = MYSETW
(   98)   
(   99)   ALLOCATE(D%NPNTGTB0(0:R%NSMAX,D%NDGL_FS))
(  100)   IF(LLP2)WRITE(NOUT,9) 'D%NPNTGTB0 ',SIZE(D%NPNTGTB0 ),SHAPE(D%NPNTGTB0 )
(  101)   ALLOCATE(D%NPNTGTB1(D%NUMP,R%NDGL))
(  102)   IF(LLP2)WRITE(NOUT,9) 'D%NPNTGTB1 ',SIZE(D%NPNTGTB1 ),SHAPE(D%NPNTGTB1 )
(  103) 
(  104)   DO JA=1,NPRTRW
(  105)     IPOS = 0
(  106)     DO JGL=1,D%NULTPP(MYSETW)
(  107)       IGL = D%NPTRLS(MYSETW) + JGL - 1
(  108)       DO JML=D%NPTRMS(JA),D%NPTRMS(JA)+D%NUMPP(JA)-1
(  109)         IM = D%NALLMS(JML)
(  110)         IF (IM  <=  G%NMEN(IGL)) THEN
(  111)           D%NPNTGTB0(IM,JGL) = IPOS
(  112)           IPOS = IPOS+1
(  113)         ELSE
(  114)           D%NPNTGTB0(IM,JGL) = -99
(  115)         ENDIF
(  116)       ENDDO
(  117)     ENDDO
(  118)   ENDDO
(  119) 
(  120)   DO JA=1,NPRTRW
(  121)     IPOS = 0
(  122)     DO JGL=1,D%NULTPP(JA)
(  123)       IGL = D%NPTRLS(JA) + JGL - 1
(  124)       DO JM=1,D%NUMP
(  125)         IM = D%MYMS(JM)
(  126)         IF (IM  <=  G%NMEN(IGL)) THEN
(  127)           D%NPNTGTB1(JM,IGL) = IPOS
(  128)           IPOS = IPOS+1
(  129)         ELSE
(  130)           D%NPNTGTB1(JM,IGL) = -99
(  131)         ENDIF
(  132)       ENDDO
(  133)     ENDDO
(  134)   ENDDO
(  135) 
(  136)   IAUX0 = 0
(  137)   IAUX1 = 0
(  138)   DO JA=1,NPRTRNS-1
(  139)     I1 = MYSENDSET(NPRTRNS,MYSETW,JA)
(  140)     I2 = MYRECVSET(NPRTRNS,MYSETW,JA)
(  141)     I3 = -1
(  142)     DO JA1=1,NPRTRNS-1
(  143)       IF(MYSENDSET(NPRTRNS,MYSETW,JA1) == I2) I3 =MYRECVSET(NPRTRNS,MYSETW,JA1)
(  144)     ENDDO
(  145)     IAUX0 = MAX(D%NLTSFTB(I1),D%NLTSGTB(I2),IAUX0)
(  146)     IAUX1 = MAX(D%NLTSGTB(I2),D%NLTSFTB(I3),IAUX1)
(  147)   ENDDO






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 4

(  148)   IAUX0 = MAX(D%NLTSGTB(MYSETW),IAUX0)
(  149)   IAUX1 = MAX(D%NLTSGTB(MYSETW),IAUX1)
(  150)   DO JA=1,NPRTRNS+1
(  151)     D%NSTAGT0B(JA) = (JA-1)*IAUX0
(  152)     D%NSTAGT1B(JA) = (JA-1)*IAUX1
(  153)   ENDDO
(  154)   D%NLENGT0B = IAUX0*NPRTRNS
(  155)   D%NLENGT1B = IAUX1*NPRTRNS
(  156) ENDIF
(  157)   
(  158) ! GRIDPOINT SPACE
(  159) 
(  160) ALLOCATE(D%NFRSTLAT(N_REGIONS_NS))
(  161) IF(LLP2)WRITE(NOUT,9) 'D%NFRSTLAT ',SIZE(D%NFRSTLAT ),SHAPE(D%NFRSTLAT )
(  162) ALLOCATE(D%NLSTLAT(N_REGIONS_NS))
(  163) IF(LLP2)WRITE(NOUT,9) 'D%NLSTLAT  ',SIZE(D%NLSTLAT  ),SHAPE(D%NLSTLAT  )
(  164) ALLOCATE(D%NPTRLAT(R%NDGL))
(  165) IF(LLP2)WRITE(NOUT,9) 'D%NPTRLAT  ',SIZE(D%NPTRLAT  ),SHAPE(D%NPTRLAT  )
(  166) ALLOCATE(D%NPTRFRSTLAT(N_REGIONS_NS))
(  167) IF(LLP2)WRITE(NOUT,9) 'D%NPTRFRSTLAT',SIZE(D%NPTRFRSTLAT),SHAPE(D%NPTRFRSTLAT)
(  168) ALLOCATE(D%NPTRLSTLAT(N_REGIONS_NS))
(  169) IF(LLP2)WRITE(NOUT,9)'D%NPTRLSTLAT',SIZE(D%NPTRLSTLAT),SHAPE(D%NPTRLSTLAT)
(  170) ALLOCATE(D%LSPLITLAT(R%NDGL))
(  171) IF(LLP2)WRITE(NOUT,9) 'D%LSPLITLAT',SIZE(D%LSPLITLAT),SHAPE(D%LSPLITLAT)
(  172) ALLOCATE(D%NPROCA_GP(N_REGIONS_NS))
(  173) IF(LLP2)WRITE(NOUT,9) 'D%NPROCA_GP',SIZE(D%NPROCA_GP),SHAPE(D%NPROCA_GP)
(  174) 
(  175) 
(  176) IF(.NOT.D%LWEIGHTED_DISTR) THEN
(  177)   ALLOCATE(ZDUM(1))
(  178)   CALL SUMPLAT(R%NDGL,NPROC,N_REGIONS_NS,MY_REGION_NS,D%LSPLIT,LEQ_REGIONS,&
(  179)              &D%NFRSTLAT,D%NLSTLAT,D%NFRSTLOFF,D%NPTRLAT,&
(  180)              &D%NPTRFRSTLAT,D%NPTRLSTLAT,D%NPTRFLOFF,&
(  181)              &ZDUM,D%LWEIGHTED_DISTR,ZMEDIAP,D%NPROCA_GP,&
(  182)              &IMEDIAP,IRESTM,D%LSPLITLAT,MYPROC,G%NLOEN)
(  183) ELSE
(  184)   CALL SUMPLAT(R%NDGL,NPROC,N_REGIONS_NS,MY_REGION_NS,D%LSPLIT,LEQ_REGIONS,&
(  185)              &D%NFRSTLAT,D%NLSTLAT,D%NFRSTLOFF,D%NPTRLAT,&
(  186)              &D%NPTRFRSTLAT,D%NPTRLSTLAT,D%NPTRFLOFF,&
(  187)              &D%RWEIGHT,D%LWEIGHTED_DISTR,ZMEDIAP,D%NPROCA_GP,&
(  188)              &IMEDIAP,IRESTM,D%LSPLITLAT,MYPROC,G%NLOEN)
(  189) ENDIF
(  190) D%NDGL_GP = D%NLSTLAT(MY_REGION_NS)-D%NFRSTLOFF
(  191) 
(  192) IF (LLP1) THEN
(  193)   IF(.NOT.D%LGRIDONLY) THEN
(  194)     WRITE(NOUT,FMT='(/'' OUTPUT FROM ROUTINE SUMPLAT: ''/)')
(  195)     WRITE(NOUT,FMT='('' D%NULTPP '')')
(  196)     WRITE(NOUT,FMT='(20(1X,I4))') D%NULTPP(1:NPRTRNS)
(  197)     WRITE(NOUT,FMT='('' D%NPROCL '')')
(  198)     WRITE(NOUT,FMT='(20(1X,I4))') D%NPROCL(1:R%NDGL)
(  199)   ENDIF
(  200)   WRITE(NOUT,FMT='('' D%NFRSTLAT '')')
(  201)   WRITE(NOUT,FMT='(20(1X,I4))') D%NFRSTLAT(1:N_REGIONS_NS)
(  202)   WRITE(NOUT,FMT='('' D%NLSTLAT '')')
(  203)   WRITE(NOUT,FMT='(20(1X,I4))') D%NLSTLAT(1:N_REGIONS_NS)
(  204)   WRITE(NOUT,FMT='('' D%NFRSTLOFF  D%NPTRFLOFF '')')
(  205)   WRITE(NOUT,FMT='(2(1X,I6))') D%NFRSTLOFF, D%NPTRFLOFF






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 5

(  206)   WRITE(NOUT,FMT='('' D%NPTRLAT '')')
(  207)   WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRLAT(1:R%NDGL)
(  208)   WRITE(NOUT,FMT='('' D%LSPLITLAT '')')
(  209)   WRITE(NOUT,FMT='(50(1X,L1))') D%LSPLITLAT(1:R%NDGL)
(  210)   WRITE(NOUT,FMT='('' D%NPTRFRSTLAT '')')
(  211)   WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRFRSTLAT(1:N_REGIONS_NS)
(  212)   WRITE(NOUT,FMT='('' D%NPTRLSTLAT '')')
(  213)   WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRLSTLAT(1:N_REGIONS_NS)
(  214)   WRITE(NOUT,FMT='(/)')
(  215) ENDIF
(  216) ALLOCATE(D%NSTA(R%NDGL+N_REGIONS_NS-1,N_REGIONS_EW))
(  217) IF(LLP2)WRITE(NOUT,9) 'D%NSTA     ',SIZE(D%NSTA     ),SHAPE(D%NSTA     )
(  218) ALLOCATE(D%NONL(R%NDGL+N_REGIONS_NS-1,N_REGIONS_EW))
(  219) IF(LLP2)WRITE(NOUT,9) 'D%NONL     ',SIZE(D%NONL     ),SHAPE(D%NONL     )
(  220) 
(  221) IF(.NOT.D%LWEIGHTED_DISTR) THEN
(  222)   CALL SUSTAONL(IMEDIAP,IRESTM,D%LWEIGHTED_DISTR,ZDUM,ZMEDIAP,D%NPROCA_GP)
(  223) ELSE
(  224)   CALL SUSTAONL(IMEDIAP,IRESTM,D%LWEIGHTED_DISTR,D%RWEIGHT,ZMEDIAP,D%NPROCA_GP)
(  225) ENDIF
(  226) !  IGPTOTL is the number of grid points in each individual processor
(  227) ALLOCATE(IGPTOTL(N_REGIONS_NS,N_REGIONS_EW))
(  228) IGPTOTL(:,:)=0
(  229) 
(  230) DO JA=1,N_REGIONS_NS
(  231)   DO JB=1,N_REGIONS(JA)
(  232)     IGPTOT = 0
(  233)     DO JGL=D%NPTRFRSTLAT(JA),D%NPTRLSTLAT(JA)
(  234)       IGPTOT = IGPTOT+D%NONL(JGL,JB)
(  235)     ENDDO
(  236)     IGPTOTL(JA,JB) = IGPTOT
(  237)   ENDDO
(  238) ENDDO
(  239) D%NGPTOT = IGPTOTL(MY_REGION_NS,MY_REGION_EW)
(  240) D%NGPTOTMX = MAXVAL(IGPTOTL)
(  241) D%NGPTOTG = SUM(IGPTOTL)
(  242) ALLOCATE(D%NGPTOTL(N_REGIONS_NS,N_REGIONS_EW))
(  243) IF(LLP2)WRITE(NOUT,9) 'D%NGPTOTL     ',SIZE(D%NGPTOTL ),SHAPE(D%NGPTOTL  )
(  244) D%NGPTOTL(:,:) = IGPTOTL(:,:)
(  245) 
(  246) IF(.NOT.D%LGRIDONLY) THEN
(  247)   ALLOCATE(D%NSTAGTF(D%NDGL_FS))
(  248)   IF(LLP2)WRITE(NOUT,9) 'D%NSTAGTF     ',SIZE(D%NSTAGTF ),SHAPE(D%NSTAGTF  )
(  249)   IOFF = 0
(  250)   DO JGL=1,D%NDGL_FS
(  251)     D%NSTAGTF(JGL) = IOFF
(  252)     IGL = D%NPTRLS(MYSETW) + JGL - 1
(  253)     IOFF = IOFF + G%NLOEN(IGL)+3
(  254)   ENDDO
(  255)   D%NLENGTF = IOFF
(  256) ENDIF
(  257) 
(  258) IF(ALLOCATED(ZDUM)) DEALLOCATE(ZDUM)
(  259) DEALLOCATE(IGPTOTL)
(  260) 
(  261) !     ------------------------------------------------------------------
(  262) 9 FORMAT(1X,'ARRAY ',A10,' ALLOCATED ',8I8)
(  263) 






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 6

(  264) END SUBROUTINE SUMP_TRANS
(  265) END MODULE SUMP_TRANS_MOD
(  266) 





























































NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 7

(    1) # 1 "sump_trans_mod.F90"
(    1) MODULE SUMP_TRANS_MOD
(    2) CONTAINS
(    3) SUBROUTINE SUMP_TRANS
(    4) # 5 "sump_trans_mod.F90"
(    5) ! Set up distributed environment for the transform package (part 2)
(    6) # 7 "sump_trans_mod.F90"
(    7) ! Modifications :
(    8) ! P.Marguinaud : 11-Sep-2012 : Fix twice allocated pointer
(    9) # 10 "sump_trans_mod.F90"
(   10) USE PARKIND1  ,ONLY : JPIM     ,JPRBT,  JPRD
(   11) # 12 "sump_trans_mod.F90"
(   12) USE TPM_GEN         ,ONLY : NOUT, NPRINTLEV
(   13) USE TPM_DIM         ,ONLY : R
(   14) USE TPM_GEOMETRY    ,ONLY : G
(   15) USE TPM_DISTR       ,ONLY : D, LEQ_REGIONS, MYSETW, NPRTRNS, NPRTRW, NPROC, MYPROC
(   16) # 17 "sump_trans_mod.F90"
(   17) !USE SUWAVEDI_MOD
(   18) !USE PE2SET_MOD
(   19) USE SUMPLATF_MOD    ,ONLY : SUMPLATF
(   20) USE SUMPLAT_MOD     ,ONLY : SUMPLAT
(   21) USE SUSTAONL_MOD    ,ONLY : SUSTAONL
(   22) USE MYSENDSET_MOD   ,ONLY : MYSENDSET
(   23) USE MYRECVSET_MOD   ,ONLY : MYRECVSET
(   24) USE EQ_REGIONS_MOD  ,ONLY : MY_REGION_NS, MY_REGION_EW,           &
(   25)      &                      N_REGIONS, N_REGIONS_EW, N_REGIONS_NS
(   26) !
(   27) # 28 "sump_trans_mod.F90"
(   28) IMPLICIT NONE
(   29) # 30 "sump_trans_mod.F90"
(   30) INTEGER(KIND=JPIM) :: JM
(   31) INTEGER(KIND=JPIM) :: JGL,IGL,IPLAT,ISENDSET,IRECVSET,JML,IPOS,IM
(   32) INTEGER(KIND=JPIM) :: I1,I2,I3,IAUX0,IAUX1,JA1
(   33) INTEGER(KIND=JPIM) :: IGPTOT,IMEDIAP,IRESTM,JA,JB,IOFF
(   34) INTEGER(KIND=JPIM),ALLOCATABLE :: IGPTOTL(:,:)
(   35) # 36 "sump_trans_mod.F90"
(   36) REAL(KIND=JPRBT),ALLOCATABLE :: ZDUM(:)
(   37) REAL(KIND=JPRBT) :: ZMEDIAP
(   38) REAL(KIND=JPRD)    :: ZTIME0,ZTIME1,ZTIME2
(   39) # 40 "sump_trans_mod.F90"
(   40) LOGICAL    :: LLP1,LLP2
(   41) # 42 "sump_trans_mod.F90"
(   42) !     ------------------------------------------------------------------
(   43) # 45 "sump_trans_mod.F90"
(   45) LLP1 = NPRINTLEV>0
(   46) LLP2 = NPRINTLEV>1
(   47) IF(LLP1) WRITE(NOUT,*) '=== ENTER ROUTINE SUMP_TRANS ==='
(   48) # 49 "sump_trans_mod.F90"
(   49) IF(.NOT.D%LGRIDONLY) THEN
(   50)   ALLOCATE(D%NULTPP(NPRTRNS))
(   51)   IF(LLP2)WRITE(NOUT,9) 'D%NULTPP   ',SIZE(D%NULTPP   ),SHAPE(D%NULTPP   )
(   52)   ALLOCATE(D%NPTRLS(NPRTRNS))
(   53)   IF(LLP2)WRITE(NOUT,9) 'D%NPTRLS   ',SIZE(D%NPTRLS   ),SHAPE(D%NPTRLS   )
(   54)   ALLOCATE(D%NPROCL(R%NDGL))
(   55)   IF(LLP2)WRITE(NOUT,9) 'D%NPROCL   ',SIZE(D%NPROCL   ),SHAPE(D%NPROCL   )
(   56) # 57 "sump_trans_mod.F90"
(   57)   CALL SUMPLATF(R%NDGL,NPRTRNS,MYSETW,D%NULTPP,D%NPROCL,D%NPTRLS)
(   58)   D%NDGL_FS = D%NULTPP(MYSETW)






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 8

(   59) # 60 "sump_trans_mod.F90"
(   60) ! Help arrays for spectral to fourier space transposition
(   61)   ALLOCATE(D%NLTSGTB (NPRTRNS+1))
(   62)   IF(LLP2)WRITE(NOUT,9) 'D%NLTSGTB ',SIZE(D%NLTSGTB),SHAPE(D%NLTSGTB)
(   63)   ALLOCATE(D%NLTSFTB (NPRTRNS+1))
(   64)   IF(LLP2)WRITE(NOUT,9) 'D%NLTSFTB ',SIZE(D%NLTSFTB),SHAPE(D%NLTSFTB)
(   65)   ALLOCATE(D%NSTAGT0B(NPRTRNS+1))
(   66)   IF(LLP2)WRITE(NOUT,9) 'D%NSTAGT0B ',SIZE(D%NSTAGT0B),SHAPE(D%NSTAGT0B)
(   67)   ALLOCATE(D%NSTAGT1B(NPRTRNS+1))
(   68)   IF(LLP2)WRITE(NOUT,9) 'D%NSTAGT1B ',SIZE(D%NSTAGT1B),SHAPE(D%NSTAGT1B)
(   69)   ALLOCATE(D%MSTABF  (NPRTRNS+1))
(   70)   IF(LLP2)WRITE(NOUT,9) 'D%MSTABF ',SIZE(D%MSTABF),SHAPE(D%MSTABF)
(   71) # 72 "sump_trans_mod.F90"
(   72)   D%NLTSGTB(:) = 0
(   73)   DO JGL=1,D%NDGL_FS
(   74)     IGL = D%NPTRLS(MYSETW)+JGL-1
(   75)     DO JM=0,G%NMEN(IGL)
(   76)       D%NLTSGTB(D%NPROCM(JM)) = D%NLTSGTB(D%NPROCM(JM))+1
(   77)     ENDDO
(   78)   ENDDO
(   79)   DO JA=1,NPRTRW
(   80)     IPLAT = 0
(   81)     DO JGL=1,D%NULTPP(JA)
(   82)       IGL = D%NPTRLS(JA)+JGL-1
(   83)       DO JM=1,D%NUMP
(   84)         IF(IGL > R%NDGNH-G%NDGLU(D%MYMS(JM)) .AND. IGL <= R%NDGNH+G%NDGLU(D%MYMS(JM))) THEN
(   85)           IPLAT = IPLAT + 1
(   86)         ENDIF
(   87)       ENDDO
(   88)     ENDDO
(   89)     D%NLTSFTB(JA) = IPLAT
(   90)   ENDDO
(   91)   
(   92)   DO JA=1,NPRTRW-1
(   93)     ISENDSET = MYSENDSET(NPRTRW,MYSETW,JA)
(   94)     IRECVSET = MYRECVSET(NPRTRW,MYSETW,JA)
(   95)     D%MSTABF(IRECVSET) = ISENDSET
(   96)   ENDDO
(   97)   D%MSTABF(MYSETW) = MYSETW
(   98)   
(   99)   ALLOCATE(D%NPNTGTB0(0:R%NSMAX,D%NDGL_FS))
(  100)   IF(LLP2)WRITE(NOUT,9) 'D%NPNTGTB0 ',SIZE(D%NPNTGTB0 ),SHAPE(D%NPNTGTB0 )
(  101)   ALLOCATE(D%NPNTGTB1(D%NUMP,R%NDGL))
(  102)   IF(LLP2)WRITE(NOUT,9) 'D%NPNTGTB1 ',SIZE(D%NPNTGTB1 ),SHAPE(D%NPNTGTB1 )
(  103) # 104 "sump_trans_mod.F90"
(  104)   DO JA=1,NPRTRW
(  105)     IPOS = 0
(  106)     DO JGL=1,D%NULTPP(MYSETW)
(  107)       IGL = D%NPTRLS(MYSETW) + JGL - 1
(  108)       DO JML=D%NPTRMS(JA),D%NPTRMS(JA)+D%NUMPP(JA)-1
(  109)         IM = D%NALLMS(JML)
(  110)         IF (IM  <=  G%NMEN(IGL)) THEN
(  111)           D%NPNTGTB0(IM,JGL) = IPOS
(  112)           IPOS = IPOS+1
(  113)         ELSE
(  114)           D%NPNTGTB0(IM,JGL) = -99
(  115)         ENDIF
(  116)       ENDDO






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 9

(  117)     ENDDO
(  118)   ENDDO
(  119) # 120 "sump_trans_mod.F90"
(  120)   DO JA=1,NPRTRW
(  121)     IPOS = 0
(  122)     DO JGL=1,D%NULTPP(JA)
(  123)       IGL = D%NPTRLS(JA) + JGL - 1
(  124)       DO JM=1,D%NUMP
(  125)         IM = D%MYMS(JM)
(  126)         IF (IM  <=  G%NMEN(IGL)) THEN
(  127)           D%NPNTGTB1(JM,IGL) = IPOS
(  128)           IPOS = IPOS+1
(  129)         ELSE
(  130)           D%NPNTGTB1(JM,IGL) = -99
(  131)         ENDIF
(  132)       ENDDO
(  133)     ENDDO
(  134)   ENDDO
(  135) # 136 "sump_trans_mod.F90"
(  136)   IAUX0 = 0
(  137)   IAUX1 = 0
(  138)   DO JA=1,NPRTRNS-1
(  139)     I1 = MYSENDSET(NPRTRNS,MYSETW,JA)
(  140)     I2 = MYRECVSET(NPRTRNS,MYSETW,JA)
(  141)     I3 = -1
(  142)     DO JA1=1,NPRTRNS-1
(  143)       IF(MYSENDSET(NPRTRNS,MYSETW,JA1) == I2) I3 =MYRECVSET(NPRTRNS,MYSETW,JA1)
(  144)     ENDDO
(  145)     IAUX0 = MAX(D%NLTSFTB(I1),D%NLTSGTB(I2),IAUX0)
(  146)     IAUX1 = MAX(D%NLTSGTB(I2),D%NLTSFTB(I3),IAUX1)
(  147)   ENDDO
(  148)   IAUX0 = MAX(D%NLTSGTB(MYSETW),IAUX0)
(  149)   IAUX1 = MAX(D%NLTSGTB(MYSETW),IAUX1)
(  150)   DO JA=1,NPRTRNS+1
(  151)     D%NSTAGT0B(JA) = (JA-1)*IAUX0
(  152)     D%NSTAGT1B(JA) = (JA-1)*IAUX1
(  153)   ENDDO
(  154)   D%NLENGT0B = IAUX0*NPRTRNS
(  155)   D%NLENGT1B = IAUX1*NPRTRNS
(  156) ENDIF
(  157)   
(  158) ! GRIDPOINT SPACE
(  159) # 160 "sump_trans_mod.F90"
(  160) ALLOCATE(D%NFRSTLAT(N_REGIONS_NS))
(  161) IF(LLP2)WRITE(NOUT,9) 'D%NFRSTLAT ',SIZE(D%NFRSTLAT ),SHAPE(D%NFRSTLAT )
(  162) ALLOCATE(D%NLSTLAT(N_REGIONS_NS))
(  163) IF(LLP2)WRITE(NOUT,9) 'D%NLSTLAT  ',SIZE(D%NLSTLAT  ),SHAPE(D%NLSTLAT  )
(  164) ALLOCATE(D%NPTRLAT(R%NDGL))
(  165) IF(LLP2)WRITE(NOUT,9) 'D%NPTRLAT  ',SIZE(D%NPTRLAT  ),SHAPE(D%NPTRLAT  )
(  166) ALLOCATE(D%NPTRFRSTLAT(N_REGIONS_NS))
(  167) IF(LLP2)WRITE(NOUT,9) 'D%NPTRFRSTLAT',SIZE(D%NPTRFRSTLAT),SHAPE(D%NPTRFRSTLAT)
(  168) ALLOCATE(D%NPTRLSTLAT(N_REGIONS_NS))
(  169) IF(LLP2)WRITE(NOUT,9)'D%NPTRLSTLAT',SIZE(D%NPTRLSTLAT),SHAPE(D%NPTRLSTLAT)
(  170) ALLOCATE(D%LSPLITLAT(R%NDGL))
(  171) IF(LLP2)WRITE(NOUT,9) 'D%LSPLITLAT',SIZE(D%LSPLITLAT),SHAPE(D%LSPLITLAT)
(  172) ALLOCATE(D%NPROCA_GP(N_REGIONS_NS))
(  173) IF(LLP2)WRITE(NOUT,9) 'D%NPROCA_GP',SIZE(D%NPROCA_GP),SHAPE(D%NPROCA_GP)
(  174) # 176 "sump_trans_mod.F90"






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 10

(  176) IF(.NOT.D%LWEIGHTED_DISTR) THEN
(  177)   ALLOCATE(ZDUM(1))
(  178)   CALL SUMPLAT(R%NDGL,NPROC,N_REGIONS_NS,MY_REGION_NS,D%LSPLIT,LEQ_REGIONS,&
(  179)              &D%NFRSTLAT,D%NLSTLAT,D%NFRSTLOFF,D%NPTRLAT,&
(  180)              &D%NPTRFRSTLAT,D%NPTRLSTLAT,D%NPTRFLOFF,&
(  181)              &ZDUM,D%LWEIGHTED_DISTR,ZMEDIAP,D%NPROCA_GP,&
(  182)              &IMEDIAP,IRESTM,D%LSPLITLAT,MYPROC,G%NLOEN)
(  183) ELSE
(  184)   CALL SUMPLAT(R%NDGL,NPROC,N_REGIONS_NS,MY_REGION_NS,D%LSPLIT,LEQ_REGIONS,&
(  185)              &D%NFRSTLAT,D%NLSTLAT,D%NFRSTLOFF,D%NPTRLAT,&
(  186)              &D%NPTRFRSTLAT,D%NPTRLSTLAT,D%NPTRFLOFF,&
(  187)              &D%RWEIGHT,D%LWEIGHTED_DISTR,ZMEDIAP,D%NPROCA_GP,&
(  188)              &IMEDIAP,IRESTM,D%LSPLITLAT,MYPROC,G%NLOEN)
(  189) ENDIF
(  190) D%NDGL_GP = D%NLSTLAT(MY_REGION_NS)-D%NFRSTLOFF
(  191) # 192 "sump_trans_mod.F90"
(  192) IF (LLP1) THEN
(  193)   IF(.NOT.D%LGRIDONLY) THEN
(  194)     WRITE(NOUT,FMT='(/'' OUTPUT FROM ROUTINE SUMPLAT: ''/)')
(  195)     WRITE(NOUT,FMT='('' D%NULTPP '')')
(  196)     WRITE(NOUT,FMT='(20(1X,I4))') D%NULTPP(1:NPRTRNS)
(  197)     WRITE(NOUT,FMT='('' D%NPROCL '')')
(  198)     WRITE(NOUT,FMT='(20(1X,I4))') D%NPROCL(1:R%NDGL)
(  199)   ENDIF
(  200)   WRITE(NOUT,FMT='('' D%NFRSTLAT '')')
(  201)   WRITE(NOUT,FMT='(20(1X,I4))') D%NFRSTLAT(1:N_REGIONS_NS)
(  202)   WRITE(NOUT,FMT='('' D%NLSTLAT '')')
(  203)   WRITE(NOUT,FMT='(20(1X,I4))') D%NLSTLAT(1:N_REGIONS_NS)
(  204)   WRITE(NOUT,FMT='('' D%NFRSTLOFF  D%NPTRFLOFF '')')
(  205)   WRITE(NOUT,FMT='(2(1X,I6))') D%NFRSTLOFF, D%NPTRFLOFF
(  206)   WRITE(NOUT,FMT='('' D%NPTRLAT '')')
(  207)   WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRLAT(1:R%NDGL)
(  208)   WRITE(NOUT,FMT='('' D%LSPLITLAT '')')
(  209)   WRITE(NOUT,FMT='(50(1X,L1))') D%LSPLITLAT(1:R%NDGL)
(  210)   WRITE(NOUT,FMT='('' D%NPTRFRSTLAT '')')
(  211)   WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRFRSTLAT(1:N_REGIONS_NS)
(  212)   WRITE(NOUT,FMT='('' D%NPTRLSTLAT '')')
(  213)   WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRLSTLAT(1:N_REGIONS_NS)
(  214)   WRITE(NOUT,FMT='(/)')
(  215) ENDIF
(  216) ALLOCATE(D%NSTA(R%NDGL+N_REGIONS_NS-1,N_REGIONS_EW))
(  217) IF(LLP2)WRITE(NOUT,9) 'D%NSTA     ',SIZE(D%NSTA     ),SHAPE(D%NSTA     )
(  218) ALLOCATE(D%NONL(R%NDGL+N_REGIONS_NS-1,N_REGIONS_EW))
(  219) IF(LLP2)WRITE(NOUT,9) 'D%NONL     ',SIZE(D%NONL     ),SHAPE(D%NONL     )
(  220) # 221 "sump_trans_mod.F90"
(  221) IF(.NOT.D%LWEIGHTED_DISTR) THEN
(  222)   CALL SUSTAONL(IMEDIAP,IRESTM,D%LWEIGHTED_DISTR,ZDUM,ZMEDIAP,D%NPROCA_GP)
(  223) ELSE
(  224)   CALL SUSTAONL(IMEDIAP,IRESTM,D%LWEIGHTED_DISTR,D%RWEIGHT,ZMEDIAP,D%NPROCA_GP)
(  225) ENDIF
(  226) !  IGPTOTL is the number of grid points in each individual processor
(  227) ALLOCATE(IGPTOTL(N_REGIONS_NS,N_REGIONS_EW))
(  228) IGPTOTL(:,:)=0
(  229) # 230 "sump_trans_mod.F90"
(  230) DO JA=1,N_REGIONS_NS
(  231)   DO JB=1,N_REGIONS(JA)
(  232)     IGPTOT = 0
(  233)     DO JGL=D%NPTRFRSTLAT(JA),D%NPTRLSTLAT(JA)






NVFORTRAN (Version    20.11)          02/16/2022  17:30:41      page 11

(  234)       IGPTOT = IGPTOT+D%NONL(JGL,JB)
(  235)     ENDDO
(  236)     IGPTOTL(JA,JB) = IGPTOT
(  237)   ENDDO
(  238) ENDDO
(  239) D%NGPTOT = IGPTOTL(MY_REGION_NS,MY_REGION_EW)
(  240) D%NGPTOTMX = MAXVAL(IGPTOTL)
(  241) D%NGPTOTG = SUM(IGPTOTL)
(  242) ALLOCATE(D%NGPTOTL(N_REGIONS_NS,N_REGIONS_EW))
(  243) IF(LLP2)WRITE(NOUT,9) 'D%NGPTOTL     ',SIZE(D%NGPTOTL ),SHAPE(D%NGPTOTL  )
(  244) D%NGPTOTL(:,:) = IGPTOTL(:,:)
(  245) # 246 "sump_trans_mod.F90"
(  246) IF(.NOT.D%LGRIDONLY) THEN
(  247)   ALLOCATE(D%NSTAGTF(D%NDGL_FS))
(  248)   IF(LLP2)WRITE(NOUT,9) 'D%NSTAGTF     ',SIZE(D%NSTAGTF ),SHAPE(D%NSTAGTF  )
(  249)   IOFF = 0
(  250)   DO JGL=1,D%NDGL_FS
(  251)     D%NSTAGTF(JGL) = IOFF
(  252)     IGL = D%NPTRLS(MYSETW) + JGL - 1
(  253)     IOFF = IOFF + G%NLOEN(IGL)+3
(  254)   ENDDO
(  255)   D%NLENGTF = IOFF
(  256) ENDIF
(  257) # 258 "sump_trans_mod.F90"
(  258) IF(ALLOCATED(ZDUM)) DEALLOCATE(ZDUM)
(  259) DEALLOCATE(IGPTOTL)
(  260) # 261 "sump_trans_mod.F90"
(  261) !     ------------------------------------------------------------------
(  262) 9 FORMAT(1X,'ARRAY ',A10,' ALLOCATED ',8I8)
(  263) # 264 "sump_trans_mod.F90"
(  264) END SUBROUTINE SUMP_TRANS
(  265) END MODULE SUMP_TRANS_MOD
