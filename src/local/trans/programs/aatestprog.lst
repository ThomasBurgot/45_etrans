


NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/include
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/lib
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: aatestprog.F90

(    1) PROGRAM TEST
(    2) 
(    3) USE MPL_END_MOD, ONLY : MPL_END
(    4) USE MPL_INIT_MOD, ONLY : MPL_INIT
(    5) USE PARKIND1, ONLY : JPIM, JPRB
(    6) USE MPL_MODULE, ONLY : MPL_BARRIER, MPL_MYRANK, MPL_NPROC
(    7) USE MPL_DATA_MODULE, ONLY : MPL_COMM_OML
(    8) USE YOMHOOK, ONLY : DR_HOOK, LHOOK
(    9) USE SET2PE_MOD, ONLY : SET2PE
(   10) 
(   11) USE XRD_GETOPTIONS
(   12) 
(   13) IMPLICIT NONE
(   14) 
(   15) REAL (KIND=JPRB), PARAMETER :: RPI = 2._JPRB * ASIN (1.0_JPRB)
(   16) REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB
(   17) 
(   18) INTEGER(KIND=JPIM) :: NMSMAX, NSMAX, NDGLG, NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NDLON, NPRINTLEV, NTIME
(   19) INTEGER(KIND=JPIM) :: MYPROC, NPROC, NBSETSP
(   20) INTEGER(KIND=JPIM) :: NFLEV
(   21) INTEGER(KIND=JPIM) :: NFLEVG
(   22) INTEGER(KIND=JPIM) :: NSPEC2, NSPEC2G, NGPTOT, NGPTOTG, MYSETV, MYSETW
(   23) INTEGER(KIND=JPIM), ALLOCATABLE :: NLOEN (:) 
(   24) INTEGER(KIND=JPIM), ALLOCATABLE :: IFLDSCH (:) 
(   25) INTEGER(KIND=JPIM), ALLOCATABLE :: IVSETOFF (:)
(   26) INTEGER(KIND=JPIM), POINTER     :: INFD (:), IFLDOFF (:)
(   27) INTEGER(KIND=JPIM), ALLOCATABLE, TARGET :: INFD_ALLVSETS (:,:), IFLDOFF_ALLVSETS (:,:)
(   28) 
(   29) REAL (KIND=JPRB) :: ZTSTEP, TIMEF
(   30) 
(   31) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFL (:,:) 






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 2

(   32) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFG (:,:) 
(   33) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL (:,:,:) 
(   34) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG (:,:) 
(   35) INTEGER (KIND=JPIM), ALLOCATABLE :: NBSETLEV (:) 
(   36) INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:) 
(   37) INTEGER (KIND=JPIM) :: NFLDUA, NFLDSU, IFLD, ILEVG, IGPG, JFLDG1, JFLDG2, IPROC
(   38) INTEGER (KIND=JPIM) :: JSETW, JSETV
(   39) INTEGER (KIND=JPIM) :: IFLDGPG, IFLDSPL
(   40) INTEGER (KIND=JPIM) :: IA, IB
(   41) INTEGER (KIND=JPIM) :: NRGRI (8000)
(   42) INTEGER (KIND=JPIM) :: ITIME
(   43) 
(   44) LOGICAL :: LUSEFLT, LUSERPNM, LKEEPRPNM
(   45) LOGICAL :: LSPLIT, LEQ_REGIONS, LDEBUG, LELAM, LLCHECK
(   46) LOGICAL :: LLHOOK
(   47) 
(   48) #include "setup_trans0.h"
(   49) 
(   50) #include "setup_trans.h"
(   51) #include "trans_inq.h"
(   52) #include "dist_grid.h"
(   53) #include "gath_grid.h"
(   54) #include "gath_spec.h"
(   55) #include "dir_trans.h"
(   56) #include "inv_trans.h"
(   57) 
(   58) #include "esetup_trans.h"
(   59) #include "etrans_inq.h"
(   60) #include "edist_grid.h"
(   61) #include "egath_grid.h"
(   62) #include "egath_spec.h"
(   63) #include "edir_trans.h"
(   64) #include "einv_trans.h"
(   65) 
(   66) #include "abor1.intfb.h"
(   67) 
(   68) NAMELIST / NAMAATESTPROG / & 
(   69)   & NFLDUA, NFLDSU, NMSMAX, NSMAX, NDGLG, NFLEVG, LDEBUG, NDLON, NPRINTLEV, NTIME, LELAM
(   70) 
(   71) NAMELIST / NAMTRANS / & 
(   72)   & LUSEFLT, LUSERPNM, LKEEPRPNM
(   73) 
(   74) NAMELIST / NAMPAR0 / & 
(   75)   & NPRGPNS, NPRGPEW, NPRTRW, NPRTRV
(   76) 
(   77) NAMELIST / NAMPAR1 / & 
(   78)   & LEQ_REGIONS, LSPLIT
(   79) 
(   80) NAMELIST / NAMRGRI / & 
(   81)   & NRGRI
(   82) 
(   83) CHARACTER (LEN=64) :: CLNAMELIST
(   84) CHARACTER (LEN=64) :: CLFIELD
(   85) LOGICAL :: LLMPOFF, LLNOWRITE, LLNODIRTRANS, LLNOINVTRANS, LLTESTHARMONICS, LLALLOPERM
(   86) 
(   87) REAL (KIND=JPRB) :: ZHOOK_HANDLE
(   88) 
(   89) CALL GPU_BIND_JZ






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 3

(   90) CALL INITOPTIONS ()
(   91) CLNAMELIST = 'fort.4'
(   92) CALL GETOPTION ("--namelist", CLNAMELIST)
(   93) CALL GETOPTION ("--lmpoff", LLMPOFF)
(   94) NTIME     = 10
(   95) CALL GETOPTION ("--time", NTIME)
(   96) CLFIELD = ''
(   97) CALL GETOPTION ("--field-file", CLFIELD)
(   98) CALL GETOPTION ("--no-write", LLNOWRITE)
(   99) CALL GETOPTION ("--no-dir-trans", LLNODIRTRANS)
(  100) CALL GETOPTION ("--no-inv-trans", LLNOINVTRANS)
(  101) CALL GETOPTION ("--test-harmonics", LLTESTHARMONICS)
(  102) CALL GETOPTION ("--alloperm", LLALLOPERM)
(  103) CALL GETOPTION ("--check", LLCHECK)
(  104) CALL CHECKOPTIONS ()
(  105) 
(  106) 
(  107) LLHOOK = LHOOK
(  108) LHOOK = .FALSE.
(  109) 
(  110) OPEN (4, FILE=TRIM (CLNAMELIST), FORM='FORMATTED')
(  111) 
(  112) LELAM     = .FALSE.
(  113) NFLDUA    = 1
(  114) NFLDSU    = 0
(  115) NPRINTLEV = 0
(  116) NSMAX     = 0
(  117) NMSMAX    = 0
(  118) NDGLG     = 0
(  119) NFLEVG    = 19
(  120) LDEBUG    = .FALSE.
(  121) 
(  122) CALL POSNAM (4, 'NAMAATESTPROG')
(  123) READ (4, NAMAATESTPROG)
(  124) 
(  125) IF ((NSMAX == 0) .OR. (NDGLG == 0)) THEN
(  126)   CALL ABOR1 ('DWARF: NSMAX AND NDGLG ARE REQUIRED')
(  127) ENDIF
(  128) 
(  129) NPRGPNS = 0 
(  130) NPRGPEW = 0 
(  131) NPRTRW  = 0 
(  132) NPRTRV  = 0 
(  133) 
(  134) CALL POSNAM (4, 'NAMPAR0')
(  135) READ (4, NAMPAR0)
(  136) 
(  137) LUSEFLT   = NSMAX > 1280
(  138) LUSERPNM  = .NOT.LUSEFLT
(  139) LKEEPRPNM = .NOT.LUSEFLT
(  140) 
(  141) CALL POSNAM (4, 'NAMTRANS')
(  142) READ (4, NAMTRANS)
(  143) 
(  144) LEQ_REGIONS = .NOT. LELAM
(  145) LSPLIT      = .TRUE.
(  146) 
(  147) CALL POSNAM (4, 'NAMPAR1')






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 4

(  148) READ (4, NAMPAR1)
(  149) 
(  150) IF (LELAM) THEN
(  151)   NRGRI = NDLON
(  152) ELSE
(  153)   NRGRI = 0
(  154) ENDIF
(  155) 
(  156) CALL POSNAM (4, 'NAMRGRI')
(  157) READ (4, NAMRGRI)
(  158) 
(  159) CLOSE (4)
(  160) 
(  161) ALLOCATE (NLOEN (NDGLG))
(  162) NLOEN (1:NDGLG) = NRGRI (1:NDGLG)
(  163) 
(  164) IF (.NOT. LELAM) THEN
(  165)   IF (ANY (NLOEN (NDGLG/2+1:NDGLG) == 0)) THEN
(  166)     NLOEN (NDGLG/2+1:NDGLG) = NLOEN (NDGLG/2:1:-1)
(  167)   ENDIF
(  168)   IF (ANY (NLOEN (NDGLG/2:1:-1) /= NLOEN (NDGLG/2+1:NDGLG))) THEn
(  169)     CALL ABOR1 ('UNEXPECTED NLOEN')
(  170)   ENDIF
(  171) ENDIF
(  172) 
(  173) IF (LLMPOFF) THEN
(  174)   MYPROC = 1
(  175)   NPROC  = 1
(  176) ELSE
(  177)   CALL MPL_INIT 
(  178)   MYPROC = MPL_MYRANK()
(  179)   NPROC  = MPL_NPROC ()
(  180) ENDIF
(  181) 
(  182) ! GPU binding
(  183) 
(  184) !CALL GPU_BIND (MYPROC-1, NPROC)
(  185) 
(  186) IF (NPROC > 1 .AND. LLTESTHARMONICS) THEN
(  187)   CALL ABOR1 ('NPROC > 1 .AND. LLTESTHARMONICS')
(  188) ENDIF
(  189) 
(  190) CALL SQUARE (NPROC, IB, IA)
(  191) 
(  192) IF (NPRGPNS == 0 .AND. NPRGPEW == 0) THEN
(  193)   NPRGPNS = IA
(  194)   NPRGPEW = IB
(  195) ENDIF
(  196) 
(  197) IF (NPRTRW == 0 .AND. NPRTRV == 0) THEN
(  198)   NPRTRW = IA
(  199)   NPRTRV = IB
(  200) ENDIF
(  201) 
(  202) NBSETSP = MIN (NFLEVG+1, NPRTRV)
(  203) 
(  204) IF (MYPROC == 1) THEN
(  205) 






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 5

(  206)   WRITE (0, *) " NPROC = ", NPROC, " NTIME = ", NTIME, " LELAM = ", LELAM
(  207)   WRITE (0, *) " NFLDUA = ", NFLDUA, " NFLDSU = ", NFLDSU, " NFLEVG = ", NFLEVG
(  208)   WRITE (0, *) " NPRGPNS = ", NPRGPNS, " NPRGPEW = ", NPRGPEW
(  209)   WRITE (0, *) " NPRTRW = ", NPRTRW, " NPRTRV = ", NPRTRV
(  210)   WRITE (0, *) " LEQ_REGIONS = ", LEQ_REGIONS, " LSPLIT = ", LSPLIT
(  211)   WRITE (0, *) " NSMAX = ", NSMAX, " NDGLG = ", NDGLG
(  212) 
(  213) ENDIF
(  214) 
(  215) MYSETV = MOD (MYPROC-1, NPRTRV) + 1
(  216) MYSETW = (MYPROC-1) / NPRTRV + 1
(  217) 
(  218) 
(  219) CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=2,   &
(  220)                  & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,     &
(  221)                  & LDEQ_REGIONS=LEQ_REGIONS, LDMPOFF=LLMPOFF,           &
(  222)                  & LDALLOPERM=LLALLOPERM, LDALLOPERM2=LLALLOPERM)
(  223) IF (LELAM) THEN
(  224)   CALL ESETUP_TRANS (KSMAX=NSMAX, KMSMAX=NMSMAX, KDGL=NDGLG, KDGUX=NDGLG, KLOEN=NLOEN, &
(  225)                    & LDSPLIT=LSPLIT, KFLEV=NFLEVG)
(  226)   CALL ETRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  227) ELSE
(  228)   CALL SETUP_TRANS (KSMAX=NSMAX, KDGL=NDGLG, KLOEN=NLOEN, LDSPLIT=LSPLIT, KFLEV=NFLEVG, &
(  229)                   & LDUSEFLT=LUSEFLT,LDUSERPNM=LUSERPNM, LDKEEPRPNM=LKEEPRPNM)
(  230)   CALL TRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  231) ENDIF
(  232) 
(  233) IF (MYPROC == 1) THEN
(  234)   WRITE (0, *) " NGPTOTG = ", NGPTOTG, " NSPEC2G = ", NSPEC2G
(  235) ENDIF
(  236) 
(  237) ALLOCATE (NBSETLEV (NFLEVG))
(  238) 
(  239) DO ILEVG = 1, NFLEVG
(  240)   NBSETLEV (ILEVG) = MOD (ILEVG, NPRTRV) + 1
(  241) ENDDO
(  242) 
(  243) NFLEV = COUNT (NBSETLEV == MYSETV)
(  244) 
(  245) IFLDGPG = NFLDSU + NFLDUA * NFLEVG 
(  246) ALLOCATE (IVSET (IFLDGPG))
(  247) 
(  248) DO IFLD = 1, NFLDSU
(  249)   IVSET (IFLD) = NBSETSP
(  250) ENDDO
(  251) 
(  252) DO IFLD = 1, NFLDUA
(  253)   DO ILEVG = 1, NFLEVG
(  254)     IVSET (NFLDSU+ILEVG+(IFLD-1)*NFLEVG) = NBSETLEV (ILEVG)
(  255)   ENDDO
(  256) ENDDO
(  257) 
(  258) IFLDSPL = COUNT (IVSET == MYSETV)
(  259) 
(  260) PRINT *, " IFLDSPL = ", IFLDSPL, " MYPROC = ", MYPROC
(  261) 
(  262) ALLOCATE (ZSPBUFL (IFLDSPL, NSPEC2))
(  263) ALLOCATE (ZGPBUFL (NGPTOT, IFLDGPG, 1))






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 6

(  264) 
(  265) CALL GENFIELD
(  266) 
(  267) IF (LLCHECK) THEN
(  268)   CALL CHECK (LDDIFF=.FALSE.)
(  269) ENDIF
(  270) 
(  271) IF (.NOT. LLNOWRITE) THEN
(  272)   CALL WRIFIELD ('AATESTPROG.0.fa')
(  273) ENDIF
(  274) 
(  275) IF (.NOT. LLMPOFF) CALL MPL_BARRIER()
(  276) 
(  277) LHOOK = LLHOOK
(  278) 
(  279) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',0,ZHOOK_HANDLE)
(  280) 
(  281) IF (LLTESTHARMONICS) THEN
(  282)   CALL TESTHARMONICS
(  283) ELSE
(  284)   DO ITIME = 1, NTIME
(  285)     ZTSTEP = TIMEF()
(  286)   
(  287)     IF (LELAM) THEN
(  288)       IF (.NOT. LLNODIRTRANS) CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  289)       IF (.NOT. LLNOINVTRANS) CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  290)     ELSE
(  291)       IF (.NOT. LLNODIRTRANS) CALL DIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  292)       IF (.NOT. LLNOINVTRANS) CALL INV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  293)     ENDIF
(  294)   
(  295)     IF(MYPROC == 1) THEN
(  296)       ZTSTEP=(TIMEF()-ZTSTEP)
(  297)       WRITE(*,'(" time step ",I6," took", F8.2)') ITIME, ZTSTEP
(  298)     ENDIF
(  299)   ENDDO
(  300) ENDIF
(  301) 
(  302) CALL FLUSH (0)
(  303) 
(  304) IF (LELAM) THEN
(  305)   CALL ETRANS_END
(  306) ELSE
(  307)   CALL TRANS_END
(  308) ENDIF
(  309) 
(  310) 999 CONTINUE
(  311) 
(  312) IF (.NOT. LLMPOFF) CALL MPL_BARRIER
(  313) 
(  314) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',1,ZHOOK_HANDLE)
(  315) 
(  316) IF (.NOT. LLNOWRITE) THEN
(  317)   CALL WRIFIELD ('AATESTPROG.1.fa')
(  318) ENDIF
(  319) 
(  320) IF (LLCHECK) THEN
(  321)   CALL CHECK (LDDIFF=.FALSE.)






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 7

(  322)   CALL CHECK (LDDIFF=.TRUE.)
(  323) ENDIF
(  324) 
(  325) IF (.NOT. LLMPOFF) CALL MPL_END
(  326) 
(  327) IF (MYPROC == 1) WRITE (0, *) " --------- END --------- "
(  328) 
(  329) CALL FLUSH (0)
(  330) 
(  331) CONTAINS
(  332) 
(  333) SUBROUTINE TESTHARMONICS
(  334) 
(  335) INTEGER (KIND=JPIM) :: INHARM
(  336) CHARACTER (LEN=32) :: CLFILE
(  337) 
(  338) DO INHARM = 1, NSPEC2G
(  339) 
(  340)   WRITE (CLFILE, '(I6.6)') INHARM
(  341) 
(  342)   ZSPBUFL = 0._JPRB
(  343)   ZSPBUFL (1, INHARM) = 1._JPRB
(  344)   ZGPBUFL = 999._JPRB
(  345) 
(  346)   CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  347)   
(  348) ! OPEN (77, FILE=TRIM (CLFILE)//'.gp.dat')
(  349) ! WRITE (77, *) ZGPBUFL (:, 1, 1)
(  350) ! CLOSE (77)
(  351) 
(  352)   ZSPBUFL = 999._JPRB
(  353) 
(  354)   CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  355) 
(  356) ! OPEN (77, FILE=TRIM (CLFILE)//'.sp.dat')
(  357) ! WRITE (77, *) ZSPBUFL (1, :)
(  358) ! CLOSE (77)
(  359) 
(  360)   WHERE (ABS (ZSPBUFL) < 1E-15)
(  361)     ZSPBUFL = 0._JPRB
(  362)   ENDWHERE
(  363) 
(  364)   WHERE (ABS (ZSPBUFL - 1._JPRB) < 1E-15)
(  365)     ZSPBUFL = 1._JPRB
(  366)   ENDWHERE
(  367) 
(  368)   WRITE (88, '(I6," ",I6," ",I6," ",I6," ",I6)') INHARM, &
(  369)        & COUNT (ZSPBUFL (1, :) == 0._JPRB), COUNT (ZSPBUFL (1, :) == 1._JPRB), &
(  370)        & COUNT ((ZSPBUFL (1, :) /= 1._JPRB) .AND. (ZSPBUFL (1, :) /= 0._JPRB)), &
(  371)        & NSPEC2G
(  372)  
(  373) 
(  374) ENDDO
(  375) 
(  376) END SUBROUTINE
(  377) 
(  378) SUBROUTINE SQUARE (KN, KA, KB)
(  379) 






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 8

(  380) INTEGER (KIND=JPIM) :: KN, KA, KB
(  381) 
(  382) KB = INT (SQRT (REAL (KN))) + 1
(  383) 
(  384) DO
(  385)   KA = KN / KB
(  386)   IF (KA * KB == KN) EXIT
(  387)   KB = KB - 1
(  388) ENDDO
(  389) 
(  390) END SUBROUTINE SQUARE
(  391) 
(  392) SUBROUTINE POSNAM (KULNAM,CDNAML)
(  393) 
(  394) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  395) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  396) 
(  397) IMPLICIT NONE
(  398) 
(  399) INTEGER(KIND=JPIM),INTENT(IN)    :: KULNAM 
(  400) CHARACTER(LEN=*)  ,INTENT(IN)    :: CDNAML 
(  401) 
(  402) 
(  403) #include "abor1.intfb.h"
(  404) 
(  405) 
(  406) CHARACTER (LEN = 40) ::  CLINE
(  407) CHARACTER (LEN =  1) ::  CLTEST
(  408) 
(  409) INTEGER(KIND=JPIM) :: ILEN, IND1, ISTATUS, ISCAN
(  410) REAL(KIND=JPRB)    :: ZHOOK_HANDLE
(  411) 
(  412) IF (LHOOK) CALL DR_HOOK('POSNAM',0,ZHOOK_HANDLE)
(  413) 
(  414) CLINE='                                        '
(  415) REWIND(KULNAM)
(  416) ILEN=LEN(CDNAML)
(  417) ISTATUS=0
(  418) ISCAN=0
(  419) DO WHILE (ISTATUS==0 .AND. ISCAN==0)
(  420)   READ(KULNAM,'(A)',IOSTAT=ISTATUS) CLINE
(  421)   SELECT CASE (ISTATUS)
(  422)   CASE (:-1)
(  423)     CALL ABOR1 ('POSNAM: CANNOT FIND '//TRIM (CDNAML))
(  424)   CASE (0)
(  425)     IF (INDEX(CLINE(1:10),'&') == 0) THEN
(  426)       ISCAN=0
(  427)     ELSE
(  428)       IND1=INDEX(CLINE,'&'//CDNAML)
(  429)       IF (IND1 == 0) THEN
(  430)         ISCAN=0
(  431)       ELSE
(  432)         CLTEST=CLINE(IND1+ILEN+1:IND1+ILEN+1)
(  433)         IF (   (LGE(CLTEST,'0').AND.LLE(CLTEST,'9')) &
(  434)          & .OR.(LGE(CLTEST,'A').AND.LLE(CLTEST,'Z')) ) THEN
(  435)           ISCAN=0
(  436)         ELSE
(  437)           ISCAN=1






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 9

(  438)         ENDIF
(  439)       ENDIF
(  440)     ENDIF
(  441)   CASE (1:)
(  442)     CALL ABOR1 ('POSNAM: AN ERROR HAPPENED WHILE READING THE NAMELIST')
(  443)   END SELECT
(  444) ENDDO
(  445) BACKSPACE(KULNAM)
(  446) 
(  447) IF (LHOOK) CALL DR_HOOK('POSNAM',1,ZHOOK_HANDLE)
(  448) END SUBROUTINE POSNAM
(  449) 
(  450) SUBROUTINE WRIFIELD (CDFILE)
(  451) 
(  452) CHARACTER (LEN=*), INTENT (IN) :: CDFILE
(  453) INTEGER (KIND=JPIM) :: ITO (IFLDGPG), JFLD
(  454) CHARACTER (LEN=16) :: CLPREF, CLSUFF
(  455) 
(  456) ITO = 1
(  457) 
(  458) IF (MYPROC == 1) THEN
(  459)   ALLOCATE (ZGPBUFG (NGPTOTG, IFLDGPG))
(  460) 
(  461)   IF (LELAM) THEN
(  462)     CALL EGATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  463)   ELSE
(  464)     CALL GATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  465)   ENDIF
(  466) 
(  467)   CALL SYSTEM ('rm -f '//TRIM (CDFILE))
(  468) 
(  469)   DO JFLD = 1, IFLDGPG
(  470)     CLPREF = 'SURF'
(  471)     WRITE (CLSUFF, '("FFFF.",I4.4)') JFLD
(  472)     CALL WFA (ZGPBUFG (:, JFLD), CDFILE, CLPREF, CLSUFF)
(  473)   ENDDO
(  474) 
(  475)   DEALLOCATE (ZGPBUFG)
(  476) ELSE
(  477)   IF (LELAM) THEN
(  478)     CALL EGATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  479)   ELSE
(  480)     CALL GATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  481)   ENDIF
(  482) ENDIF
(  483) 
(  484) END SUBROUTINE
(  485) 
(  486) SUBROUTINE WFA (PGLO, CDFILE, CDPREF, CDSUFF)
(  487) 
(  488) REAL (KIND=JPRB),  INTENT (IN) :: PGLO (:)
(  489) CHARACTER (LEN=*), INTENT (IN) :: CDFILE, CDPREF, CDSUFF
(  490) 
(  491) REAL (KIND=JPRB) :: ZMU (NDGLG)
(  492) 
(  493) CHARACTER (LEN=3) :: CLNOMC 
(  494) REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
(  495) INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 10

(  496) INTEGER (KIND=JPIM) :: NLOENG (NDGLG), INOZPA (NDGLG)
(  497) INTEGER (KIND=JPIM) :: INBARP, INBARI, ILUN, IREP
(  498) INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
(  499) INTEGER (KIND=JPIM) :: IDATEF (11), ILCHAM
(  500) CHARACTER (LEN=16)  :: CLSTATUS
(  501) LOGICAL :: LLEXIST
(  502) 
(  503) INQUIRE (FILE=TRIM (CDFILE), EXIST=LLEXIST)
(  504) 
(  505) IF (LLEXIST) THEN
(  506)   CLSTATUS = 'OLD'
(  507)   IF (LELAM) THEN
(  508)     CLNOMC = 'ALD'
(  509)   ELSE
(  510)     CLNOMC = 'ARP'
(  511)   ENDIF
(  512) ELSE
(  513)   CLSTATUS = 'NEW'
(  514) IF (LELAM) THEN
(  515) BLOCK
(  516)   INTEGER (KIND=JPIM) :: INLOPA (8)
(  517)   INTEGER (KIND=JPIM) :: NX, NY, NUX, NUY
(  518)   REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
(  519)   REAL (KIND=JPRB) :: ZSINLA (18)
(  520) 
(  521)   REAL (KIND=JPRB), PARAMETER :: LADINDEGREES    = 46.2_JPRB
(  522)   REAL (KIND=JPRB), PARAMETER :: LATIN1INDEGREES = 46.2_JPRB
(  523)   REAL (KIND=JPRB), PARAMETER :: LATIN2INDEGREES = 46.2_JPRB
(  524)   REAL (KIND=JPRB), PARAMETER :: LOVINDEGREES    =  2.0_JPRB
(  525) 
(  526)   CLNOMC = 'ALD'
(  527)   NX = NDLON
(  528)   NY = NDGLG
(  529) 
(  530)   ! Round dx to 100m
(  531)   DXINMETRES = 2000.E3_JPRB / REAL (NX - 1, JPRB)
(  532)   DXINMETRES = 100._JPRB * NINT (DXINMETRES / 100._JPRB) 
(  533)   DYINMETRES = DXINMETRES
(  534) 
(  535)   NUX = NX - 1
(  536)   NUY = NY - 1
(  537) 
(  538)   INLATI = NY
(  539)   INXLON = NX
(  540)   ZSLAPO = 0._JPRB
(  541)   ZCLOPO = 0._JPRB
(  542)   ZSLOPO = 0._JPRB
(  543)   ZCODIL = 0._JPRB
(  544)   ZREFER = 0._JPRB
(  545)   INIVER = 1_JPIM
(  546)   ZAHYBR = 0._JPRB
(  547)   ZBHYBR = 0._JPRB 
(  548)   INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
(  549)   ITRONC = +INLATI / 2 - 1 
(  550)   ITYPTR = -INXLON / 2 + 1 
(  551)   
(  552)   ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
(  553)          &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 11

(  554)          &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, 0._JPRB, &
(  555)          &  0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB ]
(  556)   
(  557)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
(  558)   &            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
(  559)   &            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
(  560)   &            ZBHYBR, .FALSE.)
(  561) 
(  562) ENDBLOCK
(  563) ELSE
(  564) BLOCK
(  565)   REAL (KIND=JPRB) :: ZCENTRE (2)
(  566) 
(  567)   CLNOMC = 'ARP'
(  568) 
(  569)   CALL TRANS_INQ (PMU=ZMU)
(  570)   
(  571)   ZCENTRE = [0._JPRB, 90._JPRB]
(  572)   ZCODIL = 1._JPRB
(  573)   
(  574)   INIVER = 1_JPIM
(  575)   ZAHYBR = 0._JPRB
(  576)   ZBHYBR = 0._JPRB
(  577)   ITYPTR = 2_JPIM
(  578)   
(  579)   NLOENG = NLOEN
(  580)   
(  581)   ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
(  582)   ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
(  583)   ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
(  584)   INLATI = NDGLG
(  585)   INXLON = MAXVAL (NLOENG)
(  586)   ITRONC = INXLON / 3
(  587)   INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
(  588)   ZREFER = 1._JPRB
(  589)   
(  590)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
(  591)   &            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
(  592)   &            INOZPA, ZMU,    INIVER, ZREFER, ZAHYBR, &
(  593)   &            ZBHYBR, .FALSE.)
(  594) 
(  595) ENDBLOCK
(  596) ENDIF
(  597) ENDIF
(  598)  
(  599) 
(  600) INBARP = 0
(  601) INBARI = 0
(  602) ILUN = 77
(  603) CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), CLSTATUS, .TRUE., &
(  604)            & .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
(  605) 
(  606) IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
(  607) CALL FANDAR (IREP, ILUN, IDATEF)
(  608) 
(  609) CALL FATCHA (IREP, CLNOMC, .FALSE., ILCHAM)
(  610) 
(  611) CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 12

(  612) INGRIB = 123_JPIM
(  613) CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
(  614) 
(  615) CALL FAIENC (IREP, ILUN, CDPREF, 0, CDSUFF, PGLO, .FALSE.)
(  616) 
(  617) CALL FAIRME (IREP, ILUN, 'KEEP')
(  618) 
(  619) END SUBROUTINE
(  620) 
(  621) SUBROUTINE CHECK (LDDIFF)
(  622) 
(  623) LOGICAL, INTENT (IN) :: LDDIFF
(  624) 
(  625) ! Save result in ZGPBUFL1
(  626) 
(  627) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL1 (:,:,:) 
(  628) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG1 (:,:) 
(  629) INTEGER (KIND=JPIM) :: JFLD, ITO (1)
(  630) REAL (KIND=JPRB) :: ZDIFF2 (IFLDGPG)
(  631) 
(  632) ALLOCATE (ZGPBUFL1 (NGPTOT, IFLDGPG, 1)) 
(  633) 
(  634) ZGPBUFL1 = ZGPBUFL
(  635) 
(  636) ! Recreate original field
(  637) 
(  638) 
(  639) IF (LDDIFF) THEN
(  640)   CALL GENFIELD
(  641)   ZGPBUFL1 = ZGPBUFL1 - ZGPBUFL
(  642) ENDIF
(  643) 
(  644) IF (MYPROC == 1) THEN
(  645)   IF (LDDIFF) THEN
(  646)     WRITE (100, *) "                  ------------- DIFF ------------- "
(  647)   ELSE
(  648)     WRITE (100, *) "                  ------------- STAT ------------- "
(  649)   ENDIF
(  650) ENDIF
(  651) 
(  652) ITO = 1
(  653) 
(  654) DO JFLD = 1, IFLDGPG
(  655) 
(  656)   IF (MYPROC == 1) THEN
(  657)     ALLOCATE (ZGPBUFG1 (NGPTOTG, 1))
(  658)     IF (LELAM) THEN
(  659)       CALL EGATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  660)     ELSE
(  661)       CALL GATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  662)     ENDIF
(  663)     WRITE (100, '(" FIELD ",I6," L2 =",E16.8," L1 = ",E16.8," MEAN =",E16.8)') & 
(  664)          & JFLD, SQRT (SUM (ZGPBUFG1 * ZGPBUFG1) / REAL (NGPTOTG, JPRB)), &
(  665)          & SUM (ABS (ZGPBUFG1)) / REAL (NGPTOTG, JPRB), SUM (ZGPBUFG1)
(  666)     DEALLOCATE (ZGPBUFG1)
(  667)   ELSE
(  668)     IF (LELAM) THEN
(  669)       CALL EGATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 13

(  670)     ELSE
(  671)       CALL GATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  672)     ENDIF
(  673)   ENDIF
(  674) 
(  675) ENDDO
(  676) 
(  677) END SUBROUTINE
(  678) 
(  679) SUBROUTINE GENFIELD
(  680) 
(  681) IF (MYPROC == 1) THEN
(  682)   ALLOCATE (ZGPBUFG (NGPTOTG, 1))
(  683) 
(  684)   IF (CLFIELD /= '') THEN
(  685)     OPEN (77, FILE=TRIM (CLFIELD), FORM='UNFORMATTED', STATUS='OLD')
(  686)     READ (77) ZGPBUFG (:, 1)
(  687)     CLOSE (77)
(  688)   ELSE
(  689)   BLOCK
(  690)     REAL (KIND=JPRB) :: ZLON, ZLAT, ZVAL, ZX, ZY
(  691)     INTEGER (KIND=JPIM) :: JLAT, JLON, JGLO
(  692) 
(  693)     JGLO = 1
(  694) 
(  695)     DO JLAT = 1, NDGLG
(  696)       DO JLON = 1, NLOEN (JLAT)
(  697)        
(  698)         IF (LELAM) THEN
(  699)           ZX = REAL (JLON-1, JPRB) / REAL (NDLON, JPRB)
(  700)           ZY = REAL (JLAT-1, JPRB) / REAL (NDLON, JPRB)
(  701)           ZVAL = ZX * (1._JPRB - ZX) * ZY * (1._JPRB - ZY) * 4._JPRB + 0.5
(  702)         ELSE
(  703)           ZLAT = + RPI * (0.5_JPRB - REAL (JLAT, JPRB) / REAL (NDGLG+1, JPRB))
(  704)           ZLON = 2 * RPI * REAL (JLON-1, JPRB) / REAL (NLOEN (JLAT))
(  705)           ZVAL = COS (ZLAT) * SIN (ZLON)
(  706)         ENDIF
(  707)         ZGPBUFG (JGLO, 1) = ZVAL
(  708)         JGLO = JGLO + 1
(  709)       ENDDO
(  710)     ENDDO
(  711)   ENDBLOCK
(  712)   ENDIF
(  713) 
(  714)   IF (LELAM) THEN
(  715)     CALL EDIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  716)   ELSE
(  717)     CALL DIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  718)   ENDIF
(  719) 
(  720)   DEALLOCATE (ZGPBUFG)
(  721) 
(  722) ELSE
(  723)   IF (LELAM) THEN
(  724)     CALL EDIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  725)   ELSE
(  726)     CALL DIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  727)   ENDIF






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 14

(  728) ENDIF
(  729) 
(  730) DO IFLD = 2, IFLDGPG
(  731)   ZGPBUFL (:, IFLD, 1) = ZGPBUFL (:, 1, 1) * REAL (IFLD, JPRB)
(  732) ENDDO
(  733) 
(  734) 
(  735) END SUBROUTINE
(  736) 
(  737) END PROGRAM TEST
(  738) 





















































NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 15

(    1) # 1 "aatestprog.F90"
(    1) PROGRAM TEST
(    2) # 3 "aatestprog.F90"
(    3) USE MPL_END_MOD, ONLY : MPL_END
(    4) USE MPL_INIT_MOD, ONLY : MPL_INIT
(    5) USE PARKIND1, ONLY : JPIM, JPRB
(    6) USE MPL_MODULE, ONLY : MPL_BARRIER, MPL_MYRANK, MPL_NPROC
(    7) USE MPL_DATA_MODULE, ONLY : MPL_COMM_OML
(    8) USE YOMHOOK, ONLY : DR_HOOK, LHOOK
(    9) USE SET2PE_MOD, ONLY : SET2PE
(   10) # 11 "aatestprog.F90"
(   11) USE XRD_GETOPTIONS
(   12) # 13 "aatestprog.F90"
(   13) IMPLICIT NONE
(   14) # 15 "aatestprog.F90"
(   15) REAL (KIND=JPRB), PARAMETER :: RPI = 2._JPRB * ASIN (1.0_JPRB)
(   16) REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB
(   17) # 18 "aatestprog.F90"
(   18) INTEGER(KIND=JPIM) :: NMSMAX, NSMAX, NDGLG, NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NDLON, NPRINTLEV, NTIME
(   19) INTEGER(KIND=JPIM) :: MYPROC, NPROC, NBSETSP
(   20) INTEGER(KIND=JPIM) :: NFLEV
(   21) INTEGER(KIND=JPIM) :: NFLEVG
(   22) INTEGER(KIND=JPIM) :: NSPEC2, NSPEC2G, NGPTOT, NGPTOTG, MYSETV, MYSETW
(   23) INTEGER(KIND=JPIM), ALLOCATABLE :: NLOEN (:) 
(   24) INTEGER(KIND=JPIM), ALLOCATABLE :: IFLDSCH (:) 
(   25) INTEGER(KIND=JPIM), ALLOCATABLE :: IVSETOFF (:)
(   26) INTEGER(KIND=JPIM), POINTER     :: INFD (:), IFLDOFF (:)
(   27) INTEGER(KIND=JPIM), ALLOCATABLE, TARGET :: INFD_ALLVSETS (:,:), IFLDOFF_ALLVSETS (:,:)
(   28) # 29 "aatestprog.F90"
(   29) REAL (KIND=JPRB) :: ZTSTEP, TIMEF
(   30) # 31 "aatestprog.F90"
(   31) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFL (:,:) 
(   32) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFG (:,:) 
(   33) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL (:,:,:) 
(   34) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG (:,:) 
(   35) INTEGER (KIND=JPIM), ALLOCATABLE :: NBSETLEV (:) 
(   36) INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:) 
(   37) INTEGER (KIND=JPIM) :: NFLDUA, NFLDSU, IFLD, ILEVG, IGPG, JFLDG1, JFLDG2, IPROC
(   38) INTEGER (KIND=JPIM) :: JSETW, JSETV
(   39) INTEGER (KIND=JPIM) :: IFLDGPG, IFLDSPL
(   40) INTEGER (KIND=JPIM) :: IA, IB
(   41) INTEGER (KIND=JPIM) :: NRGRI (8000)
(   42) INTEGER (KIND=JPIM) :: ITIME
(   43) # 44 "aatestprog.F90"
(   44) LOGICAL :: LUSEFLT, LUSERPNM, LKEEPRPNM
(   45) LOGICAL :: LSPLIT, LEQ_REGIONS, LDEBUG, LELAM, LLCHECK
(   46) LOGICAL :: LLHOOK
(   47) # 48 "aatestprog.F90"
(   48) # 1 ".D[10]/setup_trans0.h"
(    1) INTERFACE
(    2) SUBROUTINE SETUP_TRANS0(KOUT,KERR,KPRINTLEV,KMAX_RESOL,KPROMATR,&
(    3) &                       KPRGPNS,KPRGPEW,KPRTRW,KCOMBFLEN,&
(    4) &                       LDMPOFF,LDSYNC_TRANS,KTRANS_SYNC_LEVEL,&
(    5) &                       LDEQ_REGIONS,K_REGIONS_NS,K_REGIONS_EW,K_REGIONS,&
(    6) &                       PRAD,LDALLOPERM,LDALLOPERM2)
(    7) # 8 ".D[10]/setup_trans0.h"
(    8) !**** *SETUP_TRANS0* - General setup routine for transform package
(    9) # 10 ".D[10]/setup_trans0.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 16

(   10) !     Purpose.
(   11) !     --------
(   12) !     Resolution independent part of setup of transform package
(   13) !     Has to be called BEFORE SETUP_TRANS
(   14) # 15 ".D[10]/setup_trans0.h"
(   15) !**   Interface.
(   16) !     ----------
(   17) !     CALL SETUP_TRANS0(...)
(   18) # 19 ".D[10]/setup_trans0.h"
(   19) !     Explicit arguments : All arguments are optional, [..] default value
(   20) !     -------------------
(   21) !     KOUT - Unit number for listing output [6]
(   22) !     KERR - Unit number for error messages [0]
(   23) !     KPRINTLEV - level of output to KOUT, 0->no output,1->normal,2->debug [0]
(   24) !     KMAX_RESOL - maximum number of different resolutions for this run [1]
(   25) !     KPRGPNS - splitting level in N-S direction in grid-point space [1]
(   26) !     KPRGPEW - splitting level in E-W direction in grid-point space [1]
(   27) !     KPRTRW  - splitting level in wave direction in spectral space [1]
(   28) !     KCOMBFLEN - Size of communication buffer [1800000 (*8bytes) ]
(   29) !     LDMPOFF - switch off message passing [false]
(   30) !     LDSYNC_TRANS - switch to activate barrier before transforms [false]
(   31) !     KTRANS_SYNC_LEVEL - use of synchronization/blocking [0]
(   32) !     LDEQ_REGIONS - true if new eq_regions partitioning [false]
(   33) !     K_REGIONS    - Number of regions (1D or 2D partitioning)
(   34) !     K_REGIONS_NS - Maximum number of NS partitions
(   35) !     K_REGIONS_EW - Maximum number of EW partitions
(   36) !     PRAD         - Radius of the planet
(   37) !     LDALLOPERM  - Allocate certain arrays permanently
(   38) # 39 ".D[10]/setup_trans0.h"
(   39) !     The total number of (MPI)-processors has to be equal to KPRGPNS*KPRGPEW
(   40) # 41 ".D[10]/setup_trans0.h"
(   41) !     Method.
(   42) !     -------
(   43) # 44 ".D[10]/setup_trans0.h"
(   44) !     Externals.  SUMP_TRANS0 - initial setup routine
(   45) !     ----------
(   46) # 47 ".D[10]/setup_trans0.h"
(   47) !     Author.
(   48) !     -------
(   49) !        Mats Hamrud *ECMWF*
(   50) # 51 ".D[10]/setup_trans0.h"
(   51) !     Modifications.
(   52) !     --------------
(   53) !        Original : 00-03-03
(   54) !        R. El Khatib 03-01-24 LDMPOFF
(   55) !        G. Mozdzynski 2006-09-13 LDEQ_REGIONS
(   56) !        N. Wedi  2009-11-30 add radius
(   57) # 58 ".D[10]/setup_trans0.h"
(   58) !     ------------------------------------------------------------------
(   59) # 60 ".D[10]/setup_trans0.h"
(   60) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   61) # 62 ".D[10]/setup_trans0.h"
(   62) IMPLICIT NONE
(   63) # 64 ".D[10]/setup_trans0.h"
(   64) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KOUT,KERR,KPRINTLEV,KMAX_RESOL,KPROMATR
(   65) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KPRGPNS,KPRGPEW,KPRTRW,KCOMBFLEN
(   66) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDMPOFF
(   67) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDSYNC_TRANS






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 17

(   68) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KTRANS_SYNC_LEVEL
(   69) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDEQ_REGIONS
(   70) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDALLOPERM
(   71) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDALLOPERM2
(   72) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN)  :: PRAD
(   73) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS(:)
(   74) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS_NS
(   75) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS_EW
(   76) # 77 ".D[10]/setup_trans0.h"
(   77) END SUBROUTINE SETUP_TRANS0
(   78) # 81 ".D[10]/setup_trans0.h"
(   81) END INTERFACE
(   82) # 49 "aatestprog.F90"
(   49) # 50 "aatestprog.F90"
(   50) # 1 ".D[18]/setup_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE SETUP_TRANS(KSMAX,KDGL,KDLON,KLOEN,LDSPLIT,PSTRET,&
(    3) &KFLEV,KTMAX,KRESOL,PWEIGHT,LDGRIDONLY,LDUSERPNM,LDKEEPRPNM,LDUSEFLT,&
(    4) &LDSPSETUPONLY,LDPNMONLY,LDUSEFFTW,&
(    5) &LDLL,LDSHIFTLL,CDIO_LEGPOL,CDLEGPOLFNAME,KLEGPOLPTR,KLEGPOLPTR_LEN)
(    6) # 7 ".D[18]/setup_trans.h"
(    7) !**** *SETUP_TRANS* - Setup transform package for specific resolution
(    8) # 9 ".D[18]/setup_trans.h"
(    9) !     Purpose.
(   10) !     --------
(   11) !     To setup for making spectral transforms. Each call to this routine
(   12) !     creates a new resolution up to a maximum of NMAX_RESOL set up in
(   13) !     SETUP_TRANS0. You need to call SETUP_TRANS0 before this routine can
(   14) !     be called.
(   15) # 16 ".D[18]/setup_trans.h"
(   16) !**   Interface.
(   17) !     ----------
(   18) !     CALL SETUP_TRANS(...)
(   19) # 20 ".D[18]/setup_trans.h"
(   20) !     Explicit arguments : KLOEN,LDSPLIT are optional arguments
(   21) !     -------------------- 
(   22) !     KSMAX - spectral truncation required
(   23) !     KDGL  - number of Gaussian latitudes
(   24) !     KDLON - number of points on each latitude [2*KDGL]
(   25) !     KLOEN(:) - number of points on each Gaussian latitude [2*KDGL]
(   26) !     LDSPLIT - true if split latitudes in grid-point space [false]
(   27) !     KTMAX - truncation order for tendencies?
(   28) !     KRESOL - the resolution identifier
(   29) !     PWEIGHT - the weight per grid-point (for a weighted distribution)
(   30) !     LDGRIDONLY - true if only grid space is required
(   31) # 32 ".D[18]/setup_trans.h"
(   32) !     KSMAX,KDGL,KTMAX and KLOEN are GLOBAL variables desribing the resolution
(   33) !     in spectral and grid-point space
(   34) # 35 ".D[18]/setup_trans.h"
(   35) !     LDSPLIT describe the distribution among processors of grid-point data and
(   36) !     has no relevance if you are using a single processor
(   37) # 38 ".D[18]/setup_trans.h"
(   38) !     LDUSEFLT   - use Fast Legandre Transform (Butterfly algorithm)
(   39) !     LDUSERPNM  - Use Belusov to compute legendre pol. (else new alg.)
(   40) !     LDKEEPRPNM - Keep Legendre Polynomials (only applicable when using
(   41) !                  FLT, otherwise always kept)
(   42) !     LDPNMONLY  - Compute the Legendre polynomialsonly, not the FFTs.
(   43) !     LDUSEFFTW   - Use FFTW for FFTs






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 18

(   44) !     LDLL                 - Setup second set of input/output latitudes
(   45) !                                 the number of input/output latitudes to transform is equal KDGL 
(   46) !                                 or KDGL+2 in the case that includes poles + equator
(   47) !                                 the number of input/output longitudes to transform is 2*KDGL
(   48) !     LDSHIFTLL       - Shift output lon/lat data by 0.5*dx and 0.5*dy
(   49)  
(   50) !     Method.
(   51) !     -------
(   52) # 53 ".D[18]/setup_trans.h"
(   53) !     Externals.  SET_RESOL   - set resolution
(   54) !     ----------  SETUP_DIMS  - setup distribution independent dimensions
(   55) !                 SUMP_TRANS_PRELEG - first part of setup of distr. environment
(   56) !                 SULEG - Compute Legandre polonomial and Gaussian 
(   57) !                         Latitudes and Weights
(   58) !                 SUMP_TRANS - Second part of setup of distributed environment
(   59) !                 SUFFT - setup for FFT
(   60) # 61 ".D[18]/setup_trans.h"
(   61) !     Author.
(   62) !     -------
(   63) !        Mats Hamrud *ECMWF*
(   64) # 65 ".D[18]/setup_trans.h"
(   65) !     Modifications.
(   66) !     --------------
(   67) !        Original : 00-03-03
(   68) # 69 ".D[18]/setup_trans.h"
(   69) !     ------------------------------------------------------------------
(   70) # 71 ".D[18]/setup_trans.h"
(   71) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   72)     USE, INTRINSIC :: ISO_C_BINDING, ONLY:  C_PTR, C_INT,C_ASSOCIATED,C_SIZE_T
(   73) # 75 ".D[18]/setup_trans.h"
(   75) IMPLICIT NONE
(   76) # 77 ".D[18]/setup_trans.h"
(   77) ! Dummy arguments
(   78) # 79 ".D[18]/setup_trans.h"
(   79) INTEGER(KIND=JPIM) ,INTENT(IN) :: KSMAX,KDGL
(   80) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KDLON
(   81) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KLOEN(:)
(   82) LOGICAL   ,OPTIONAL,INTENT(IN) :: LDSPLIT
(   83) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KTMAX
(   84) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT):: KRESOL
(   85) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN) :: PWEIGHT(:)
(   86) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN) :: PSTRET
(   87) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KFLEV
(   88) LOGICAL   ,OPTIONAL,INTENT(IN):: LDGRIDONLY
(   89) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSEFLT
(   90) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSERPNM
(   91) LOGICAL   ,OPTIONAL,INTENT(IN):: LDKEEPRPNM
(   92) LOGICAL   ,OPTIONAL,INTENT(IN):: LDPNMONLY
(   93) LOGICAL   ,OPTIONAL,INTENT(IN):: LDSPSETUPONLY
(   94) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSEFFTW
(   95) LOGICAL   ,OPTIONAL,INTENT(IN):: LDLL
(   96) LOGICAL   ,OPTIONAL,INTENT(IN):: LDSHIFTLL
(   97) CHARACTER(LEN=*),OPTIONAL,INTENT(IN):: CDIO_LEGPOL
(   98) CHARACTER(LEN=*),OPTIONAL,INTENT(IN):: CDLEGPOLFNAME
(   99) TYPE(C_PTR) ,OPTIONAL,INTENT(IN) :: KLEGPOLPTR
(  100) INTEGER(C_SIZE_T) ,OPTIONAL,INTENT(IN) :: KLEGPOLPTR_LEN
(  101) # 103 ".D[18]/setup_trans.h"
(  103) END SUBROUTINE SETUP_TRANS






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 19

(  104) # 106 ".D[18]/setup_trans.h"
(  106) END INTERFACE
(  107) # 51 "aatestprog.F90"
(   51) # 51 "aatestprog.F90"
(   51) # 1 ".D[18]/trans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE TRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)                     &KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)                     &KMYMS,KASM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)                     &KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)                     &KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)                     &KULTPP,KPTRLS,KNMENG,&
(    8)                     &KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)                     &LDSPLITLAT,&
(   10)                     &KSMAX,PLAPIN,KNVALUE,KDEF_RESOL,LDLAM,&
(   11)                     &PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KDGLU)
(   12) # 13 ".D[18]/trans_inq.h"
(   13) !**** *TRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[18]/trans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[18]/trans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL TRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[18]/trans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[18]/trans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KASM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation
(   50) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   51) # 52 ".D[18]/trans_inq.h"
(   52) !                 GRIDPOINT SPACE                  
(   53) !     KFRSTLAT    - First latitude of each a-set in grid-point space






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 20

(   54) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   55) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   56) !     KPTRLAT     - Pointer to the start of each latitude
(   57) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   58) !                   NSTA and NONL arrays
(   59) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   60) !                   NSTA and NONL arrays
(   61) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   62) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   63) !     KSTA        - Position of first grid column for the latitudes on a 
(   64) !                   processor. The information is available for all processors.
(   65) !                   The b-sets are distinguished by the last dimension of 
(   66) !                   nsta().The latitude band for each a-set is addressed by 
(   67) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   68) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   69) !                   Each split latitude has two entries in nsta(,:) which 
(   70) !                   necessitates the rather complex addressing of nsta(,:)
(   71) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   72) !     KONL        - Number of grid columns for the latitudes on a processor.
(   73) !                   Similar to nsta() in data structure.
(   74) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   75) !                   two a-sets
(   76) # 77 ".D[18]/trans_inq.h"
(   77) !                FOURIER SPACE
(   78) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   79) !                the FFT's.
(   80) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   81) !                it performs the Fourier calculations
(   82) !     KNMENG   - associated (with NLOENG) cut-off zonal wavenumber
(   83) # 84 ".D[18]/trans_inq.h"
(   84) !                 LEGENDRE
(   85) !     PMU      - sin(Gaussian latitudes)
(   86) !     PGW      - Gaussian weights
(   87) !     PRPNM    - Legendre polynomials
(   88) !     KLEI3    - First dimension of Legendre polynomials
(   89) !     KSPOLEGL - Second dimension of Legendre polynomials
(   90) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   91) !     PLAPIN   - Eigen-values of the inverse Laplace operator
(   92) !     KDGLU    - Number of active points in an hemisphere for a given wavenumber "m"
(   93) # 94 ".D[18]/trans_inq.h"
(   94) !     Method.
(   95) !     -------
(   96) # 97 ".D[18]/trans_inq.h"
(   97) !     Externals.  SET_RESOL - set resolution
(   98) !     ----------  
(   99) # 100 ".D[18]/trans_inq.h"
(  100) !     Author.
(  101) !     -------
(  102) !        Mats Hamrud *ECMWF*
(  103) # 104 ".D[18]/trans_inq.h"
(  104) !     Modifications.
(  105) !     --------------
(  106) !        Original : 00-03-03
(  107) !        M. Hortal : 2001-03-05 Dimensions of the Legendre polynomials
(  108) !        R. El Khatib 08-Aug-2012 KSMAX,PLAPIN,KNVALUE,LDLAM,KDEF_RESOL
(  109) # 110 ".D[18]/trans_inq.h"
(  110) !     ------------------------------------------------------------------
(  111) # 112 ".D[18]/trans_inq.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 21

(  112) USE PARKIND1  ,ONLY : JPIM     ,JPRB, JPRD
(  113) # 115 ".D[18]/trans_inq.h"
(  115) IMPLICIT NONE
(  116) # 117 ".D[18]/trans_inq.h"
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(  118) # 119 ".D[18]/trans_inq.h"
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2
(  121) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2G
(  122) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2MX
(  123) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNUMP
(  124) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOT
(  125) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTG
(  126) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTMX
(  127) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTL(:,:)
(  128) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLOFF
(  129) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFLOFF
(  130) # 131 ".D[18]/trans_inq.h"
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYMS(:)
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KASM0(0:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KUMPP(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPOSSP(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRMS(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KALLMS(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDIM0G(0:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLAT(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLSTLAT(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLAT(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFRSTLAT(:)
(  142) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLSTLAT(:)
(  143) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSTA(:,:)
(  144) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KONL(:,:)
(  145) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  150) LOGICAL   ,OPTIONAL, INTENT(OUT) :: LDSPLITLAT(:)
(  151) # 152 ".D[18]/trans_inq.h"
(  152) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KULTPP(:)
(  153) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLS(:)
(  154) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNMENG(:)
(  155) # 156 ".D[18]/trans_inq.h"
(  156) REAL(KIND=JPRD)    ,OPTIONAL, INTENT(OUT) :: PMU(:)
(  157) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGW(:)
(  158) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PRPNM(:,:)
(  159) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLEI3
(  160) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPOLEGL
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPMS(0:)
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDGLU(0:)
(  163) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PLAPIN(-1:)
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  166) # 167 ".D[18]/trans_inq.h"
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) # 170 ".D[18]/trans_inq.h"
(  170) END SUBROUTINE TRANS_INQ






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 22

(  171) # 177 ".D[18]/trans_inq.h"
(  177) END INTERFACE
(  178) # 52 "aatestprog.F90"
(   52) # 52 "aatestprog.F90"
(   52) # 1 ".D[18]/dist_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE DIST_GRID(PGPG,KPROMA,KFDISTG,KFROM,KRESOL,PGP,KSORT)
(    3) # 4 ".D[18]/dist_grid.h"
(    4) !**** *DIST_GRID* - Distribute global gridpoint array among processors
(    5) # 6 ".D[18]/dist_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for distributing gridpoint array
(    9) # 10 ".D[18]/dist_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL DIST_GRID(...)
(   13) # 14 ".D[18]/dist_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PGPG(:,:) - Global spectral array
(   17) !     KFDISTG     - Global number of fields to be distributed
(   18) !     KPROMA      - required blocking factor for gridpoint input
(   19) !     KFROM(:)    - Processor resposible for distributing each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[18]/dist_grid.h"
(   27) !     Externals.  SET_RESOL      - set resolution
(   28) !     ----------  DIST_GRID_CTL  - control routine
(   29) # 30 ".D[18]/dist_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[18]/dist_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[18]/dist_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) # 40 ".D[18]/dist_grid.h"
(   40) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   41) # 43 ".D[18]/dist_grid.h"
(   43) IMPLICIT NONE
(   44) # 45 ".D[18]/dist_grid.h"
(   45) ! Declaration of arguments
(   46) # 47 ".D[18]/dist_grid.h"
(   47) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PGPG(:,:)
(   48) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFDISTG
(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFROM(:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   52) REAL(KIND=JPRB)             , INTENT(OUT) :: PGP(:,:,:)
(   53) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSORT (:)
(   54) # 56 ".D[18]/dist_grid.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 23

(   56) !     ------------------------------------------------------------------
(   57) # 58 ".D[18]/dist_grid.h"
(   58) END SUBROUTINE DIST_GRID
(   59) # 60 ".D[18]/dist_grid.h"
(   60) END INTERFACE
(   61) # 53 "aatestprog.F90"
(   53) # 53 "aatestprog.F90"
(   53) # 1 ".D[18]/gath_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE GATH_GRID(PGPG,KPROMA,KFGATHG,KTO,KRESOL,PGP)
(    3) # 4 ".D[18]/gath_grid.h"
(    4) !**** *GATH_GRID* - Gather global gridpoint array from processors
(    5) # 6 ".D[18]/gath_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering gripoint array
(    9) # 10 ".D[18]/gath_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL GATH_GRID(...)
(   13) # 14 ".D[18]/gath_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PGPG(:,:)   - Global gridpoint array
(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KPROMA      - blocking factor for gridpoint input
(   19) !     KTO(:)      - Processor responsible for gathering each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[18]/gath_grid.h"
(   27) !     Externals.  SET_RESOL   - set resolution
(   28) !     ----------  GATH_GRID_CTL -  control routine
(   29) # 30 ".D[18]/gath_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[18]/gath_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[18]/gath_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) # 40 ".D[18]/gath_grid.h"
(   40) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   41) # 43 ".D[18]/gath_grid.h"
(   43) IMPLICIT NONE
(   44) # 45 ".D[18]/gath_grid.h"
(   45) ! Declaration of arguments
(   46) # 47 ".D[18]/gath_grid.h"
(   47) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGPG(:,:)
(   48) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG
(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 24

(   52) REAL(KIND=JPRB)             , INTENT(IN)  :: PGP(:,:,:)
(   53) # 55 ".D[18]/gath_grid.h"
(   55) !     ------------------------------------------------------------------
(   56) # 57 ".D[18]/gath_grid.h"
(   57) END SUBROUTINE GATH_GRID
(   58) # 59 ".D[18]/gath_grid.h"
(   59) END INTERFACE
(   60) # 54 "aatestprog.F90"
(   54) # 54 "aatestprog.F90"
(   54) # 1 ".D[18]/gath_spec.h"
(    1) INTERFACE
(    2) SUBROUTINE GATH_SPEC(PSPECG,KFGATHG,KTO,KVSET,KRESOL,PSPEC,LDIM1_IS_FLD,KSMAX,LDZA0IP)
(    3) # 4 ".D[18]/gath_spec.h"
(    4) !**** *GATH_SPEC* - Gather global spectral array from processors
(    5) # 6 ".D[18]/gath_spec.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering spectral array
(    9) # 10 ".D[18]/gath_spec.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL GATH_SPEC(...)
(   13) # 14 ".D[18]/gath_spec.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PSPECG(:,:) - Global spectral array
(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KTO(:)      - Processor responsible for gathering each field
(   19) !     KVSET(:)    - "B-Set" for each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PSPEC(:,:)  - Local spectral array
(   23) !     LDIM1_IS_FLD - If TRUE first dimension of PSCPEC and PSPECG is the field dimension [.T.]
(   24) !
(   25) !     Method.
(   26) !     -------
(   27) # 28 ".D[18]/gath_spec.h"
(   28) !     Externals.  SET_RESOL   - set resolution
(   29) !     ----------  GATH_SPEC_CONTROL - control routine
(   30) # 31 ".D[18]/gath_spec.h"
(   31) !     Author.
(   32) !     -------
(   33) !        Mats Hamrud *ECMWF*
(   34) # 35 ".D[18]/gath_spec.h"
(   35) !     Modifications.
(   36) !     --------------
(   37) !        Original : 00-03-03
(   38) # 39 ".D[18]/gath_spec.h"
(   39) !     ------------------------------------------------------------------
(   40) # 41 ".D[18]/gath_spec.h"
(   41) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   42) # 44 ".D[18]/gath_spec.h"
(   44) IMPLICIT NONE
(   45) # 46 ".D[18]/gath_spec.h"
(   46) ! Declaration of arguments
(   47) # 48 ".D[18]/gath_spec.h"
(   48) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPECG(:,:)
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 25

(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KVSET(:)
(   52) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   53) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PSPEC(:,:)
(   54) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDIM1_IS_FLD
(   55) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSMAX
(   56) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDZA0IP
(   57) # 59 ".D[18]/gath_spec.h"
(   59) !     ------------------------------------------------------------------
(   60) # 61 ".D[18]/gath_spec.h"
(   61) END SUBROUTINE GATH_SPEC
(   62) # 63 ".D[18]/gath_spec.h"
(   63) END INTERFACE
(   64) # 55 "aatestprog.F90"
(   55) # 55 "aatestprog.F90"
(   55) # 1 ".D[18]/dir_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE DIR_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3) & LDLATLON,KPROMA,KVSETUV,KVSETSC,KRESOL,KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    4) & PGP,PGPUV,PGP3A,PGP3B,PGP2)
(    5) # 7 ".D[18]/dir_trans.h"
(    7) !**** *DIR_TRANS* - Direct spectral transform (from grid-point to spectral).
(    8) # 9 ".D[18]/dir_trans.h"
(    9) !     Purpose.
(   10) !     --------
(   11) !        Interface routine for the direct spectral transform
(   12) # 13 ".D[18]/dir_trans.h"
(   13) !**   Interface.
(   14) !     ----------
(   15) !     CALL DIR_TRANS(...)
(   16) # 17 ".D[18]/dir_trans.h"
(   17) !     Explicit arguments : All arguments except from PGP are optional.
(   18) !     -------------------- 
(   19) !     PSPVOR(:,:) - spectral vorticity (output)
(   20) !     PSPDIV(:,:) - spectral divergence (output)
(   21) !     PSPSCALAR(:,:) - spectral scalarvalued fields (output)
(   22) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   23) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   24) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   25) !     LDLATLON   - indicating if regular lat-lon is the input data
(   26) !     KPROMA      - required blocking factor for gridpoint output
(   27) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a 
(   28) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   29) !                   The length of KVSETUV should be the GLOBAL number
(   30) !                   of u/v fields which is the dimension of u and v releated
(   31) !                   fields in grid-point space. 
(   32) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   33) !                   scalar field. As for KVSETUV this argument is required
(   34) !                   if the total number of processors is greater than
(   35) !                   the number of processors used for distribution in
(   36) !                   spectral wave space.  
(   37) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   38) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   39) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   40) !     KRESOL   - resolution tag  which is required ,default is the
(   41) !                first defined resulution (input)
(   42) !     PGP(:,:,:) - gridpoint fields (input)
(   43) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 26

(   44) !                  NPROMA is the blocking factor, IF_GP the total number
(   45) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   46) !                  The ordering of the output fields is as follows (all 
(   47) !                  parts are optional depending on the input switches):
(   48) !
(   49) !     u             : IF_UV_G fields (if psvor present)
(   50) !     v             : IF_UV_G fields (if psvor present)
(   51) !     scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   52) !   
(   53) !     Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   54) !     of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   55) !     IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the 
(   56) !     length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   57) !     'b-set' split
(   58) # 59 ".D[18]/dir_trans.h"
(   59) !     As an alternative to using PGP you can also use a combination of the
(   60) !     following arrays. The reason for introducing these alternative ways
(   61) !     of calling DIR_TRANS is to avoid uneccessary copies where your data
(   62) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   63) !     The use of any of these precludes the use of PGP and vice versa.
(   64) # 65 ".D[18]/dir_trans.h"
(   65) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   66) !                      described for PGP. The second dimension of PGPUV should
(   67) !                      be the same as the "global" first dimension of 
(   68) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   69) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   70) !                      IFLDS is the number of 'variables' (u,v)
(   71) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   72) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   73) !                      IFLDS is the number of 'variables' (the same as in
(   74) !                      PSPSC3A )
(   75) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   76) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   77) !                      IFLDS is the number of 'variables' (the same as in
(   78) !                      PSPSC3B)
(   79) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   80) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   81) !                      IFLDS is the number of 'variables' (the same as in
(   82) !                      PSPSC2 )
(   83) ! 
(   84) !     Method.
(   85) !     -------
(   86) # 87 ".D[18]/dir_trans.h"
(   87) !     Externals.  SET_RESOL   - set resolution
(   88) !     ----------  LTDIR_CTL   - control of Legendre transform
(   89) !                 FTDIR_CTL   - control of Fourier transform
(   90) # 91 ".D[18]/dir_trans.h"
(   91) !     Author.
(   92) !     -------
(   93) !        Mats Hamrud *ECMWF*
(   94) # 95 ".D[18]/dir_trans.h"
(   95) !     Modifications.
(   96) !     --------------
(   97) !        Original : 00-03-03
(   98) # 99 ".D[18]/dir_trans.h"
(   99) !     ------------------------------------------------------------------
(  100) # 101 ".D[18]/dir_trans.h"
(  101) USE PARKIND1  ,ONLY : JPIM     ,JPRB






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 27

(  102) # 104 ".D[18]/dir_trans.h"
(  104) IMPLICIT NONE
(  105) # 106 ".D[18]/dir_trans.h"
(  106) ! Declaration of arguments
(  107) # 108 ".D[18]/dir_trans.h"
(  108) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPVOR(:,:)
(  109) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPDIV(:,:)
(  110) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSCALAR(:,:)
(  111) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3A(:,:,:)
(  112) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3B(:,:,:)
(  113) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC2(:,:)
(  114) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  115) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  116) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  118) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  121) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDLATLON
(  122) # 123 ".D[18]/dir_trans.h"
(  123) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP(:,:,:)
(  124) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGPUV(:,:,:,:)
(  125) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3A(:,:,:,:)
(  126) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3B(:,:,:,:)
(  127) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP2(:,:,:)
(  128) # 130 ".D[18]/dir_trans.h"
(  130) END SUBROUTINE DIR_TRANS
(  131) # 132 ".D[18]/dir_trans.h"
(  132) END INTERFACE
(  133) # 56 "aatestprog.F90"
(   56) # 56 "aatestprog.F90"
(   56) # 1 ".D[18]/inv_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE INV_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3)  & FSPGL_PROC,&
(    4)  & LDSCDERS,LDVORGP,LDDIVGP,LDUVDER,LDLATLON,KPROMA,KVSETUV,KVSETSC,KRESOL,&
(    5)  & KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    6)  & PGP,PGPUV,PGP3A,PGP3B,PGP2)
(    7) # 8 ".D[18]/inv_trans.h"
(    8) !**** *INV_TRANS* - Inverse spectral transform.
(    9) # 10 ".D[18]/inv_trans.h"
(   10) !     Purpose.
(   11) !     --------
(   12) !        Interface routine for the inverse spectral transform
(   13) # 14 ".D[18]/inv_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL INV_TRANS(...)
(   17) # 18 ".D[18]/inv_trans.h"
(   18) !     Explicit arguments : All arguments are optional.
(   19) !     -------------------- 
(   20) !     PSPVOR(:,:) - spectral vorticity (input)
(   21) !     PSPDIV(:,:) - spectral divergence (input)
(   22) !     PSPSCALAR(:,:) - spectral scalarvalued fields (input)
(   23) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   24) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   25) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   26) !     FSPGL_PROC  - external procedure to be executed in fourier space






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 28

(   27) !                   before transposition  
(   28) !     LDSCDERS    - indicating if derivatives of scalar variables are req.
(   29) !     LDVORGP     - indicating if grid-point vorticity is req.
(   30) !     LDDIVGP     - indicating if grid-point divergence is req.
(   31) !     LDUVDER     - indicating if E-W derivatives of u and v are req.
(   32) !     LDLATLON   - indicating if regular lat-lon output requested
(   33) !     KPROMA      - required blocking factor for gridpoint output
(   34) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a 
(   35) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   36) !                   The length of KVSETUV should be the GLOBAL number
(   37) !                   of u/v fields which is the dimension of u and v releated
(   38) !                   fields in grid-point space. 
(   39) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   40) !                   scalar field. As for KVSETUV this argument is required
(   41) !                   if the total number of processors is greater than
(   42) !                   the number of processors used for distribution in
(   43) !                   spectral wave space.
(   44) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   45) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   46) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   47) !     KRESOL   - resolution tag  which is required ,default is the
(   48) !                first defined resulution (input)
(   49) !     PGP(:,:,:) - gridpoint fields (output)
(   50) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   51) !                  NPROMA is the blocking factor, IF_GP the total number
(   52) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   53) !                  The ordering of the output fields is as follows (all 
(   54) !                  parts are optional depending on the input switches):
(   55) !
(   56) !       vorticity     : IF_UV_G fields (if psvor present and LDVORGP)
(   57) !       divergence    : IF_UV_G fields (if psvor present and LDDIVGP)
(   58) !       u             : IF_UV_G fields (if psvor present)
(   59) !       v             : IF_UV_G fields (if psvor present)
(   60) !       scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   61) !       N-S derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   62) !                                         present and LDSCDERS)
(   63) !       E-W derivative of u : IF_UV_G fields (if psvor present and and LDUVDER)
(   64) !       E-W derivative of v : IF_UV_G fields (if psvor present and and LDUVDER)
(   65) !       E-W derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   66) !                                         present and LDSCDERS)
(   67) !   
(   68) !       Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   69) !       of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   70) !       IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the 
(   71) !       length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   72) !       'b-set' split
(   73) # 74 ".D[18]/inv_trans.h"
(   74) !     As an alternative to using PGP you can also use a combination of the
(   75) !     following arrays. The reason for introducing these alternative ways
(   76) !     of calling INV_TRANS is to avoid uneccessary copies where your data
(   77) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   78) !     The use of any of these precludes the use of PGP and vice versa.
(   79) # 80 ".D[18]/inv_trans.h"
(   80) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   81) !                      described for PGP. The second dimension of PGPUV should
(   82) !                      be the same as the "global" first dimension of 
(   83) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   84) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 29

(   85) !                      IFLDS is the number of 'variables' (u,v,vor,div ...)
(   86) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   87) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   88) !                      IFLDS is the number of 'variables' (the same as in
(   89) !                      PSPSC3A if no derivatives, 3 times that with der.)
(   90) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   91) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   92) !                      IFLDS is the number of 'variables' (the same as in
(   93) !                      PSPSC3B if no derivatives, 3 times that with der.)
(   94) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   95) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   96) !                      IFLDS is the number of 'variables' (the same as in
(   97) !                      PSPSC2 if no derivatives, 3 times that with der.)
(   98) !     Method.
(   99) !     -------
(  100) # 101 ".D[18]/inv_trans.h"
(  101) !     Externals.  SET_RESOL   - set resolution
(  102) !     ----------  LTINV_CTL   - control of Legendre transform
(  103) !                 FTINV_CTL   - control of Fourier transform
(  104) # 105 ".D[18]/inv_trans.h"
(  105) !     Author.
(  106) !     -------
(  107) !        Mats Hamrud *ECMWF*
(  108) # 109 ".D[18]/inv_trans.h"
(  109) !     Modifications.
(  110) !     --------------
(  111) !        Original : 00-03-03
(  112) !        26-02-03 Mats Hamrud & Gabor Radnoti : modified condition for scalar fields
(  113) !                                               and derivatives (IF_SCALARS_G)
(  114) # 115 ".D[18]/inv_trans.h"
(  115) !     ------------------------------------------------------------------
(  116) # 117 ".D[18]/inv_trans.h"
(  117) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  118) # 120 ".D[18]/inv_trans.h"
(  120) IMPLICIT NONE
(  121) # 122 ".D[18]/inv_trans.h"
(  122) ! Declaration of arguments
(  123) # 124 ".D[18]/inv_trans.h"
(  124) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPVOR(:,:)
(  125) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPDIV(:,:)
(  126) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSCALAR(:,:)
(  127) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3A(:,:,:)
(  128) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3B(:,:,:)
(  129) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC2(:,:)
(  130) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDSCDERS
(  131) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDVORGP
(  132) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDDIVGP
(  133) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDUVDER
(  134) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDLATLON
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  142) EXTERNAL  FSPGL_PROC
(  143) OPTIONAL  FSPGL_PROC






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 30

(  144) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP(:,:,:)
(  145) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGPUV(:,:,:,:)
(  146) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3A(:,:,:,:)
(  147) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3B(:,:,:,:)
(  148) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP2(:,:,:)
(  149) # 151 ".D[18]/inv_trans.h"
(  151) END SUBROUTINE INV_TRANS
(  152) # 153 ".D[18]/inv_trans.h"
(  153) END INTERFACE
(  154) # 57 "aatestprog.F90"
(   57) # 58 "aatestprog.F90"
(   58) # 1 ".D[8]/esetup_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE ESETUP_TRANS(KMSMAX,KSMAX,KDGL,KDGUX,KLOEN,LDSPLIT,&
(    3)  & KFLEV,KTMAX,KRESOL,PEXWN,PEYWN,PWEIGHT,LDGRIDONLY,KNOEXTZL,KNOEXTZG,&
(    4)  & LDUSEFFTW)
(    5) !**** *ESETUP_TRANS* - Setup transform package for specific resolution
(    6) # 7 ".D[8]/esetup_trans.h"
(    7) !     Purpose.
(    8) !     --------
(    9) !     To setup for making spectral transforms. Each call to this routine
(   10) !     creates a new resolution up to a maximum of NMAX_RESOL set up in
(   11) !     SETUP_TRANS0. You need to call SETUP_TRANS0 before this routine can
(   12) !     be called.
(   13) # 14 ".D[8]/esetup_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL ESETUP_TRANS(...)
(   17) # 18 ".D[8]/esetup_trans.h"
(   18) !     Explicit arguments : KLOEN,LDSPLIT are optional arguments
(   19) !     -------------------- 
(   20) !     KSMAX - spectral truncation required
(   21) !     KDGL  - number of Gaussian latitudes
(   22) !     KLOEN(:) - number of points on each Gaussian latitude [2*KDGL]
(   23) !     LDSPLIT - true if split latitudes in grid-point space [false]
(   24) !     KTMAX - truncation order for tendencies?
(   25) !     KRESOL - the resolution identifier
(   26) !     KSMAX,KDGL,KTMAX and KLOEN are GLOBAL variables desribing the resolution
(   27) !     in spectral and grid-point space
(   28) !     LDGRIDONLY - true if only grid space is required
(   29) # 31 ".D[8]/esetup_trans.h"
(   31) !     LDSPLIT describe the distribution among processors of
(   32) !     grid-point data and has no relevance if you are using a single processor
(   33)  
(   34) !     LDUSEFFTW   - Use FFTW for FFTs
(   35) # 36 ".D[8]/esetup_trans.h"
(   36) !     Method.
(   37) !     -------
(   38) # 39 ".D[8]/esetup_trans.h"
(   39) !     Externals.  ESET_RESOL   - set resolution
(   40) !     ----------  ESETUP_DIMS  - setup distribution independent dimensions
(   41) !                 SUEMP_TRANS_PRELEG - first part of setup of distr. environment
(   42) !                 SULEG - Compute Legandre polonomial and Gaussian 
(   43) !                         Latitudes and Weights
(   44) !                 ESETUP_GEOM - Compute arrays related to grid-point geometry
(   45) !                 SUEMP_TRANS - Second part of setup of distributed environment
(   46) !                 SUEFFT - setup for FFT
(   47) # 48 ".D[8]/esetup_trans.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 31

(   48) !     Author.
(   49) !     -------
(   50) !        Mats Hamrud *ECMWF*
(   51) # 52 ".D[8]/esetup_trans.h"
(   52) !     Modifications.
(   53) !     --------------
(   54) !        Original : 00-03-03
(   55) !        02-04-11 A. Bogatchev: Passing of TCDIS
(   56) !        02-11-14 C. Fischer: soften test on KDGL
(   57) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(   58) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(   59) !        A.Bogatchev   16-Sep-2010 Phasing cy37
(   60) !        D. Degrauwe  (Feb 2012): Alternative extension zone (E')
(   61) # 62 ".D[8]/esetup_trans.h"
(   62) !     ------------------------------------------------------------------
(   63) # 64 ".D[8]/esetup_trans.h"
(   64) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   65) # 66 ".D[8]/esetup_trans.h"
(   66) IMPLICIT NONE
(   67) # 68 ".D[8]/esetup_trans.h"
(   68) ! Dummy arguments
(   69) INTEGER(KIND=JPIM),INTENT(IN)    :: KMSMAX 
(   70) INTEGER(KIND=JPIM),INTENT(IN)    :: KSMAX 
(   71) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGL 
(   72) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUX 
(   73) INTEGER(KIND=JPIM),INTENT(IN)    :: KLOEN(:) 
(   74) LOGICAL           ,OPTIONAL,INTENT(IN)    :: LDSPLIT 
(   75) LOGICAL           ,OPTIONAL,INTENT(IN)    :: LDGRIDONLY
(   76) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KTMAX 
(   77) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KFLEV
(   78) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KRESOL 
(   79) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PEXWN 
(   80) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PEYWN 
(   81) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PWEIGHT(:)
(   82) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KNOEXTZL
(   83) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KNOEXTZG
(   84) LOGICAL   ,OPTIONAL,INTENT(IN)            :: LDUSEFFTW
(   85) # 86 ".D[8]/esetup_trans.h"
(   86) END SUBROUTINE ESETUP_TRANS
(   87) END INTERFACE
(   88) # 59 "aatestprog.F90"
(   59) # 59 "aatestprog.F90"
(   59) # 1 ".D[8]/etrans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE ETRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)  & KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)  & KMYMS,KESM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)  & KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)  & KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)  & KULTPP,KPTRLS,&
(    8)  & KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)  & LDSPLITLAT,&
(   10)  & KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,KDEF_RESOL,LDLAM,&
(   11)  & PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KCPL2M,KCPL4M,KPROCM)  
(   12) # 13 ".D[8]/etrans_inq.h"
(   13) !**** *ETRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[8]/etrans_inq.h"
(   15) !     Purpose.






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 32

(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[8]/etrans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL ETRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[8]/etrans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[8]/etrans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KESM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation - n direction
(   50) !     KMSMAX   - spectral truncation - m direction
(   51) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   52) !     KMVALUE  - m value for each KSPEC2 spectral coeffient
(   53) # 54 ".D[8]/etrans_inq.h"
(   54) !                 GRIDPOINT SPACE                  
(   55) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   56) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   57) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   58) !     KPTRLAT     - Pointer to the start of each latitude
(   59) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   60) !                   NSTA and NONL arrays
(   61) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   62) !                   NSTA and NONL arrays
(   63) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   64) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   65) !     KSTA        - Position of first grid column for the latitudes on a 
(   66) !                   processor. The information is available for all processors.
(   67) !                   The b-sets are distinguished by the last dimension of 
(   68) !                   nsta().The latitude band for each a-set is addressed by 
(   69) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   70) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   71) !                   Each split latitude has two entries in nsta(,:) which 
(   72) !                   necessitates the rather complex addressing of nsta(,:)
(   73) !                   and the overdimensioning of nsta by N_REGIONS_NS.






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 33

(   74) !     KONL        - Number of grid columns for the latitudes on a processor.
(   75) !                   Similar to nsta() in data structure.
(   76) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   77) !                   two a-sets
(   78) # 79 ".D[8]/etrans_inq.h"
(   79) !                FOURIER SPACE
(   80) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   81) !                the FFT's.
(   82) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   83) !                it performs the Fourier calculations
(   84) # 85 ".D[8]/etrans_inq.h"
(   85) !                 LEGENDRE
(   86) !     PMU      - sin(Gaussian latitudes)
(   87) !     PGW      - Gaussian weights
(   88) !     PRPNM    - Legendre polynomials
(   89) !     KLEI3    - First dimension of Legendre polynomials
(   90) !     KSPOLEGL - Second dimension of Legendre polynomials
(   91) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   92) !     PLEPINM  - Eigen-values of the inverse Laplace operator
(   93) # 94 ".D[8]/etrans_inq.h"
(   94) !     Method.
(   95) !     -------
(   96) # 97 ".D[8]/etrans_inq.h"
(   97) !     Externals.  ESET_RESOL - set resolution
(   98) !     ----------  
(   99) # 100 ".D[8]/etrans_inq.h"
(  100) !     Author.
(  101) !     -------
(  102) !        Mats Hamrud *ECMWF*
(  103) # 104 ".D[8]/etrans_inq.h"
(  104) !     Modifications.
(  105) !     --------------
(  106) !        Original : 00-03-03
(  107) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(  108) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(  109) !        A.Bogatchev   16-Sep-2010 Phasing with TFL 36R4
(  110) !        R. El Khatib 08-Aug-2012 KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,LDLAM,KDEF_RESOL
(  111) # 112 ".D[8]/etrans_inq.h"
(  112) !     ------------------------------------------------------------------
(  113) # 114 ".D[8]/etrans_inq.h"
(  114) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  115) # 116 ".D[8]/etrans_inq.h"
(  116) IMPLICIT NONE
(  117) # 118 ".D[8]/etrans_inq.h"
(  118) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KRESOL 
(  119) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC 
(  120) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2 
(  121) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2G 
(  122) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2MX 
(  123) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KNUMP 
(  124) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOT 
(  125) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTG 
(  126) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTMX 
(  127) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTL(:,:) 
(  128) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KMYMS(:) 
(  129) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KESM0(0:) 
(  130) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KUMPP(:) 
(  131) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPOSSP(:) 






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 34

(  132) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRMS(:) 
(  133) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KALLMS(:) 
(  134) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KDIM0G(0:) 
(  135) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLAT(:) 
(  136) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLSTLAT(:) 
(  137) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLOFF 
(  138) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLAT(:) 
(  139) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFRSTLAT(:) 
(  140) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLSTLAT(:) 
(  141) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFLOFF 
(  142) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSTA(:,:) 
(  143) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KONL(:,:) 
(  144) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KULTPP(:) 
(  145) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLS(:) 
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  150) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  151) LOGICAL           ,OPTIONAL,INTENT(INOUT) :: LDSPLITLAT(:) 
(  152) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PMU(:) 
(  153) REAL(KIND=JPRB)   ,OPTIONAL               :: PGW(:) ! Argument NOT used
(  154) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PRPNM(:,:) 
(  155) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLEI3 
(  156) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPOLEGL 
(  157) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPMS(0:) 
(  158) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL2M(0:) 
(  159) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL4M(0:) 
(  160) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPROCM(0:) 
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMSMAX
(  163) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMVALUE(:)
(  165) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(OUT) :: PLEPINM(:)
(  166) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  167) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  168) # 169 ".D[8]/etrans_inq.h"
(  169) END SUBROUTINE ETRANS_INQ
(  170) END INTERFACE
(  171) # 60 "aatestprog.F90"
(   60) # 60 "aatestprog.F90"
(   60) # 1 ".D[8]/edist_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE EDIST_GRID(PGPG,KPROMA,KFDISTG,KFROM,KRESOL,PGP,KSORT)
(    3) # 4 ".D[8]/edist_grid.h"
(    4) !**** *EDIST_GRID* - Distribute global gridpoint array among processors
(    5) # 6 ".D[8]/edist_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for distributing gridpoint array
(    9) # 10 ".D[8]/edist_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL EDIST_GRID(...)
(   13) # 14 ".D[8]/edist_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PGPG(:,:) - Global spectral array






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 35

(   17) !     KFDISTG     - Global number of fields to be distributed
(   18) !     KPROMA      - required blocking factor for gridpoint input
(   19) !     KFROM(:)    - Processor resposible for distributing each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[8]/edist_grid.h"
(   27) !     Externals.  ESET_RESOL      - set resolution
(   28) !     ----------  DIST_GRID_CTL  - control routine
(   29) # 30 ".D[8]/edist_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[8]/edist_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[8]/edist_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   40) # 41 ".D[8]/edist_grid.h"
(   41) IMPLICIT NONE
(   42) # 43 ".D[8]/edist_grid.h"
(   43) ! Declaration of arguments
(   44) # 45 ".D[8]/edist_grid.h"
(   45) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PGPG(:,:)
(   46) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   47) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFDISTG
(   48) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFROM(:)
(   49) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   50) REAL(KIND=JPRB)             , INTENT(OUT) :: PGP(:,:,:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSORT (:)
(   52) # 54 ".D[8]/edist_grid.h"
(   54) !     ------------------------------------------------------------------
(   55) # 56 ".D[8]/edist_grid.h"
(   56) END SUBROUTINE EDIST_GRID
(   57) END INTERFACE
(   58) # 61 "aatestprog.F90"
(   61) # 61 "aatestprog.F90"
(   61) # 1 ".D[8]/egath_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE EGATH_GRID(PGPG,KPROMA,KFGATHG,KTO,KRESOL,PGP)
(    3) # 4 ".D[8]/egath_grid.h"
(    4) !**** *EGATH_GRID* - Gather global gridpoint array from processors
(    5) # 6 ".D[8]/egath_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering gripoint array
(    9) # 10 ".D[8]/egath_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL EGATH_GRID(...)
(   13) # 14 ".D[8]/egath_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 36

(   16) !     PGPG(:,:)   - Global gridpoint array
(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KPROMA      - blocking factor for gridpoint input
(   19) !     KTO(:)      - Processor responsible for gathering each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[8]/egath_grid.h"
(   27) !     Externals.  ESET_RESOL   - set resolution
(   28) !     ----------  GATH_GRID_CTL -  control routine
(   29) # 30 ".D[8]/egath_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[8]/egath_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[8]/egath_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   40) # 41 ".D[8]/egath_grid.h"
(   41) IMPLICIT NONE
(   42) # 43 ".D[8]/egath_grid.h"
(   43) ! Declaration of arguments
(   44) # 45 ".D[8]/egath_grid.h"
(   45) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGPG(:,:)
(   46) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   47) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG
(   48) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)
(   49) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   50) REAL(KIND=JPRB)             , INTENT(IN)  :: PGP(:,:,:)
(   51) # 53 ".D[8]/egath_grid.h"
(   53) !     ------------------------------------------------------------------
(   54) # 55 ".D[8]/egath_grid.h"
(   55) END SUBROUTINE EGATH_GRID
(   56) END INTERFACE
(   57) # 62 "aatestprog.F90"
(   62) # 62 "aatestprog.F90"
(   62) # 1 ".D[8]/egath_spec.h"
(    1) INTERFACE
(    2) SUBROUTINE EGATH_SPEC(PSPECG,KFGATHG,KTO,KVSET,KRESOL,PSPEC,LDIM1_IS_FLD,KSMAX,KMSMAX,LDZA0IP)
(    3) # 4 ".D[8]/egath_spec.h"
(    4) !**** *EGATH_SPEC* - Gather global spectral array from processors
(    5) # 6 ".D[8]/egath_spec.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering spectral array
(    9) # 10 ".D[8]/egath_spec.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL EGATH_SPEC(...)
(   13) # 14 ".D[8]/egath_spec.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 37

(   16) !     PSPECG(:,:) - Global spectral array
(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KTO(:)      - Processor responsible for gathering each field
(   19) !     KVSET(:)    - "B-Set" for each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PSPEC(:,:)  - Local spectral array
(   23) !     LDIM1_IS_FLD - If TRUE first dimension of PSCPEC and PSPECG is the field dimension [.T.]
(   24) !
(   25) !     Method.
(   26) !     -------
(   27) # 28 ".D[8]/egath_spec.h"
(   28) !     Externals.  SET_RESOL   - set resolution
(   29) !     ----------  EGATH_SPEC_CONTROL - control routine
(   30) # 31 ".D[8]/egath_spec.h"
(   31) !     Author.
(   32) !     -------
(   33) !        Mats Hamrud *ECMWF*
(   34) # 35 ".D[8]/egath_spec.h"
(   35) !     Modifications.
(   36) !     --------------
(   37) !        Original : 00-03-03
(   38) # 39 ".D[8]/egath_spec.h"
(   39) !     ------------------------------------------------------------------
(   40) # 41 ".D[8]/egath_spec.h"
(   41) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   42) # 44 ".D[8]/egath_spec.h"
(   44) IMPLICIT NONE
(   45) # 46 ".D[8]/egath_spec.h"
(   46) ! Declaration of arguments
(   47) # 48 ".D[8]/egath_spec.h"
(   48) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPECG(:,:)
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG
(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KVSET(:)
(   52) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   53) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PSPEC(:,:)
(   54) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDIM1_IS_FLD
(   55) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSMAX
(   56) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KMSMAX
(   57) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDZA0IP
(   58) # 60 ".D[8]/egath_spec.h"
(   60) !     ------------------------------------------------------------------
(   61) # 62 ".D[8]/egath_spec.h"
(   62) END SUBROUTINE EGATH_SPEC
(   63) # 64 ".D[8]/egath_spec.h"
(   64) END INTERFACE
(   65) # 63 "aatestprog.F90"
(   63) # 63 "aatestprog.F90"
(   63) # 1 ".D[8]/edir_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE EDIR_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3) & KPROMA,KVSETUV,KVSETSC,KRESOL,KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    4) & PGP,PGPUV,PGP3A,PGP3B,PGP2,PMEANU,PMEANV,AUX_PROC)
(    5) # 7 ".D[8]/edir_trans.h"
(    7) !**** *EDIR_TRANS* - Direct spectral transform (from grid-point to spectral).
(    8) # 9 ".D[8]/edir_trans.h"
(    9) !     Purpose.






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 38

(   10) !     --------
(   11) !        Interface routine for the direct spectral transform
(   12) # 13 ".D[8]/edir_trans.h"
(   13) !**   Interface.
(   14) !     ----------
(   15) !     CALL EDIR_TRANS(...)
(   16) # 17 ".D[8]/edir_trans.h"
(   17) !     Explicit arguments : All arguments except from PGP are optional.
(   18) !     --------------------
(   19) !     PSPVOR(:,:) - spectral vorticity (output)
(   20) !     PSPDIV(:,:) - spectral divergence (output)
(   21) !     PSPSCALAR(:,:) - spectral scalarvalued fields (output)
(   22) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   23) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   24) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   25) !     KPROMA      - required blocking factor for gridpoint output
(   26) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a
(   27) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   28) !                   The length of KVSETUV should be the GLOBAL number
(   29) !                   of u/v fields which is the dimension of u and v releated
(   30) !                   fields in grid-point space.
(   31) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   32) !                   scalar field. As for KVSETUV this argument is required
(   33) !                   if the total number of processors is greater than
(   34) !                   the number of processors used for distribution in
(   35) !                   spectral wave space.
(   36) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   37) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   38) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   39) !     KRESOL   - resolution tag  which is required ,default is the
(   40) !                first defined resulution (input)
(   41) !     PGP(:,:,:) - gridpoint fields (input)
(   42) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   43) !                  NPROMA is the blocking factor, IF_GP the total number
(   44) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   45) !                  The ordering of the output fields is as follows (all
(   46) !                  parts are optional depending on the input switches):
(   47) !
(   48) !     u             : IF_UV_G fields (if psvor present)
(   49) !     v             : IF_UV_G fields (if psvor present)
(   50) !     scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   51) !
(   52) !     Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   53) !     of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   54) !     IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the
(   55) !     length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   56) !     'b-set' split
(   57) # 58 ".D[8]/edir_trans.h"
(   58) !     As an alternative to using PGP you can also use a combination of the
(   59) !     following arrays. The reason for introducing these alternative ways
(   60) !     of calling DIR_TRANS is to avoid uneccessary copies where your data
(   61) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   62) !     The use of any of these precludes the use of PGP and vice versa.
(   63) # 64 ".D[8]/edir_trans.h"
(   64) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   65) !                      described for PGP. The second dimension of PGPUV should
(   66) !                      be the same as the "global" first dimension of
(   67) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 39

(   68) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   69) !                      IFLDS is the number of 'variables' (u,v)
(   70) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   71) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   72) !                      IFLDS is the number of 'variables' (the same as in
(   73) !                      PSPSC3A )
(   74) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   75) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   76) !                      IFLDS is the number of 'variables' (the same as in
(   77) !                      PSPSC3B)
(   78) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   79) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   80) !                      IFLDS is the number of 'variables' (the same as in
(   81) !                      PSPSC2 )
(   82) !     PMEANU(:),PMEANV(:) - mean wind
(   83) !     AUX_PROC       - optional external procedure for biperiodization of
(   84) !                      aux.fields
(   85) # 86 ".D[8]/edir_trans.h"
(   86) !     Method.
(   87) !     -------
(   88) # 89 ".D[8]/edir_trans.h"
(   89) !     Externals.  SET_RESOL   - set resolution
(   90) !     ----------  LTDIR_CTL   - control of Legendre transform
(   91) !                 FTDIR_CTL   - control of Fourier transform
(   92) # 93 ".D[8]/edir_trans.h"
(   93) !     Author.
(   94) !     -------
(   95) !        Mats Hamrud *ECMWF*
(   96) # 97 ".D[8]/edir_trans.h"
(   97) !     Modifications.
(   98) !     --------------
(   99) !        Original : 00-03-03
(  100) # 101 ".D[8]/edir_trans.h"
(  101) !     ------------------------------------------------------------------
(  102) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  103) # 104 ".D[8]/edir_trans.h"
(  104) IMPLICIT NONE
(  105) # 106 ".D[8]/edir_trans.h"
(  106) ! Declaration of arguments
(  107) # 108 ".D[8]/edir_trans.h"
(  108) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPVOR(:,:)
(  109) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPDIV(:,:)
(  110) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSCALAR(:,:)
(  111) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3A(:,:,:)
(  112) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3B(:,:,:)
(  113) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC2(:,:)
(  114) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  115) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  116) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  118) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  121) # 122 ".D[8]/edir_trans.h"
(  122) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP(:,:,:)
(  123) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGPUV(:,:,:,:)
(  124) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3A(:,:,:,:)
(  125) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3B(:,:,:,:)






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 40

(  126) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP2(:,:,:)
(  127) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PMEANU(:)
(  128) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PMEANV(:)
(  129) EXTERNAL AUX_PROC
(  130) OPTIONAL AUX_PROC
(  131) # 133 ".D[8]/edir_trans.h"
(  133) END SUBROUTINE EDIR_TRANS
(  134) # 135 ".D[8]/edir_trans.h"
(  135) END INTERFACE
(  136) # 64 "aatestprog.F90"
(   64) # 64 "aatestprog.F90"
(   64) # 1 ".D[8]/einv_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE EINV_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3)  & FSPGL_PROC,&
(    4)  & LDSCDERS,LDVORGP,LDDIVGP,LDUVDER,KPROMA,KVSETUV,KVSETSC,KRESOL,&
(    5)  & KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    6)  & PGP,PGPUV,PGP3A,PGP3B,PGP2,PMEANU,PMEANV)
(    7) # 8 ".D[8]/einv_trans.h"
(    8) !**** *EINV_TRANS* - Inverse spectral transform.
(    9) # 10 ".D[8]/einv_trans.h"
(   10) !     Purpose.
(   11) !     --------
(   12) !        Interface routine for the inverse spectral transform
(   13) # 14 ".D[8]/einv_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL EINV_TRANS(...)
(   17) # 18 ".D[8]/einv_trans.h"
(   18) !     Explicit arguments : All arguments are optional.
(   19) !     --------------------
(   20) !     PSPVOR(:,:) - spectral vorticity (input)
(   21) !     PSPDIV(:,:) - spectral divergence (input)
(   22) !     PSPSCALAR(:,:) - spectral scalarvalued fields (input)
(   23) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   24) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   25) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   26) !     FSPGL_PROC  - external procedure to be executed in fourier space
(   27) !                   before transposition
(   28) !     LDSCDERS    - indicating if derivatives of scalar variables are req.
(   29) !     LDVORGP     - indicating if grid-point vorticity is req.
(   30) !     LDDIVGP     - indicating if grid-point divergence is req.
(   31) !     LDUVDER     - indicating if E-W derivatives of u and v are req.
(   32) !     KPROMA      - required blocking factor for gridpoint output
(   33) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a
(   34) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   35) !                   The length of KVSETUV should be the GLOBAL number
(   36) !                   of u/v fields which is the dimension of u and v releated
(   37) !                   fields in grid-point space.
(   38) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   39) !                   scalar field. As for KVSETUV this argument is required
(   40) !                   if the total number of processors is greater than
(   41) !                   the number of processors used for distribution in
(   42) !                   spectral wave space.
(   43) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   44) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   45) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   46) !     KRESOL   - resolution tag  which is required ,default is the






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 41

(   47) !                first defined resulution (input)
(   48) !     PGP(:,:,:) - gridpoint fields (output)
(   49) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   50) !                  NPROMA is the blocking factor, IF_GP the total number
(   51) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   52) !                  The ordering of the output fields is as follows (all
(   53) !                  parts are optional depending on the input switches):
(   54) !
(   55) !       vorticity     : IF_UV_G fields (if psvor present and LDVORGP)
(   56) !       divergence    : IF_UV_G fields (if psvor present and LDDIVGP)
(   57) !       u             : IF_UV_G fields (if psvor present)
(   58) !       v             : IF_UV_G fields (if psvor present)
(   59) !       scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   60) !       N-S derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   61) !                                         present and LDSCDERS)
(   62) !       E-W derivative of u : IF_UV_G fields (if psvor present and and LDUVDER)
(   63) !       E-W derivative of v : IF_UV_G fields (if psvor present and and LDUVDER)
(   64) !       E-W derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   65) !                                         present and LDSCDERS)
(   66) !
(   67) !       Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   68) !       of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   69) !       IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the
(   70) !       length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   71) !       'b-set' split
(   72) # 73 ".D[8]/einv_trans.h"
(   73) !     As an alternative to using PGP you can also use a combination of the
(   74) !     following arrays. The reason for introducing these alternative ways
(   75) !     of calling INV_TRANS is to avoid uneccessary copies where your data
(   76) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   77) !     The use of any of these precludes the use of PGP and vice versa.
(   78) # 79 ".D[8]/einv_trans.h"
(   79) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   80) !                      described for PGP. The second dimension of PGPUV should
(   81) !                      be the same as the "global" first dimension of
(   82) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   83) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   84) !                      IFLDS is the number of 'variables' (u,v,vor,div ...)
(   85) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   86) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   87) !                      IFLDS is the number of 'variables' (the same as in
(   88) !                      PSPSC3A if no derivatives, 3 times that with der.)
(   89) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   90) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   91) !                      IFLDS is the number of 'variables' (the same as in
(   92) !                      PSPSC3B if no derivatives, 3 times that with der.)
(   93) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   94) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   95) !                      IFLDS is the number of 'variables' (the same as in
(   96) !                      PSPSC2 if no derivatives, 3 times that with der.)
(   97) !     Method.
(   98) !     -------
(   99) # 100 ".D[8]/einv_trans.h"
(  100) !     Externals.  ESET_RESOL   - set resolution
(  101) !     ----------  ELTINV_CTL   - control of Legendre transform
(  102) !                 EFTINV_CTL   - control of Fourier transform
(  103) # 104 ".D[8]/einv_trans.h"
(  104) !     Author.






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 42

(  105) !     -------
(  106) !        Mats Hamrud *ECMWF*
(  107) # 108 ".D[8]/einv_trans.h"
(  108) !     Modifications.
(  109) !     --------------
(  110) !        Original : 00-03-03
(  111) !        26-02-03 Mats Hamrud & Gabor Radnoti : modified condition for scalar fields
(  112) !                                               and derivatives (IF_SCALARS_G)
(  113) # 114 ".D[8]/einv_trans.h"
(  114) !     ------------------------------------------------------------------
(  115) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  116) # 117 ".D[8]/einv_trans.h"
(  117) IMPLICIT NONE
(  118) # 119 ".D[8]/einv_trans.h"
(  119) ! Declaration of arguments
(  120) # 121 ".D[8]/einv_trans.h"
(  121) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPVOR(:,:)
(  122) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPDIV(:,:)
(  123) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSCALAR(:,:)
(  124) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3A(:,:,:)
(  125) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3B(:,:,:)
(  126) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC2(:,:)
(  127) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDSCDERS
(  128) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDVORGP
(  129) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDDIVGP
(  130) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDUVDER
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  138) EXTERNAL  FSPGL_PROC
(  139) OPTIONAL  FSPGL_PROC
(  140) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP(:,:,:)
(  141) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGPUV(:,:,:,:)
(  142) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3A(:,:,:,:)
(  143) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3B(:,:,:,:)
(  144) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP2(:,:,:)
(  145) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN)  :: PMEANU(:)
(  146) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN)  :: PMEANV(:)
(  147) # 149 ".D[8]/einv_trans.h"
(  149) END SUBROUTINE EINV_TRANS
(  150) # 151 ".D[8]/einv_trans.h"
(  151) END INTERFACE
(  152) # 65 "aatestprog.F90"
(   65) # 66 "aatestprog.F90"
(   66) # 1 ".D[17]/abor1.intfb.h"
(    1) INTERFACE
(    2) # 3 ".D[17]/abor1.intfb.h"
(    3) SUBROUTINE ABOR1(CDTEXT)
(    4) CHARACTER(LEN=*), INTENT(IN) :: CDTEXT
(    5) END SUBROUTINE ABOR1
(    6) # 7 ".D[17]/abor1.intfb.h"
(    7) SUBROUTINE ABOR1FL(CDFILE, KLINENUM, CDTEXT)
(    8) USE PARKIND1  ,ONLY : JPIM
(    9) CHARACTER(LEN=*), INTENT(IN) :: CDFILE,CDTEXT






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 43

(   10) INTEGER(KIND=JPIM), INTENT(IN) :: KLINENUM
(   11) END SUBROUTINE ABOR1FL
(   12) # 13 ".D[17]/abor1.intfb.h"
(   13) SUBROUTINE ABOR1_EXCEPTION_HANDLER()
(   14) END SUBROUTINE ABOR1_EXCEPTION_HANDLER
(   15) # 16 ".D[17]/abor1.intfb.h"
(   16) END INTERFACE
(   17) # 67 "aatestprog.F90"
(   67) # 68 "aatestprog.F90"
(   68) NAMELIST / NAMAATESTPROG / & 
(   69)   & NFLDUA, NFLDSU, NMSMAX, NSMAX, NDGLG, NFLEVG, LDEBUG, NDLON, NPRINTLEV, NTIME, LELAM
(   70) # 71 "aatestprog.F90"
(   71) NAMELIST / NAMTRANS / & 
(   72)   & LUSEFLT, LUSERPNM, LKEEPRPNM
(   73) # 74 "aatestprog.F90"
(   74) NAMELIST / NAMPAR0 / & 
(   75)   & NPRGPNS, NPRGPEW, NPRTRW, NPRTRV
(   76) # 77 "aatestprog.F90"
(   77) NAMELIST / NAMPAR1 / & 
(   78)   & LEQ_REGIONS, LSPLIT
(   79) # 80 "aatestprog.F90"
(   80) NAMELIST / NAMRGRI / & 
(   81)   & NRGRI
(   82) # 83 "aatestprog.F90"
(   83) CHARACTER (LEN=64) :: CLNAMELIST
(   84) CHARACTER (LEN=64) :: CLFIELD
(   85) LOGICAL :: LLMPOFF, LLNOWRITE, LLNODIRTRANS, LLNOINVTRANS, LLTESTHARMONICS, LLALLOPERM
(   86) # 87 "aatestprog.F90"
(   87) REAL (KIND=JPRB) :: ZHOOK_HANDLE
(   88) # 89 "aatestprog.F90"
(   89) CALL GPU_BIND_JZ
(   90) CALL INITOPTIONS ()
(   91) CLNAMELIST = 'fort.4'
(   92) CALL GETOPTION ("--namelist", CLNAMELIST)
(   93) CALL GETOPTION ("--lmpoff", LLMPOFF)
(   94) NTIME     = 10
(   95) CALL GETOPTION ("--time", NTIME)
(   96) CLFIELD = ''
(   97) CALL GETOPTION ("--field-file", CLFIELD)
(   98) CALL GETOPTION ("--no-write", LLNOWRITE)
(   99) CALL GETOPTION ("--no-dir-trans", LLNODIRTRANS)
(  100) CALL GETOPTION ("--no-inv-trans", LLNOINVTRANS)
(  101) CALL GETOPTION ("--test-harmonics", LLTESTHARMONICS)
(  102) CALL GETOPTION ("--alloperm", LLALLOPERM)
(  103) CALL GETOPTION ("--check", LLCHECK)
(  104) CALL CHECKOPTIONS ()
(  105) # 107 "aatestprog.F90"
(  107) LLHOOK = LHOOK
(  108) LHOOK = .FALSE.
(  109) # 110 "aatestprog.F90"
(  110) OPEN (4, FILE=TRIM (CLNAMELIST), FORM='FORMATTED')
(  111) # 112 "aatestprog.F90"
(  112) LELAM     = .FALSE.
(  113) NFLDUA    = 1
(  114) NFLDSU    = 0
(  115) NPRINTLEV = 0
(  116) NSMAX     = 0
(  117) NMSMAX    = 0






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 44

(  118) NDGLG     = 0
(  119) NFLEVG    = 19
(  120) LDEBUG    = .FALSE.
(  121) # 122 "aatestprog.F90"
(  122) CALL POSNAM (4, 'NAMAATESTPROG')
(  123) READ (4, NAMAATESTPROG)
(  124) # 125 "aatestprog.F90"
(  125) IF ((NSMAX == 0) .OR. (NDGLG == 0)) THEN
(  126)   CALL ABOR1 ('DWARF: NSMAX AND NDGLG ARE REQUIRED')
(  127) ENDIF
(  128) # 129 "aatestprog.F90"
(  129) NPRGPNS = 0 
(  130) NPRGPEW = 0 
(  131) NPRTRW  = 0 
(  132) NPRTRV  = 0 
(  133) # 134 "aatestprog.F90"
(  134) CALL POSNAM (4, 'NAMPAR0')
(  135) READ (4, NAMPAR0)
(  136) # 137 "aatestprog.F90"
(  137) LUSEFLT   = NSMAX > 1280
(  138) LUSERPNM  = .NOT.LUSEFLT
(  139) LKEEPRPNM = .NOT.LUSEFLT
(  140) # 141 "aatestprog.F90"
(  141) CALL POSNAM (4, 'NAMTRANS')
(  142) READ (4, NAMTRANS)
(  143) # 144 "aatestprog.F90"
(  144) LEQ_REGIONS = .NOT. LELAM
(  145) LSPLIT      = .TRUE.
(  146) # 147 "aatestprog.F90"
(  147) CALL POSNAM (4, 'NAMPAR1')
(  148) READ (4, NAMPAR1)
(  149) # 150 "aatestprog.F90"
(  150) IF (LELAM) THEN
(  151)   NRGRI = NDLON
(  152) ELSE
(  153)   NRGRI = 0
(  154) ENDIF
(  155) # 156 "aatestprog.F90"
(  156) CALL POSNAM (4, 'NAMRGRI')
(  157) READ (4, NAMRGRI)
(  158) # 159 "aatestprog.F90"
(  159) CLOSE (4)
(  160) # 161 "aatestprog.F90"
(  161) ALLOCATE (NLOEN (NDGLG))
(  162) NLOEN (1:NDGLG) = NRGRI (1:NDGLG)
(  163) # 164 "aatestprog.F90"
(  164) IF (.NOT. LELAM) THEN
(  165)   IF (ANY (NLOEN (NDGLG/2+1:NDGLG) == 0)) THEN
(  166)     NLOEN (NDGLG/2+1:NDGLG) = NLOEN (NDGLG/2:1:-1)
(  167)   ENDIF
(  168)   IF (ANY (NLOEN (NDGLG/2:1:-1) /= NLOEN (NDGLG/2+1:NDGLG))) THEn
(  169)     CALL ABOR1 ('UNEXPECTED NLOEN')
(  170)   ENDIF
(  171) ENDIF
(  172) # 173 "aatestprog.F90"
(  173) IF (LLMPOFF) THEN
(  174)   MYPROC = 1
(  175)   NPROC  = 1






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 45

(  176) ELSE
(  177)   CALL MPL_INIT 
(  178)   MYPROC = MPL_MYRANK()
(  179)   NPROC  = MPL_NPROC ()
(  180) ENDIF
(  181) # 182 "aatestprog.F90"
(  182) ! GPU binding
(  183) # 184 "aatestprog.F90"
(  184) !CALL GPU_BIND (MYPROC-1, NPROC)
(  185) # 186 "aatestprog.F90"
(  186) IF (NPROC > 1 .AND. LLTESTHARMONICS) THEN
(  187)   CALL ABOR1 ('NPROC > 1 .AND. LLTESTHARMONICS')
(  188) ENDIF
(  189) # 190 "aatestprog.F90"
(  190) CALL SQUARE (NPROC, IB, IA)
(  191) # 192 "aatestprog.F90"
(  192) IF (NPRGPNS == 0 .AND. NPRGPEW == 0) THEN
(  193)   NPRGPNS = IA
(  194)   NPRGPEW = IB
(  195) ENDIF
(  196) # 197 "aatestprog.F90"
(  197) IF (NPRTRW == 0 .AND. NPRTRV == 0) THEN
(  198)   NPRTRW = IA
(  199)   NPRTRV = IB
(  200) ENDIF
(  201) # 202 "aatestprog.F90"
(  202) NBSETSP = MIN (NFLEVG+1, NPRTRV)
(  203) # 204 "aatestprog.F90"
(  204) IF (MYPROC == 1) THEN
(  205) # 206 "aatestprog.F90"
(  206)   WRITE (0, *) " NPROC = ", NPROC, " NTIME = ", NTIME, " LELAM = ", LELAM
(  207)   WRITE (0, *) " NFLDUA = ", NFLDUA, " NFLDSU = ", NFLDSU, " NFLEVG = ", NFLEVG
(  208)   WRITE (0, *) " NPRGPNS = ", NPRGPNS, " NPRGPEW = ", NPRGPEW
(  209)   WRITE (0, *) " NPRTRW = ", NPRTRW, " NPRTRV = ", NPRTRV
(  210)   WRITE (0, *) " LEQ_REGIONS = ", LEQ_REGIONS, " LSPLIT = ", LSPLIT
(  211)   WRITE (0, *) " NSMAX = ", NSMAX, " NDGLG = ", NDGLG
(  212) # 213 "aatestprog.F90"
(  213) ENDIF
(  214) # 215 "aatestprog.F90"
(  215) MYSETV = MOD (MYPROC-1, NPRTRV) + 1
(  216) MYSETW = (MYPROC-1) / NPRTRV + 1
(  217) # 219 "aatestprog.F90"
(  219) CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=2,   &
(  220)                  & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,     &
(  221)                  & LDEQ_REGIONS=LEQ_REGIONS, LDMPOFF=LLMPOFF,           &
(  222)                  & LDALLOPERM=LLALLOPERM, LDALLOPERM2=LLALLOPERM)
(  223) IF (LELAM) THEN
(  224)   CALL ESETUP_TRANS (KSMAX=NSMAX, KMSMAX=NMSMAX, KDGL=NDGLG, KDGUX=NDGLG, KLOEN=NLOEN, &
(  225)                    & LDSPLIT=LSPLIT, KFLEV=NFLEVG)
(  226)   CALL ETRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  227) ELSE
(  228)   CALL SETUP_TRANS (KSMAX=NSMAX, KDGL=NDGLG, KLOEN=NLOEN, LDSPLIT=LSPLIT, KFLEV=NFLEVG, &
(  229)                   & LDUSEFLT=LUSEFLT,LDUSERPNM=LUSERPNM, LDKEEPRPNM=LKEEPRPNM)
(  230)   CALL TRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  231) ENDIF
(  232) # 233 "aatestprog.F90"
(  233) IF (MYPROC == 1) THEN
(  234)   WRITE (0, *) " NGPTOTG = ", NGPTOTG, " NSPEC2G = ", NSPEC2G






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 46

(  235) ENDIF
(  236) # 237 "aatestprog.F90"
(  237) ALLOCATE (NBSETLEV (NFLEVG))
(  238) # 239 "aatestprog.F90"
(  239) DO ILEVG = 1, NFLEVG
(  240)   NBSETLEV (ILEVG) = MOD (ILEVG, NPRTRV) + 1
(  241) ENDDO
(  242) # 243 "aatestprog.F90"
(  243) NFLEV = COUNT (NBSETLEV == MYSETV)
(  244) # 245 "aatestprog.F90"
(  245) IFLDGPG = NFLDSU + NFLDUA * NFLEVG 
(  246) ALLOCATE (IVSET (IFLDGPG))
(  247) # 248 "aatestprog.F90"
(  248) DO IFLD = 1, NFLDSU
(  249)   IVSET (IFLD) = NBSETSP
(  250) ENDDO
(  251) # 252 "aatestprog.F90"
(  252) DO IFLD = 1, NFLDUA
(  253)   DO ILEVG = 1, NFLEVG
(  254)     IVSET (NFLDSU+ILEVG+(IFLD-1)*NFLEVG) = NBSETLEV (ILEVG)
(  255)   ENDDO
(  256) ENDDO
(  257) # 258 "aatestprog.F90"
(  258) IFLDSPL = COUNT (IVSET == MYSETV)
(  259) # 260 "aatestprog.F90"
(  260) PRINT *, " IFLDSPL = ", IFLDSPL, " MYPROC = ", MYPROC
(  261) # 262 "aatestprog.F90"
(  262) ALLOCATE (ZSPBUFL (IFLDSPL, NSPEC2))
(  263) ALLOCATE (ZGPBUFL (NGPTOT, IFLDGPG, 1))
(  264) # 265 "aatestprog.F90"
(  265) CALL GENFIELD
(  266) # 267 "aatestprog.F90"
(  267) IF (LLCHECK) THEN
(  268)   CALL CHECK (LDDIFF=.FALSE.)
(  269) ENDIF
(  270) # 271 "aatestprog.F90"
(  271) IF (.NOT. LLNOWRITE) THEN
(  272)   CALL WRIFIELD ('AATESTPROG.0.fa')
(  273) ENDIF
(  274) # 275 "aatestprog.F90"
(  275) IF (.NOT. LLMPOFF) CALL MPL_BARRIER()
(  276) # 277 "aatestprog.F90"
(  277) LHOOK = LLHOOK
(  278) # 279 "aatestprog.F90"
(  279) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',0,ZHOOK_HANDLE)
(  280) # 281 "aatestprog.F90"
(  281) IF (LLTESTHARMONICS) THEN
(  282)   CALL TESTHARMONICS
(  283) ELSE
(  284)   DO ITIME = 1, NTIME
(  285)     ZTSTEP = TIMEF()
(  286)   
(  287)     IF (LELAM) THEN
(  288)       IF (.NOT. LLNODIRTRANS) CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  289)       IF (.NOT. LLNOINVTRANS) CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  290)     ELSE
(  291)       IF (.NOT. LLNODIRTRANS) CALL DIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  292)       IF (.NOT. LLNOINVTRANS) CALL INV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 47

(  293)     ENDIF
(  294)   
(  295)     IF(MYPROC == 1) THEN
(  296)       ZTSTEP=(TIMEF()-ZTSTEP)
(  297)       WRITE(*,'(" time step ",I6," took", F8.2)') ITIME, ZTSTEP
(  298)     ENDIF
(  299)   ENDDO
(  300) ENDIF
(  301) # 302 "aatestprog.F90"
(  302) CALL FLUSH (0)
(  303) # 304 "aatestprog.F90"
(  304) IF (LELAM) THEN
(  305)   CALL ETRANS_END
(  306) ELSE
(  307)   CALL TRANS_END
(  308) ENDIF
(  309) # 310 "aatestprog.F90"
(  310) 999 CONTINUE
(  311) # 312 "aatestprog.F90"
(  312) IF (.NOT. LLMPOFF) CALL MPL_BARRIER
(  313) # 314 "aatestprog.F90"
(  314) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',1,ZHOOK_HANDLE)
(  315) # 316 "aatestprog.F90"
(  316) IF (.NOT. LLNOWRITE) THEN
(  317)   CALL WRIFIELD ('AATESTPROG.1.fa')
(  318) ENDIF
(  319) # 320 "aatestprog.F90"
(  320) IF (LLCHECK) THEN
(  321)   CALL CHECK (LDDIFF=.FALSE.)
(  322)   CALL CHECK (LDDIFF=.TRUE.)
(  323) ENDIF
(  324) # 325 "aatestprog.F90"
(  325) IF (.NOT. LLMPOFF) CALL MPL_END
(  326) # 327 "aatestprog.F90"
(  327) IF (MYPROC == 1) WRITE (0, *) " --------- END --------- "
(  328) # 329 "aatestprog.F90"
(  329) CALL FLUSH (0)
(  330) # 331 "aatestprog.F90"
(  331) CONTAINS
(  332) # 333 "aatestprog.F90"
(  333) SUBROUTINE TESTHARMONICS
(  334) # 335 "aatestprog.F90"
(  335) INTEGER (KIND=JPIM) :: INHARM
(  336) CHARACTER (LEN=32) :: CLFILE
(  337) # 338 "aatestprog.F90"
(  338) DO INHARM = 1, NSPEC2G
(  339) # 340 "aatestprog.F90"
(  340)   WRITE (CLFILE, '(I6.6)') INHARM
(  341) # 342 "aatestprog.F90"
(  342)   ZSPBUFL = 0._JPRB
(  343)   ZSPBUFL (1, INHARM) = 1._JPRB
(  344)   ZGPBUFL = 999._JPRB
(  345) # 346 "aatestprog.F90"
(  346)   CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  347)   
(  348) ! OPEN (77, FILE=TRIM (CLFILE)//'.gp.dat')
(  349) ! WRITE (77, *) ZGPBUFL (:, 1, 1)
(  350) ! CLOSE (77)






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 48

(  351) # 352 "aatestprog.F90"
(  352)   ZSPBUFL = 999._JPRB
(  353) # 354 "aatestprog.F90"
(  354)   CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  355) # 356 "aatestprog.F90"
(  356) ! OPEN (77, FILE=TRIM (CLFILE)//'.sp.dat')
(  357) ! WRITE (77, *) ZSPBUFL (1, :)
(  358) ! CLOSE (77)
(  359) # 360 "aatestprog.F90"
(  360)   WHERE (ABS (ZSPBUFL) < 1E-15)
(  361)     ZSPBUFL = 0._JPRB
(  362)   ENDWHERE
(  363) # 364 "aatestprog.F90"
(  364)   WHERE (ABS (ZSPBUFL - 1._JPRB) < 1E-15)
(  365)     ZSPBUFL = 1._JPRB
(  366)   ENDWHERE
(  367) # 368 "aatestprog.F90"
(  368)   WRITE (88, '(I6," ",I6," ",I6," ",I6," ",I6)') INHARM, &
(  369)        & COUNT (ZSPBUFL (1, :) == 0._JPRB), COUNT (ZSPBUFL (1, :) == 1._JPRB), &
(  370)        & COUNT ((ZSPBUFL (1, :) /= 1._JPRB) .AND. (ZSPBUFL (1, :) /= 0._JPRB)), &
(  371)        & NSPEC2G
(  372)  
(  373) # 374 "aatestprog.F90"
(  374) ENDDO
(  375) # 376 "aatestprog.F90"
(  376) END SUBROUTINE
(  377) # 378 "aatestprog.F90"
(  378) SUBROUTINE SQUARE (KN, KA, KB)
(  379) # 380 "aatestprog.F90"
(  380) INTEGER (KIND=JPIM) :: KN, KA, KB
(  381) # 382 "aatestprog.F90"
(  382) KB = INT (SQRT (REAL (KN))) + 1
(  383) # 384 "aatestprog.F90"
(  384) DO
(  385)   KA = KN / KB
(  386)   IF (KA * KB == KN) EXIT
(  387)   KB = KB - 1
(  388) ENDDO
(  389) # 390 "aatestprog.F90"
(  390) END SUBROUTINE SQUARE
(  391) # 392 "aatestprog.F90"
(  392) SUBROUTINE POSNAM (KULNAM,CDNAML)
(  393) # 394 "aatestprog.F90"
(  394) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  395) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  396) # 397 "aatestprog.F90"
(  397) IMPLICIT NONE
(  398) # 399 "aatestprog.F90"
(  399) INTEGER(KIND=JPIM),INTENT(IN)    :: KULNAM 
(  400) CHARACTER(LEN=*)  ,INTENT(IN)    :: CDNAML 
(  401) # 403 "aatestprog.F90"
(  403) # 1 ".D[17]/abor1.intfb.h"
(    1) INTERFACE
(    2) # 3 ".D[17]/abor1.intfb.h"
(    3) SUBROUTINE ABOR1(CDTEXT)
(    4) CHARACTER(LEN=*), INTENT(IN) :: CDTEXT
(    5) END SUBROUTINE ABOR1
(    6) # 7 ".D[17]/abor1.intfb.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 49

(    7) SUBROUTINE ABOR1FL(CDFILE, KLINENUM, CDTEXT)
(    8) USE PARKIND1  ,ONLY : JPIM
(    9) CHARACTER(LEN=*), INTENT(IN) :: CDFILE,CDTEXT
(   10) INTEGER(KIND=JPIM), INTENT(IN) :: KLINENUM
(   11) END SUBROUTINE ABOR1FL
(   12) # 13 ".D[17]/abor1.intfb.h"
(   13) SUBROUTINE ABOR1_EXCEPTION_HANDLER()
(   14) END SUBROUTINE ABOR1_EXCEPTION_HANDLER
(   15) # 16 ".D[17]/abor1.intfb.h"
(   16) END INTERFACE
(   17) # 404 "aatestprog.F90"
(  404) # 406 "aatestprog.F90"
(  406) CHARACTER (LEN = 40) ::  CLINE
(  407) CHARACTER (LEN =  1) ::  CLTEST
(  408) # 409 "aatestprog.F90"
(  409) INTEGER(KIND=JPIM) :: ILEN, IND1, ISTATUS, ISCAN
(  410) REAL(KIND=JPRB)    :: ZHOOK_HANDLE
(  411) # 412 "aatestprog.F90"
(  412) IF (LHOOK) CALL DR_HOOK('POSNAM',0,ZHOOK_HANDLE)
(  413) # 414 "aatestprog.F90"
(  414) CLINE='                                        '
(  415) REWIND(KULNAM)
(  416) ILEN=LEN(CDNAML)
(  417) ISTATUS=0
(  418) ISCAN=0
(  419) DO WHILE (ISTATUS==0 .AND. ISCAN==0)
(  420)   READ(KULNAM,'(A)',IOSTAT=ISTATUS) CLINE
(  421)   SELECT CASE (ISTATUS)
(  422)   CASE (:-1)
(  423)     CALL ABOR1 ('POSNAM: CANNOT FIND '//TRIM (CDNAML))
(  424)   CASE (0)
(  425)     IF (INDEX(CLINE(1:10),'&') == 0) THEN
(  426)       ISCAN=0
(  427)     ELSE
(  428)       IND1=INDEX(CLINE,'&'//CDNAML)
(  429)       IF (IND1 == 0) THEN
(  430)         ISCAN=0
(  431)       ELSE
(  432)         CLTEST=CLINE(IND1+ILEN+1:IND1+ILEN+1)
(  433)         IF (   (LGE(CLTEST,'0').AND.LLE(CLTEST,'9')) &
(  434)          & .OR.(LGE(CLTEST,'A').AND.LLE(CLTEST,'Z')) ) THEN
(  435)           ISCAN=0
(  436)         ELSE
(  437)           ISCAN=1
(  438)         ENDIF
(  439)       ENDIF
(  440)     ENDIF
(  441)   CASE (1:)
(  442)     CALL ABOR1 ('POSNAM: AN ERROR HAPPENED WHILE READING THE NAMELIST')
(  443)   END SELECT
(  444) ENDDO
(  445) BACKSPACE(KULNAM)
(  446) # 447 "aatestprog.F90"
(  447) IF (LHOOK) CALL DR_HOOK('POSNAM',1,ZHOOK_HANDLE)
(  448) END SUBROUTINE POSNAM
(  449) # 450 "aatestprog.F90"
(  450) SUBROUTINE WRIFIELD (CDFILE)
(  451) # 452 "aatestprog.F90"






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 50

(  452) CHARACTER (LEN=*), INTENT (IN) :: CDFILE
(  453) INTEGER (KIND=JPIM) :: ITO (IFLDGPG), JFLD
(  454) CHARACTER (LEN=16) :: CLPREF, CLSUFF
(  455) # 456 "aatestprog.F90"
(  456) ITO = 1
(  457) # 458 "aatestprog.F90"
(  458) IF (MYPROC == 1) THEN
(  459)   ALLOCATE (ZGPBUFG (NGPTOTG, IFLDGPG))
(  460) # 461 "aatestprog.F90"
(  461)   IF (LELAM) THEN
(  462)     CALL EGATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  463)   ELSE
(  464)     CALL GATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  465)   ENDIF
(  466) # 467 "aatestprog.F90"
(  467)   CALL SYSTEM ('rm -f '//TRIM (CDFILE))
(  468) # 469 "aatestprog.F90"
(  469)   DO JFLD = 1, IFLDGPG
(  470)     CLPREF = 'SURF'
(  471)     WRITE (CLSUFF, '("FFFF.",I4.4)') JFLD
(  472)     CALL WFA (ZGPBUFG (:, JFLD), CDFILE, CLPREF, CLSUFF)
(  473)   ENDDO
(  474) # 475 "aatestprog.F90"
(  475)   DEALLOCATE (ZGPBUFG)
(  476) ELSE
(  477)   IF (LELAM) THEN
(  478)     CALL EGATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  479)   ELSE
(  480)     CALL GATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  481)   ENDIF
(  482) ENDIF
(  483) # 484 "aatestprog.F90"
(  484) END SUBROUTINE
(  485) # 486 "aatestprog.F90"
(  486) SUBROUTINE WFA (PGLO, CDFILE, CDPREF, CDSUFF)
(  487) # 488 "aatestprog.F90"
(  488) REAL (KIND=JPRB),  INTENT (IN) :: PGLO (:)
(  489) CHARACTER (LEN=*), INTENT (IN) :: CDFILE, CDPREF, CDSUFF
(  490) # 491 "aatestprog.F90"
(  491) REAL (KIND=JPRB) :: ZMU (NDGLG)
(  492) # 493 "aatestprog.F90"
(  493) CHARACTER (LEN=3) :: CLNOMC 
(  494) REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
(  495) INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
(  496) INTEGER (KIND=JPIM) :: NLOENG (NDGLG), INOZPA (NDGLG)
(  497) INTEGER (KIND=JPIM) :: INBARP, INBARI, ILUN, IREP
(  498) INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
(  499) INTEGER (KIND=JPIM) :: IDATEF (11), ILCHAM
(  500) CHARACTER (LEN=16)  :: CLSTATUS
(  501) LOGICAL :: LLEXIST
(  502) # 503 "aatestprog.F90"
(  503) INQUIRE (FILE=TRIM (CDFILE), EXIST=LLEXIST)
(  504) # 505 "aatestprog.F90"
(  505) IF (LLEXIST) THEN
(  506)   CLSTATUS = 'OLD'
(  507)   IF (LELAM) THEN
(  508)     CLNOMC = 'ALD'
(  509)   ELSE






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 51

(  510)     CLNOMC = 'ARP'
(  511)   ENDIF
(  512) ELSE
(  513)   CLSTATUS = 'NEW'
(  514) IF (LELAM) THEN
(  515) BLOCK
(  516)   INTEGER (KIND=JPIM) :: INLOPA (8)
(  517)   INTEGER (KIND=JPIM) :: NX, NY, NUX, NUY
(  518)   REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
(  519)   REAL (KIND=JPRB) :: ZSINLA (18)
(  520) # 521 "aatestprog.F90"
(  521)   REAL (KIND=JPRB), PARAMETER :: LADINDEGREES    = 46.2_JPRB
(  522)   REAL (KIND=JPRB), PARAMETER :: LATIN1INDEGREES = 46.2_JPRB
(  523)   REAL (KIND=JPRB), PARAMETER :: LATIN2INDEGREES = 46.2_JPRB
(  524)   REAL (KIND=JPRB), PARAMETER :: LOVINDEGREES    =  2.0_JPRB
(  525) # 526 "aatestprog.F90"
(  526)   CLNOMC = 'ALD'
(  527)   NX = NDLON
(  528)   NY = NDGLG
(  529) # 530 "aatestprog.F90"
(  530)   ! Round dx to 100m
(  531)   DXINMETRES = 2000.E3_JPRB / REAL (NX - 1, JPRB)
(  532)   DXINMETRES = 100._JPRB * NINT (DXINMETRES / 100._JPRB) 
(  533)   DYINMETRES = DXINMETRES
(  534) # 535 "aatestprog.F90"
(  535)   NUX = NX - 1
(  536)   NUY = NY - 1
(  537) # 538 "aatestprog.F90"
(  538)   INLATI = NY
(  539)   INXLON = NX
(  540)   ZSLAPO = 0._JPRB
(  541)   ZCLOPO = 0._JPRB
(  542)   ZSLOPO = 0._JPRB
(  543)   ZCODIL = 0._JPRB
(  544)   ZREFER = 0._JPRB
(  545)   INIVER = 1_JPIM
(  546)   ZAHYBR = 0._JPRB
(  547)   ZBHYBR = 0._JPRB 
(  548)   INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
(  549)   ITRONC = +INLATI / 2 - 1 
(  550)   ITYPTR = -INXLON / 2 + 1 
(  551)   
(  552)   ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
(  553)          &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &
(  554)          &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, 0._JPRB, &
(  555)          &  0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB ]
(  556)   
(  557)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
(  558)   &            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
(  559)   &            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
(  560)   &            ZBHYBR, .FALSE.)
(  561) # 562 "aatestprog.F90"
(  562) ENDBLOCK
(  563) ELSE
(  564) BLOCK
(  565)   REAL (KIND=JPRB) :: ZCENTRE (2)
(  566) # 567 "aatestprog.F90"
(  567)   CLNOMC = 'ARP'






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 52

(  568) # 569 "aatestprog.F90"
(  569)   CALL TRANS_INQ (PMU=ZMU)
(  570)   
(  571)   ZCENTRE = [0._JPRB, 90._JPRB]
(  572)   ZCODIL = 1._JPRB
(  573)   
(  574)   INIVER = 1_JPIM
(  575)   ZAHYBR = 0._JPRB
(  576)   ZBHYBR = 0._JPRB
(  577)   ITYPTR = 2_JPIM
(  578)   
(  579)   NLOENG = NLOEN
(  580)   
(  581)   ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
(  582)   ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
(  583)   ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
(  584)   INLATI = NDGLG
(  585)   INXLON = MAXVAL (NLOENG)
(  586)   ITRONC = INXLON / 3
(  587)   INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
(  588)   ZREFER = 1._JPRB
(  589)   
(  590)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
(  591)   &            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
(  592)   &            INOZPA, ZMU,    INIVER, ZREFER, ZAHYBR, &
(  593)   &            ZBHYBR, .FALSE.)
(  594) # 595 "aatestprog.F90"
(  595) ENDBLOCK
(  596) ENDIF
(  597) ENDIF
(  598)  
(  599) # 600 "aatestprog.F90"
(  600) INBARP = 0
(  601) INBARI = 0
(  602) ILUN = 77
(  603) CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), CLSTATUS, .TRUE., &
(  604)            & .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
(  605) # 606 "aatestprog.F90"
(  606) IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
(  607) CALL FANDAR (IREP, ILUN, IDATEF)
(  608) # 609 "aatestprog.F90"
(  609) CALL FATCHA (IREP, CLNOMC, .FALSE., ILCHAM)
(  610) # 611 "aatestprog.F90"
(  611) CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
(  612) INGRIB = 123_JPIM
(  613) CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
(  614) # 615 "aatestprog.F90"
(  615) CALL FAIENC (IREP, ILUN, CDPREF, 0, CDSUFF, PGLO, .FALSE.)
(  616) # 617 "aatestprog.F90"
(  617) CALL FAIRME (IREP, ILUN, 'KEEP')
(  618) # 619 "aatestprog.F90"
(  619) END SUBROUTINE
(  620) # 621 "aatestprog.F90"
(  621) SUBROUTINE CHECK (LDDIFF)
(  622) # 623 "aatestprog.F90"
(  623) LOGICAL, INTENT (IN) :: LDDIFF
(  624) # 625 "aatestprog.F90"
(  625) ! Save result in ZGPBUFL1






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 53

(  626) # 627 "aatestprog.F90"
(  627) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL1 (:,:,:) 
(  628) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG1 (:,:) 
(  629) INTEGER (KIND=JPIM) :: JFLD, ITO (1)
(  630) REAL (KIND=JPRB) :: ZDIFF2 (IFLDGPG)
(  631) # 632 "aatestprog.F90"
(  632) ALLOCATE (ZGPBUFL1 (NGPTOT, IFLDGPG, 1)) 
(  633) # 634 "aatestprog.F90"
(  634) ZGPBUFL1 = ZGPBUFL
(  635) # 636 "aatestprog.F90"
(  636) ! Recreate original field
(  637) # 639 "aatestprog.F90"
(  639) IF (LDDIFF) THEN
(  640)   CALL GENFIELD
(  641)   ZGPBUFL1 = ZGPBUFL1 - ZGPBUFL
(  642) ENDIF
(  643) # 644 "aatestprog.F90"
(  644) IF (MYPROC == 1) THEN
(  645)   IF (LDDIFF) THEN
(  646)     WRITE (100, *) "                  ------------- DIFF ------------- "
(  647)   ELSE
(  648)     WRITE (100, *) "                  ------------- STAT ------------- "
(  649)   ENDIF
(  650) ENDIF
(  651) # 652 "aatestprog.F90"
(  652) ITO = 1
(  653) # 654 "aatestprog.F90"
(  654) DO JFLD = 1, IFLDGPG
(  655) # 656 "aatestprog.F90"
(  656)   IF (MYPROC == 1) THEN
(  657)     ALLOCATE (ZGPBUFG1 (NGPTOTG, 1))
(  658)     IF (LELAM) THEN
(  659)       CALL EGATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  660)     ELSE
(  661)       CALL GATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  662)     ENDIF
(  663)     WRITE (100, '(" FIELD ",I6," L2 =",E16.8," L1 = ",E16.8," MEAN =",E16.8)') & 
(  664)          & JFLD, SQRT (SUM (ZGPBUFG1 * ZGPBUFG1) / REAL (NGPTOTG, JPRB)), &
(  665)          & SUM (ABS (ZGPBUFG1)) / REAL (NGPTOTG, JPRB), SUM (ZGPBUFG1)
(  666)     DEALLOCATE (ZGPBUFG1)
(  667)   ELSE
(  668)     IF (LELAM) THEN
(  669)       CALL EGATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  670)     ELSE
(  671)       CALL GATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  672)     ENDIF
(  673)   ENDIF
(  674) # 675 "aatestprog.F90"
(  675) ENDDO
(  676) # 677 "aatestprog.F90"
(  677) END SUBROUTINE
(  678) # 679 "aatestprog.F90"
(  679) SUBROUTINE GENFIELD
(  680) # 681 "aatestprog.F90"
(  681) IF (MYPROC == 1) THEN
(  682)   ALLOCATE (ZGPBUFG (NGPTOTG, 1))
(  683) # 684 "aatestprog.F90"
(  684)   IF (CLFIELD /= '') THEN






NVFORTRAN (Version    20.11)          02/16/2022  17:29:54      page 54

(  685)     OPEN (77, FILE=TRIM (CLFIELD), FORM='UNFORMATTED', STATUS='OLD')
(  686)     READ (77) ZGPBUFG (:, 1)
(  687)     CLOSE (77)
(  688)   ELSE
(  689)   BLOCK
(  690)     REAL (KIND=JPRB) :: ZLON, ZLAT, ZVAL, ZX, ZY
(  691)     INTEGER (KIND=JPIM) :: JLAT, JLON, JGLO
(  692) # 693 "aatestprog.F90"
(  693)     JGLO = 1
(  694) # 695 "aatestprog.F90"
(  695)     DO JLAT = 1, NDGLG
(  696)       DO JLON = 1, NLOEN (JLAT)
(  697)        
(  698)         IF (LELAM) THEN
(  699)           ZX = REAL (JLON-1, JPRB) / REAL (NDLON, JPRB)
(  700)           ZY = REAL (JLAT-1, JPRB) / REAL (NDLON, JPRB)
(  701)           ZVAL = ZX * (1._JPRB - ZX) * ZY * (1._JPRB - ZY) * 4._JPRB + 0.5
(  702)         ELSE
(  703)           ZLAT = + RPI * (0.5_JPRB - REAL (JLAT, JPRB) / REAL (NDGLG+1, JPRB))
(  704)           ZLON = 2 * RPI * REAL (JLON-1, JPRB) / REAL (NLOEN (JLAT))
(  705)           ZVAL = COS (ZLAT) * SIN (ZLON)
(  706)         ENDIF
(  707)         ZGPBUFG (JGLO, 1) = ZVAL
(  708)         JGLO = JGLO + 1
(  709)       ENDDO
(  710)     ENDDO
(  711)   ENDBLOCK
(  712)   ENDIF
(  713) # 714 "aatestprog.F90"
(  714)   IF (LELAM) THEN
(  715)     CALL EDIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  716)   ELSE
(  717)     CALL DIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  718)   ENDIF
(  719) # 720 "aatestprog.F90"
(  720)   DEALLOCATE (ZGPBUFG)
(  721) # 722 "aatestprog.F90"
(  722) ELSE
(  723)   IF (LELAM) THEN
(  724)     CALL EDIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  725)   ELSE
(  726)     CALL DIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  727)   ENDIF
(  728) ENDIF
(  729) # 730 "aatestprog.F90"
(  730) DO IFLD = 2, IFLDGPG
(  731)   ZGPBUFL (:, IFLD, 1) = ZGPBUFL (:, 1, 1) * REAL (IFLD, JPRB)
(  732) ENDDO
(  733) # 735 "aatestprog.F90"
(  735) END SUBROUTINE
(  736) # 737 "aatestprog.F90"
(  737) END PROGRAM TEST
