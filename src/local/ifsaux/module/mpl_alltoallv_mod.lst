


NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/include
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/lib
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: mpl_alltoallv_mod.F90

(    1) MODULE MPL_ALLTOALLV_MOD
(    2) 
(    3) !**** MPL_ALLTOALLV - Everyone sends different data to everyone
(    4) 
(    5) !     Purpose.
(    6) !     --------
(    7) !     Interface to MPI_ALLTOALLV
(    8)  
(    9) !     The data may be REAL*8,or INTEGER
(   10) 
(   11) !**   Interface.
(   12) !     ----------
(   13) !        CALL MPL_ALLTOALLV
(   14) 
(   15) !        Input required arguments :
(   16) !        -------------------------
(   17) !           PSENDBUF -  buffer containing message
(   18) !                       (can be type  REAL*8 or INTEGER)
(   19) !           PRECVBUF -  buffer containing message
(   20) !                       (can be type REAL*8 or INTEGER)
(   21) !           KRECVCOUNTS-number of elements received from each process
(   22) !           KSENDCOUNTS-number of elements to be sent to each process
(   23) 
(   24) !        Input optional arguments :
(   25) !        -------------------------
(   26) !           KCOMM    -  Communicator number if different from MPI_COMM_WORLD 
(   27) !                       or from that established as the default 
(   28) !                       by an MPL communicator routine
(   29) !           KRECVDISPL -displacements in PRECVBUF at which to place 
(   30) !                       the incoming data
(   31) !           KSENDDISPL -displacements in PSENDBUF from which to send
(   32) !                       the data
(   33) !           KMP_TYPE -  buffering type (see MPL_BUFFER_METHOD)






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 2

(   34) !                       overrides value provided to MPL_BUFFER_METHOD
(   35) !           CDSTRING -  Character string for ABORT messages
(   36) !                       used when KERROR is not provided
(   37) 
(   38) !        Output optional arguments :
(   39) !        -------------------------
(   40) !           KREQUEST -  Communication request
(   41) !                       required when buffering type is non-blocking
(   42) !           KERROR   -  return error code.     If not supplied, 
(   43) !                       MPL_ALLTOALLV aborts when an error is detected.
(   44) 
(   45) !     Author.
(   46) !     -------
(   47) !       Y. Tremolet
(   48) 
(   49) !     Modifications.
(   50) !     --------------
(   51) !       Original: 02-03-21
(   52) !       Modified : 25-09-02 M.Hamrud - generalize
(   53) !      F. Vana  05-Mar-2015  Support for single precision
(   54) ! ------------------------------------------------------------------
(   55) 
(   56) USE PARKIND1  ,ONLY : JPRD, JPIM, JPIB, JPRM
(   57) 
(   58) USE MPL_MPIF
(   59) USE MPL_DATA_MODULE
(   60) USE MPL_MESSAGE_MOD
(   61) USE MPL_STATS_MOD
(   62) USE YOMMPLSTATS
(   63) 
(   64) IMPLICIT NONE
(   65) PRIVATE
(   66) 
(   67) LOGICAL :: LLABORT=.TRUE.
(   68) INTEGER(KIND=JPIM) :: ICOMM,IERROR,IPL_NUMPROC,IRECVCOUNT,ISENDCOUNT,IR,IMP_TYPE
(   69) LOGICAL :: LLSCALAR
(   70) 
(   71) INTERFACE MPL_ALLTOALLV
(   72) MODULE PROCEDURE MPL_ALLTOALLV_REAL8,MPL_ALLTOALLV_INTEGER,MPL_ALLTOALLV_REAL4
(   73) END INTERFACE
(   74) 
(   75) PUBLIC MPL_ALLTOALLV, MPL_ALLTOALLV_REAL8
(   76) 
(   77) CONTAINS
(   78) ! ------------------------------------------------------------------
(   79) 
(   80) SUBROUTINE MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,KISENDDISPL,&
(   81)  & KRECVCOUNTS,KIRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(   82) 
(   83) 
(   84) #ifdef USE_8_BYTE_WORDS
(   85)   USE MPI4TO8, ONLY : &
(   86)     MPI_COMM_SIZE => MPI_COMM_SIZE8
(   87) #endif
(   88) 
(   89) 
(   90) INTEGER(KIND=JPIM),INTENT(IN) :: KRECVCOUNTS(:),KSENDCOUNTS(:)
(   91) INTEGER(KIND=JPIM),INTENT(OUT) :: KISENDDISPL(:),KIRECVDISPL(:)






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 3

(   92) INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KSENDDISPL(:),KRECVDISPL(:),KCOMM,KMP_TYPE
(   93) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
(   94) INTEGER(KIND=JPIM) :: ITID,J
(   95) ITID = OML_MY_THREAD()
(   96) IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
(   97)   & CDMESSAGE='MPL_ALLTOALLV: MPL NOT INITIALISED ',LDABORT=LLABORT)
(   98)  
(   99) IF(PRESENT(KCOMM)) THEN
(  100)   ICOMM=KCOMM
(  101) ELSE
(  102)   ICOMM=MPL_COMM_OML(ITID)
(  103) ENDIF
(  104) 
(  105) IF(PRESENT(KMP_TYPE)) THEN
(  106)   IMP_TYPE=KMP_TYPE
(  107) ELSE
(  108)   IMP_TYPE=MPL_METHOD
(  109) ENDIF
(  110) 
(  111) IF(ICOMM == MPL_COMM_OML(ITID)) THEN
(  112)   IPL_NUMPROC = MPL_NUMPROC
(  113) ELSE
(  114)   CALL MPI_COMM_SIZE(ICOMM,IPL_NUMPROC,IERROR)
(  115) ENDIF
(  116) 
(  117) IF(SIZE(KRECVCOUNTS)  < IPL_NUMPROC) THEN
(  118)   WRITE(MPL_ERRUNIT,*)'MPL_ALLTOALLV: ERROR KRECVCOUNTS dimension=',&
(  119)    & SIZE(KRECVCOUNTS)
(  120)   CALL MPL_MESSAGE(CDMESSAGE=&
(  121)    & 'MPL_ALLTOALLV: ERROR KRECVCOUNTS dimension is wrong',LDABORT=LLABORT)
(  122) ENDIF
(  123) 
(  124) IF(SIZE(KSENDCOUNTS)  < IPL_NUMPROC) THEN
(  125)   WRITE(MPL_ERRUNIT,*)'MPL_ALLTOALLV: ERROR KSENDCOUNTS dimension=',&
(  126)    & SIZE(KSENDCOUNTS)
(  127)   CALL MPL_MESSAGE(CDMESSAGE=&
(  128)    & 'MPL_ALLTOALLV: ERROR KSENDCOUNTS dimension is wrong',LDABORT=LLABORT)
(  129) ENDIF
(  130) 
(  131) IF(PRESENT(KRECVDISPL)) THEN
(  132)   DO J=1,MIN(SIZE(KRECVDISPL),SIZE(KIRECVDISPL))
(  133)     KIRECVDISPL(J) = KRECVDISPL(J)
(  134)   ENDDO
(  135) ELSE
(  136)   KIRECVDISPL(:) = 0
(  137)   IF(LLSCALAR) THEN
(  138)     DO IR=2, IPL_NUMPROC
(  139)       KIRECVDISPL(IR) = KIRECVDISPL(IR-1) + 1
(  140)     ENDDO
(  141)   ELSE
(  142)     DO IR=2, IPL_NUMPROC
(  143)       KIRECVDISPL(IR) = KIRECVDISPL(IR-1) + KRECVCOUNTS(IR-1)
(  144)     ENDDO
(  145)   ENDIF
(  146) ENDIF
(  147) 
(  148) DO IR=1, IPL_NUMPROC
(  149)   IF(KIRECVDISPL(IR) < 0 .OR. KRECVCOUNTS(IR) < 0) THEN






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 4

(  150)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV: RECV.. < 0 ',&
(  151)      & IR,KIRECVDISPL(IR),KRECVCOUNTS(IR)
(  152)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  153)   ENDIF
(  154)   IF(KIRECVDISPL(IR)+KRECVCOUNTS(IR) > IRECVCOUNT) THEN
(  155)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:RECV BUFFER TOO SMALL  ', &
(  156)      & IR,KIRECVDISPL(IR),KRECVCOUNTS(IR),IRECVCOUNT
(  157)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  158)   ENDIF
(  159) ENDDO
(  160) 
(  161) IF(PRESENT(KSENDDISPL)) THEN
(  162)   DO J=1,MIN(SIZE(KSENDDISPL),SIZE(KISENDDISPL))
(  163)     KISENDDISPL(J) = KSENDDISPL(J)
(  164)   ENDDO
(  165) ELSE
(  166)   KISENDDISPL(:) = 0
(  167)   IF(LLSCALAR) THEN
(  168)     DO IR=2, IPL_NUMPROC
(  169)       KISENDDISPL(IR) = KISENDDISPL(IR-1) + 1
(  170)     ENDDO
(  171)   ELSE
(  172)     DO IR=2, IPL_NUMPROC
(  173)       KISENDDISPL(IR) = KISENDDISPL(IR-1) + KSENDCOUNTS(IR-1)
(  174)     ENDDO
(  175)   ENDIF
(  176) ENDIF
(  177) DO IR=1, IPL_NUMPROC
(  178)   IF(KISENDDISPL(IR) < 0 .OR. KSENDCOUNTS(IR) < 0) THEN
(  179)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:SEND.. <0 ',&
(  180)      & IR,KISENDDISPL(IR),KSENDCOUNTS(IR)
(  181)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  182)   ENDIF
(  183)   IF(KISENDDISPL(IR)+KSENDCOUNTS(IR) > ISENDCOUNT) THEN
(  184)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:SEND BUFFER TOO SMALL  ', &
(  185)      & IR,KISENDDISPL(IR),KSENDCOUNTS(IR),ISENDCOUNT
(  186)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  187)   ENDIF
(  188) ENDDO
(  189) 
(  190) END SUBROUTINE MPL_ALLTOALLV_PREAMB
(  191) 
(  192) SUBROUTINE MPL_ALLTOALLV_REAL8(PSENDBUF,KSENDCOUNTS,PRECVBUF,KRECVCOUNTS,&
(  193)  &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)
(  194) 
(  195) 
(  196) #ifdef USE_8_BYTE_WORDS
(  197)   USE MPI4TO8, ONLY : &
(  198)     MPI_ALLTOALLV => MPI_ALLTOALLV8
(  199) #endif
(  200) 
(  201) 
(  202) IMPLICIT NONE
(  203) INTEGER(KIND=JPIM), INTENT(IN) :: KSENDCOUNTS(:), KRECVCOUNTS(:)
(  204) REAL(KIND=JPRD), INTENT(IN)  :: PSENDBUF(:)
(  205) REAL(KIND=JPRD), INTENT(OUT) :: PRECVBUF(:)
(  206) INTEGER(KIND=JPIM), INTENT(IN),OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM ,KMP_TYPE
(  207) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 5

(  208) INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR
(  209) 
(  210) INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
(  211) 
(  212) ISENDCOUNT=SIZE(PSENDBUF)
(  213) IRECVCOUNT=SIZE(PRECVBUF)
(  214) 
(  215) #ifndef NAG
(  216) IF (ISENDCOUNT > 0) THEN
(  217)   IF( (LOC(PSENDBUF(UBOUND(PSENDBUF,1))) - LOC(PSENDBUF(LBOUND(PSENDBUF,1)))) /= 8_JPIB*(ISENDCOUNT - 1) .AND. &
(  218)     & ISENDCOUNT > 0 ) THEN
(  219)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  220)   ENDIF
(  221) ENDIF
(  222) 
(  223) IF (IRECVCOUNT > 0) THEN
(  224)   IF( (LOC(PRECVBUF(UBOUND(PRECVBUF,1))) - LOC(PRECVBUF(LBOUND(PRECVBUF,1)))) /= 8_JPIB*(IRECVCOUNT - 1) .AND. &
(  225)     & IRECVCOUNT > 0 ) THEN
(  226)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  227)   ENDIF
(  228) ENDIF
(  229) #endif
(  230) 
(  231) LLSCALAR=.FALSE.
(  232) 
(  233) IERROR=0
(  234) CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,&
(  235)  & KRECVCOUNTS,IRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(  236) IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
(  237)   CALL MPI_ALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL8), &
(  238)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL8),ICOMM,IERROR)
(  239) ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
(  240)   IF(.NOT.PRESENT(KREQUEST)) CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' KREQUEST MISSING',LDABORT=LLABORT)
(  241)   CALL MPI_IALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL8), &
(  242)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL8),ICOMM,KREQUEST,IERROR)
(  243) ELSE
(  244)   IF(PRESENT(KERROR)) THEN
(  245)     IERROR=1
(  246)   ELSE
(  247)     CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' INVALID METHOD',LDABORT=LLABORT)
(  248)   ENDIF
(  249) ENDIF
(  250) 
(  251) IF(PRESENT(KERROR)) THEN
(  252)   KERROR=IERROR
(  253) ELSE
(  254)   IF (IERROR/=0) CALL MPL_MESSAGE(IERROR,'ERROR IN MPL_ALLTOALLV',&
(  255)    &LDABORT=LLABORT)
(  256) ENDIF
(  257) 
(  258) IF(LMPLSTATS) THEN
(  259)   CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),INT(MPI_REAL8))
(  260)   CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),INT(MPI_REAL8))
(  261) ENDIF
(  262) 
(  263) END SUBROUTINE MPL_ALLTOALLV_REAL8
(  264) 
(  265) SUBROUTINE MPL_ALLTOALLV_REAL4(PSENDBUF,KSENDCOUNTS,PRECVBUF,KRECVCOUNTS,&






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 6

(  266)  &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)
(  267) 
(  268) 
(  269) #ifdef USE_8_BYTE_WORDS
(  270)   USE MPI4TO8, ONLY : &
(  271)     MPI_ALLTOALLV => MPI_ALLTOALLV8
(  272) #endif
(  273) 
(  274) 
(  275) IMPLICIT NONE
(  276) INTEGER(KIND=JPIM), INTENT(IN) :: KSENDCOUNTS(:), KRECVCOUNTS(:)
(  277) REAL(KIND=JPRM), INTENT(IN)  :: PSENDBUF(:)
(  278) REAL(KIND=JPRM), INTENT(OUT) :: PRECVBUF(:)
(  279) INTEGER(KIND=JPIM), INTENT(IN),OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM  ,KMP_TYPE
(  280) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
(  281) INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR
(  282) 
(  283) INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
(  284) 
(  285) ISENDCOUNT=SIZE(PSENDBUF)
(  286) IRECVCOUNT=SIZE(PRECVBUF)
(  287) 
(  288) #ifndef NAG
(  289) IF (ISENDCOUNT > 0) THEN
(  290)   IF( (LOC(PSENDBUF(UBOUND(PSENDBUF,1))) - LOC(PSENDBUF(LBOUND(PSENDBUF,1)))) /= 4_JPIB*(ISENDCOUNT - 1) ) THEN
(  291)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  292)   ENDIF
(  293) ENDIF
(  294) 
(  295) IF (IRECVCOUNT > 0) THEN
(  296)   IF( (LOC(PRECVBUF(UBOUND(PRECVBUF,1))) - LOC(PRECVBUF(LBOUND(PRECVBUF,1)))) /= 4_JPIB*(IRECVCOUNT - 1) ) THEN
(  297)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  298)   ENDIF
(  299) ENDIF
(  300) #endif
(  301) 
(  302) LLSCALAR=.FALSE.
(  303) 
(  304) IERROR=0
(  305) CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,&
(  306)  & KRECVCOUNTS,IRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(  307) IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
(  308)   CALL MPI_ALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL4), &
(  309)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL4),ICOMM,IERROR)
(  310) ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
(  311)   CALL MPI_IALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL4), &
(  312)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL4),ICOMM,KREQUEST,IERROR)
(  313) ELSE
(  314)   IF(PRESENT(KERROR)) THEN
(  315)     IERROR=1
(  316)   ELSE
(  317)     CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' INVALID METHOD',LDABORT=LLABORT)
(  318)   ENDIF
(  319) ENDIF
(  320) 
(  321) IF(PRESENT(KERROR)) THEN
(  322)   KERROR=IERROR
(  323) ELSE






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 7

(  324)   IF (IERROR/=0) CALL MPL_MESSAGE(IERROR,'ERROR IN MPL_ALLTOALLV',&
(  325)    &LDABORT=LLABORT)
(  326) ENDIF
(  327) 
(  328) IF(LMPLSTATS) THEN
(  329)   CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),INT(MPI_REAL4))
(  330)   CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),INT(MPI_REAL4))
(  331) ENDIF
(  332) 
(  333) END SUBROUTINE MPL_ALLTOALLV_REAL4
(  334) 
(  335) 
(  336) SUBROUTINE MPL_ALLTOALLV_INTEGER(KSENDBUF,KSENDCOUNTS,KRECVBUF,KRECVCOUNTS,&
(  337)  &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)
(  338) 
(  339) 
(  340) #ifdef USE_8_BYTE_WORDS
(  341)   USE MPI4TO8, ONLY : &
(  342)     MPI_ALLTOALLV => MPI_ALLTOALLV8
(  343) #endif
(  344) 
(  345) 
(  346) IMPLICIT NONE
(  347) INTEGER(KIND=JPIM), INTENT(IN) :: KSENDCOUNTS(:), KRECVCOUNTS(:)
(  348) INTEGER(KIND=JPIM), INTENT(IN)  :: KSENDBUF(:)
(  349) INTEGER(KIND=JPIM), INTENT(OUT) :: KRECVBUF(:)
(  350) INTEGER(KIND=JPIM), INTENT(IN),OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM,KMP_TYPE 
(  351) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
(  352) INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR
(  353) 
(  354) INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
(  355) 
(  356) ISENDCOUNT=SIZE(KSENDBUF)
(  357) IRECVCOUNT=SIZE(KRECVBUF)
(  358) 
(  359) #ifndef NAG
(  360) IF (ISENDCOUNT > 0) THEN
(  361)   IF( (LOC(KSENDBUF(UBOUND(KSENDBUF,1))) - LOC(KSENDBUF(LBOUND(KSENDBUF,1)))) /= 4_JPIB*(ISENDCOUNT - 1) ) THEN
(  362)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  363)   ENDIF
(  364) ENDIF
(  365) 
(  366) IF (IRECVCOUNT > 0) THEN
(  367)   IF( (LOC(KRECVBUF(UBOUND(KRECVBUF,1))) - LOC(KRECVBUF(LBOUND(KRECVBUF,1)))) /= 4_JPIB*(IRECVCOUNT - 1) ) THEN
(  368)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  369)   ENDIF
(  370) ENDIF
(  371) #endif
(  372) 
(  373) LLSCALAR=.FALSE.
(  374) 
(  375) IERROR=0
(  376) CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,&
(  377)  & KRECVCOUNTS,IRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(  378) IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
(  379)   CALL MPI_ALLTOALLV(KSENDBUF(1),KSENDCOUNTS,ISENDDISPL,INT(MPI_INTEGER), &
(  380)    & KRECVBUF(1),KRECVCOUNTS,IRECVDISPL,INT(MPI_INTEGER),ICOMM,IERROR)
(  381) ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 8

(  382)   IF(.NOT.PRESENT(KREQUEST)) CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' KREQUEST MISSING',LDABORT=LLABORT)
(  383)   CALL MPI_IALLTOALLV(KSENDBUF(1),KSENDCOUNTS,ISENDDISPL,INT(MPI_INTEGER), &
(  384)    & KRECVBUF(1),KRECVCOUNTS,IRECVDISPL,INT(MPI_INTEGER),ICOMM,KREQUEST,IERROR)
(  385) ELSE
(  386)   IF(PRESENT(KERROR)) THEN
(  387)     IERROR=1
(  388)   ELSE
(  389)     CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' INVALID METHOD',LDABORT=LLABORT)
(  390)   ENDIF
(  391) ENDIF
(  392) 
(  393) IF(PRESENT(KERROR)) THEN
(  394)   KERROR=IERROR
(  395) ELSE
(  396)   IF (IERROR/=0) CALL MPL_MESSAGE(IERROR,'ERROR IN MPL_ALLTOALLV',&
(  397)    &LDABORT=LLABORT)
(  398) ENDIF
(  399) 
(  400) IF(LMPLSTATS) THEN
(  401)   CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),INT(MPI_INTEGER))
(  402)   CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),INT(MPI_INTEGER))
(  403) ENDIF
(  404) 
(  405) END SUBROUTINE MPL_ALLTOALLV_INTEGER
(  406) 
(  407) ! ------------------------------------------------------------------
(  408) 
(  409) END MODULE MPL_ALLTOALLV_MOD
(  410) 
(  411) 


































NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 9

(    1) # 1 "mpl_alltoallv_mod.F90"
(    1) MODULE MPL_ALLTOALLV_MOD
(    2) # 3 "mpl_alltoallv_mod.F90"
(    3) !**** MPL_ALLTOALLV - Everyone sends different data to everyone
(    4) # 5 "mpl_alltoallv_mod.F90"
(    5) !     Purpose.
(    6) !     --------
(    7) !     Interface to MPI_ALLTOALLV
(    8)  
(    9) !     The data may be REAL*8,or INTEGER
(   10) # 11 "mpl_alltoallv_mod.F90"
(   11) !**   Interface.
(   12) !     ----------
(   13) !        CALL MPL_ALLTOALLV
(   14) # 15 "mpl_alltoallv_mod.F90"
(   15) !        Input required arguments :
(   16) !        -------------------------
(   17) !           PSENDBUF -  buffer containing message
(   18) !                       (can be type  REAL*8 or INTEGER)
(   19) !           PRECVBUF -  buffer containing message
(   20) !                       (can be type REAL*8 or INTEGER)
(   21) !           KRECVCOUNTS-number of elements received from each process
(   22) !           KSENDCOUNTS-number of elements to be sent to each process
(   23) # 24 "mpl_alltoallv_mod.F90"
(   24) !        Input optional arguments :
(   25) !        -------------------------
(   26) !           KCOMM    -  Communicator number if different from MPI_COMM_WORLD 
(   27) !                       or from that established as the default 
(   28) !                       by an MPL communicator routine
(   29) !           KRECVDISPL -displacements in PRECVBUF at which to place 
(   30) !                       the incoming data
(   31) !           KSENDDISPL -displacements in PSENDBUF from which to send
(   32) !                       the data
(   33) !           KMP_TYPE -  buffering type (see MPL_BUFFER_METHOD)
(   34) !                       overrides value provided to MPL_BUFFER_METHOD
(   35) !           CDSTRING -  Character string for ABORT messages
(   36) !                       used when KERROR is not provided
(   37) # 38 "mpl_alltoallv_mod.F90"
(   38) !        Output optional arguments :
(   39) !        -------------------------
(   40) !           KREQUEST -  Communication request
(   41) !                       required when buffering type is non-blocking
(   42) !           KERROR   -  return error code.     If not supplied, 
(   43) !                       MPL_ALLTOALLV aborts when an error is detected.
(   44) # 45 "mpl_alltoallv_mod.F90"
(   45) !     Author.
(   46) !     -------
(   47) !       Y. Tremolet
(   48) # 49 "mpl_alltoallv_mod.F90"
(   49) !     Modifications.
(   50) !     --------------
(   51) !       Original: 02-03-21
(   52) !       Modified : 25-09-02 M.Hamrud - generalize
(   53) !      F. Vana  05-Mar-2015  Support for single precision
(   54) ! ------------------------------------------------------------------
(   55) # 56 "mpl_alltoallv_mod.F90"
(   56) USE PARKIND1  ,ONLY : JPRD, JPIM, JPIB, JPRM
(   57) # 58 "mpl_alltoallv_mod.F90"






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 10

(   58) USE MPL_MPIF
(   59) USE MPL_DATA_MODULE
(   60) USE MPL_MESSAGE_MOD
(   61) USE MPL_STATS_MOD
(   62) USE YOMMPLSTATS
(   63) # 64 "mpl_alltoallv_mod.F90"
(   64) IMPLICIT NONE
(   65) PRIVATE
(   66) # 67 "mpl_alltoallv_mod.F90"
(   67) LOGICAL :: LLABORT=.TRUE.
(   68) INTEGER(KIND=JPIM) :: ICOMM,IERROR,IPL_NUMPROC,IRECVCOUNT,ISENDCOUNT,IR,IMP_TYPE
(   69) LOGICAL :: LLSCALAR
(   70) # 71 "mpl_alltoallv_mod.F90"
(   71) INTERFACE MPL_ALLTOALLV
(   72) MODULE PROCEDURE MPL_ALLTOALLV_REAL8,MPL_ALLTOALLV_INTEGER,MPL_ALLTOALLV_REAL4
(   73) END INTERFACE
(   74) # 75 "mpl_alltoallv_mod.F90"
(   75) PUBLIC MPL_ALLTOALLV, MPL_ALLTOALLV_REAL8
(   76) # 77 "mpl_alltoallv_mod.F90"
(   77) CONTAINS
(   78) ! ------------------------------------------------------------------
(   79) # 80 "mpl_alltoallv_mod.F90"
(   80) SUBROUTINE MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,KISENDDISPL,&
(   81)  & KRECVCOUNTS,KIRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(   82) # 90 "mpl_alltoallv_mod.F90"
(   90) INTEGER(KIND=JPIM),INTENT(IN) :: KRECVCOUNTS(:),KSENDCOUNTS(:)
(   91) INTEGER(KIND=JPIM),INTENT(OUT) :: KISENDDISPL(:),KIRECVDISPL(:)
(   92) INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KSENDDISPL(:),KRECVDISPL(:),KCOMM,KMP_TYPE
(   93) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
(   94) INTEGER(KIND=JPIM) :: ITID,J
(   95) ITID = OML_MY_THREAD()
(   96) IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
(   97)   & CDMESSAGE='MPL_ALLTOALLV: MPL NOT INITIALISED ',LDABORT=LLABORT)
(   98)  
(   99) IF(PRESENT(KCOMM)) THEN
(  100)   ICOMM=KCOMM
(  101) ELSE
(  102)   ICOMM=MPL_COMM_OML(ITID)
(  103) ENDIF
(  104) # 105 "mpl_alltoallv_mod.F90"
(  105) IF(PRESENT(KMP_TYPE)) THEN
(  106)   IMP_TYPE=KMP_TYPE
(  107) ELSE
(  108)   IMP_TYPE=MPL_METHOD
(  109) ENDIF
(  110) # 111 "mpl_alltoallv_mod.F90"
(  111) IF(ICOMM == MPL_COMM_OML(ITID)) THEN
(  112)   IPL_NUMPROC = MPL_NUMPROC
(  113) ELSE
(  114)   CALL MPI_COMM_SIZE(ICOMM,IPL_NUMPROC,IERROR)
(  115) ENDIF
(  116) # 117 "mpl_alltoallv_mod.F90"
(  117) IF(SIZE(KRECVCOUNTS)  < IPL_NUMPROC) THEN
(  118)   WRITE(MPL_ERRUNIT,*)'MPL_ALLTOALLV: ERROR KRECVCOUNTS dimension=',&
(  119)    & SIZE(KRECVCOUNTS)
(  120)   CALL MPL_MESSAGE(CDMESSAGE=&
(  121)    & 'MPL_ALLTOALLV: ERROR KRECVCOUNTS dimension is wrong',LDABORT=LLABORT)
(  122) ENDIF






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 11

(  123) # 124 "mpl_alltoallv_mod.F90"
(  124) IF(SIZE(KSENDCOUNTS)  < IPL_NUMPROC) THEN
(  125)   WRITE(MPL_ERRUNIT,*)'MPL_ALLTOALLV: ERROR KSENDCOUNTS dimension=',&
(  126)    & SIZE(KSENDCOUNTS)
(  127)   CALL MPL_MESSAGE(CDMESSAGE=&
(  128)    & 'MPL_ALLTOALLV: ERROR KSENDCOUNTS dimension is wrong',LDABORT=LLABORT)
(  129) ENDIF
(  130) # 131 "mpl_alltoallv_mod.F90"
(  131) IF(PRESENT(KRECVDISPL)) THEN
(  132)   DO J=1,MIN(SIZE(KRECVDISPL),SIZE(KIRECVDISPL))
(  133)     KIRECVDISPL(J) = KRECVDISPL(J)
(  134)   ENDDO
(  135) ELSE
(  136)   KIRECVDISPL(:) = 0
(  137)   IF(LLSCALAR) THEN
(  138)     DO IR=2, IPL_NUMPROC
(  139)       KIRECVDISPL(IR) = KIRECVDISPL(IR-1) + 1
(  140)     ENDDO
(  141)   ELSE
(  142)     DO IR=2, IPL_NUMPROC
(  143)       KIRECVDISPL(IR) = KIRECVDISPL(IR-1) + KRECVCOUNTS(IR-1)
(  144)     ENDDO
(  145)   ENDIF
(  146) ENDIF
(  147) # 148 "mpl_alltoallv_mod.F90"
(  148) DO IR=1, IPL_NUMPROC
(  149)   IF(KIRECVDISPL(IR) < 0 .OR. KRECVCOUNTS(IR) < 0) THEN
(  150)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV: RECV.. < 0 ',&
(  151)      & IR,KIRECVDISPL(IR),KRECVCOUNTS(IR)
(  152)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  153)   ENDIF
(  154)   IF(KIRECVDISPL(IR)+KRECVCOUNTS(IR) > IRECVCOUNT) THEN
(  155)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:RECV BUFFER TOO SMALL  ', &
(  156)      & IR,KIRECVDISPL(IR),KRECVCOUNTS(IR),IRECVCOUNT
(  157)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  158)   ENDIF
(  159) ENDDO
(  160) # 161 "mpl_alltoallv_mod.F90"
(  161) IF(PRESENT(KSENDDISPL)) THEN
(  162)   DO J=1,MIN(SIZE(KSENDDISPL),SIZE(KISENDDISPL))
(  163)     KISENDDISPL(J) = KSENDDISPL(J)
(  164)   ENDDO
(  165) ELSE
(  166)   KISENDDISPL(:) = 0
(  167)   IF(LLSCALAR) THEN
(  168)     DO IR=2, IPL_NUMPROC
(  169)       KISENDDISPL(IR) = KISENDDISPL(IR-1) + 1
(  170)     ENDDO
(  171)   ELSE
(  172)     DO IR=2, IPL_NUMPROC
(  173)       KISENDDISPL(IR) = KISENDDISPL(IR-1) + KSENDCOUNTS(IR-1)
(  174)     ENDDO
(  175)   ENDIF
(  176) ENDIF
(  177) DO IR=1, IPL_NUMPROC
(  178)   IF(KISENDDISPL(IR) < 0 .OR. KSENDCOUNTS(IR) < 0) THEN
(  179)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:SEND.. <0 ',&
(  180)      & IR,KISENDDISPL(IR),KSENDCOUNTS(IR)






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 12

(  181)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  182)   ENDIF
(  183)   IF(KISENDDISPL(IR)+KSENDCOUNTS(IR) > ISENDCOUNT) THEN
(  184)     WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:SEND BUFFER TOO SMALL  ', &
(  185)      & IR,KISENDDISPL(IR),KSENDCOUNTS(IR),ISENDCOUNT
(  186)     CALL MPL_MESSAGE(IERROR,'MPL_ALLTOALLV',CDSTRING,LDABORT=LLABORT)
(  187)   ENDIF
(  188) ENDDO
(  189) # 190 "mpl_alltoallv_mod.F90"
(  190) END SUBROUTINE MPL_ALLTOALLV_PREAMB
(  191) # 192 "mpl_alltoallv_mod.F90"
(  192) SUBROUTINE MPL_ALLTOALLV_REAL8(PSENDBUF,KSENDCOUNTS,PRECVBUF,KRECVCOUNTS,&
(  193)  &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)
(  194) # 202 "mpl_alltoallv_mod.F90"
(  202) IMPLICIT NONE
(  203) INTEGER(KIND=JPIM), INTENT(IN) :: KSENDCOUNTS(:), KRECVCOUNTS(:)
(  204) REAL(KIND=JPRD), INTENT(IN)  :: PSENDBUF(:)
(  205) REAL(KIND=JPRD), INTENT(OUT) :: PRECVBUF(:)
(  206) INTEGER(KIND=JPIM), INTENT(IN),OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM ,KMP_TYPE
(  207) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
(  208) INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR
(  209) # 210 "mpl_alltoallv_mod.F90"
(  210) INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
(  211) # 212 "mpl_alltoallv_mod.F90"
(  212) ISENDCOUNT=SIZE(PSENDBUF)
(  213) IRECVCOUNT=SIZE(PRECVBUF)
(  214) # 216 "mpl_alltoallv_mod.F90"
(  216) IF (ISENDCOUNT > 0) THEN
(  217)   IF( (LOC(PSENDBUF(UBOUND(PSENDBUF,1))) - LOC(PSENDBUF(LBOUND(PSENDBUF,1)))) /= 8_JPIB*(ISENDCOUNT - 1) .AND. &
(  218)     & ISENDCOUNT > 0 ) THEN
(  219)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  220)   ENDIF
(  221) ENDIF
(  222) # 223 "mpl_alltoallv_mod.F90"
(  223) IF (IRECVCOUNT > 0) THEN
(  224)   IF( (LOC(PRECVBUF(UBOUND(PRECVBUF,1))) - LOC(PRECVBUF(LBOUND(PRECVBUF,1)))) /= 8_JPIB*(IRECVCOUNT - 1) .AND. &
(  225)     & IRECVCOUNT > 0 ) THEN
(  226)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  227)   ENDIF
(  228) ENDIF
(  229) # 231 "mpl_alltoallv_mod.F90"
(  231) LLSCALAR=.FALSE.
(  232) # 233 "mpl_alltoallv_mod.F90"
(  233) IERROR=0
(  234) CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,&
(  235)  & KRECVCOUNTS,IRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(  236) IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
(  237)   CALL MPI_ALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL8), &
(  238)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL8),ICOMM,IERROR)
(  239) ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
(  240)   IF(.NOT.PRESENT(KREQUEST)) CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' KREQUEST MISSING',LDABORT=LLABORT)
(  241)   CALL MPI_IALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL8), &
(  242)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL8),ICOMM,KREQUEST,IERROR)
(  243) ELSE
(  244)   IF(PRESENT(KERROR)) THEN
(  245)     IERROR=1
(  246)   ELSE
(  247)     CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' INVALID METHOD',LDABORT=LLABORT)






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 13

(  248)   ENDIF
(  249) ENDIF
(  250) # 251 "mpl_alltoallv_mod.F90"
(  251) IF(PRESENT(KERROR)) THEN
(  252)   KERROR=IERROR
(  253) ELSE
(  254)   IF (IERROR/=0) CALL MPL_MESSAGE(IERROR,'ERROR IN MPL_ALLTOALLV',&
(  255)    &LDABORT=LLABORT)
(  256) ENDIF
(  257) # 258 "mpl_alltoallv_mod.F90"
(  258) IF(LMPLSTATS) THEN
(  259)   CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),INT(MPI_REAL8))
(  260)   CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),INT(MPI_REAL8))
(  261) ENDIF
(  262) # 263 "mpl_alltoallv_mod.F90"
(  263) END SUBROUTINE MPL_ALLTOALLV_REAL8
(  264) # 265 "mpl_alltoallv_mod.F90"
(  265) SUBROUTINE MPL_ALLTOALLV_REAL4(PSENDBUF,KSENDCOUNTS,PRECVBUF,KRECVCOUNTS,&
(  266)  &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)
(  267) # 275 "mpl_alltoallv_mod.F90"
(  275) IMPLICIT NONE
(  276) INTEGER(KIND=JPIM), INTENT(IN) :: KSENDCOUNTS(:), KRECVCOUNTS(:)
(  277) REAL(KIND=JPRM), INTENT(IN)  :: PSENDBUF(:)
(  278) REAL(KIND=JPRM), INTENT(OUT) :: PRECVBUF(:)
(  279) INTEGER(KIND=JPIM), INTENT(IN),OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM  ,KMP_TYPE
(  280) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
(  281) INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR
(  282) # 283 "mpl_alltoallv_mod.F90"
(  283) INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
(  284) # 285 "mpl_alltoallv_mod.F90"
(  285) ISENDCOUNT=SIZE(PSENDBUF)
(  286) IRECVCOUNT=SIZE(PRECVBUF)
(  287) # 289 "mpl_alltoallv_mod.F90"
(  289) IF (ISENDCOUNT > 0) THEN
(  290)   IF( (LOC(PSENDBUF(UBOUND(PSENDBUF,1))) - LOC(PSENDBUF(LBOUND(PSENDBUF,1)))) /= 4_JPIB*(ISENDCOUNT - 1) ) THEN
(  291)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  292)   ENDIF
(  293) ENDIF
(  294) # 295 "mpl_alltoallv_mod.F90"
(  295) IF (IRECVCOUNT > 0) THEN
(  296)   IF( (LOC(PRECVBUF(UBOUND(PRECVBUF,1))) - LOC(PRECVBUF(LBOUND(PRECVBUF,1)))) /= 4_JPIB*(IRECVCOUNT - 1) ) THEN
(  297)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  298)   ENDIF
(  299) ENDIF
(  300) # 302 "mpl_alltoallv_mod.F90"
(  302) LLSCALAR=.FALSE.
(  303) # 304 "mpl_alltoallv_mod.F90"
(  304) IERROR=0
(  305) CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,&
(  306)  & KRECVCOUNTS,IRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(  307) IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
(  308)   CALL MPI_ALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL4), &
(  309)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL4),ICOMM,IERROR)
(  310) ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
(  311)   CALL MPI_IALLTOALLV(PSENDBUF(:),KSENDCOUNTS,ISENDDISPL,INT(MPI_REAL4), &
(  312)    & PRECVBUF(:),KRECVCOUNTS,IRECVDISPL,INT(MPI_REAL4),ICOMM,KREQUEST,IERROR)
(  313) ELSE
(  314)   IF(PRESENT(KERROR)) THEN






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 14

(  315)     IERROR=1
(  316)   ELSE
(  317)     CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' INVALID METHOD',LDABORT=LLABORT)
(  318)   ENDIF
(  319) ENDIF
(  320) # 321 "mpl_alltoallv_mod.F90"
(  321) IF(PRESENT(KERROR)) THEN
(  322)   KERROR=IERROR
(  323) ELSE
(  324)   IF (IERROR/=0) CALL MPL_MESSAGE(IERROR,'ERROR IN MPL_ALLTOALLV',&
(  325)    &LDABORT=LLABORT)
(  326) ENDIF
(  327) # 328 "mpl_alltoallv_mod.F90"
(  328) IF(LMPLSTATS) THEN
(  329)   CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),INT(MPI_REAL4))
(  330)   CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),INT(MPI_REAL4))
(  331) ENDIF
(  332) # 333 "mpl_alltoallv_mod.F90"
(  333) END SUBROUTINE MPL_ALLTOALLV_REAL4
(  334) # 336 "mpl_alltoallv_mod.F90"
(  336) SUBROUTINE MPL_ALLTOALLV_INTEGER(KSENDBUF,KSENDCOUNTS,KRECVBUF,KRECVCOUNTS,&
(  337)  &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)
(  338) # 346 "mpl_alltoallv_mod.F90"
(  346) IMPLICIT NONE
(  347) INTEGER(KIND=JPIM), INTENT(IN) :: KSENDCOUNTS(:), KRECVCOUNTS(:)
(  348) INTEGER(KIND=JPIM), INTENT(IN)  :: KSENDBUF(:)
(  349) INTEGER(KIND=JPIM), INTENT(OUT) :: KRECVBUF(:)
(  350) INTEGER(KIND=JPIM), INTENT(IN),OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM,KMP_TYPE 
(  351) CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
(  352) INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR
(  353) # 354 "mpl_alltoallv_mod.F90"
(  354) INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
(  355) # 356 "mpl_alltoallv_mod.F90"
(  356) ISENDCOUNT=SIZE(KSENDBUF)
(  357) IRECVCOUNT=SIZE(KRECVBUF)
(  358) # 360 "mpl_alltoallv_mod.F90"
(  360) IF (ISENDCOUNT > 0) THEN
(  361)   IF( (LOC(KSENDBUF(UBOUND(KSENDBUF,1))) - LOC(KSENDBUF(LBOUND(KSENDBUF,1)))) /= 4_JPIB*(ISENDCOUNT - 1) ) THEN
(  362)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  363)   ENDIF
(  364) ENDIF
(  365) # 366 "mpl_alltoallv_mod.F90"
(  366) IF (IRECVCOUNT > 0) THEN
(  367)   IF( (LOC(KRECVBUF(UBOUND(KRECVBUF,1))) - LOC(KRECVBUF(LBOUND(KRECVBUF,1)))) /= 4_JPIB*(IRECVCOUNT - 1) ) THEN
(  368)     CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
(  369)   ENDIF
(  370) ENDIF
(  371) # 373 "mpl_alltoallv_mod.F90"
(  373) LLSCALAR=.FALSE.
(  374) # 375 "mpl_alltoallv_mod.F90"
(  375) IERROR=0
(  376) CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,&
(  377)  & KRECVCOUNTS,IRECVDISPL,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,CDSTRING)
(  378) IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
(  379)   CALL MPI_ALLTOALLV(KSENDBUF(1),KSENDCOUNTS,ISENDDISPL,INT(MPI_INTEGER), &
(  380)    & KRECVBUF(1),KRECVCOUNTS,IRECVDISPL,INT(MPI_INTEGER),ICOMM,IERROR)
(  381) ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
(  382)   IF(.NOT.PRESENT(KREQUEST)) CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' KREQUEST MISSING',LDABORT=LLABORT)






NVFORTRAN (Version    20.11)          02/16/2022  17:27:46      page 15

(  383)   CALL MPI_IALLTOALLV(KSENDBUF(1),KSENDCOUNTS,ISENDDISPL,INT(MPI_INTEGER), &
(  384)    & KRECVBUF(1),KRECVCOUNTS,IRECVDISPL,INT(MPI_INTEGER),ICOMM,KREQUEST,IERROR)
(  385) ELSE
(  386)   IF(PRESENT(KERROR)) THEN
(  387)     IERROR=1
(  388)   ELSE
(  389)     CALL MPL_MESSAGE(KERROR,'MPL_ALLTOALLV',' INVALID METHOD',LDABORT=LLABORT)
(  390)   ENDIF
(  391) ENDIF
(  392) # 393 "mpl_alltoallv_mod.F90"
(  393) IF(PRESENT(KERROR)) THEN
(  394)   KERROR=IERROR
(  395) ELSE
(  396)   IF (IERROR/=0) CALL MPL_MESSAGE(IERROR,'ERROR IN MPL_ALLTOALLV',&
(  397)    &LDABORT=LLABORT)
(  398) ENDIF
(  399) # 400 "mpl_alltoallv_mod.F90"
(  400) IF(LMPLSTATS) THEN
(  401)   CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),INT(MPI_INTEGER))
(  402)   CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),INT(MPI_INTEGER))
(  403) ENDIF
(  404) # 405 "mpl_alltoallv_mod.F90"
(  405) END SUBROUTINE MPL_ALLTOALLV_INTEGER
(  406) # 407 "mpl_alltoallv_mod.F90"
(  407) ! ------------------------------------------------------------------
(  408) # 409 "mpl_alltoallv_mod.F90"
(  409) END MODULE MPL_ALLTOALLV_MOD
