


NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/include
          -idir /gpfslocalsup/spack_soft/openmpi/4.0.5/nvhpc-20.11-3li3t3xykfzndqfr4oxyhh22iqiendl2/lib
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: ecsort_mix.F90

(    1) #ifdef RS6K
(    2) @PROCESS NOCHECK
(    3) #endif
(    4) MODULE ECSORT_MIX
(    5) USE PARKIND1   , ONLY : JPIM     ,JPIB     ,JPRB     ,JPRM    ,JPRD
(    6) USE YOMHOOK    , ONLY : LHOOK, DR_HOOK
(    7) USE OML_MOD     , ONLY : OML_MAX_THREADS, OML_MY_THREAD, OML_IN_PARALLEL
(    8) USE STRHANDLER_MOD , ONLY : TOUPPER
(    9) USE MPL_MODULE , ONLY : MPL_MYRANK, MPL_NPROC
(   10) 
(   11) !$
(   12) !..   Author: Sami Saarinen, ECMWF, 10/02/98
(   13) !     Fixes : Sami Saarinen, ECMWF, 08/11/99 : Sub-arrays go now correctly (look for addrdiff)
(   14) !                                              Genuine real(4) sort "re-habilitated"
(   15) !                                              sizeof_int, _real4 & _real8 HARDCODED !
(   16) !             Sami Saarinen, ECMWF, 11/10/00 : REAL*4 version included (REAL_M)
(   17) !             Sami Saarinen, ECMWF, 28/11/03 : Calls to DR_HOOK added manually (on top of CY28)
(   18) !             Sami Saarinen, ECMWF, 18/02/05 : 64-bit integer sorting introduced (for CY30)
(   19) !             Sami Saarinen, ECMWF, 22/02/05 : Using genuine 64-bit rsort64() => one-pass through data
(   20) !             Sami Saarinen, ECMWF, 06/07/05 : "current_method" made OpenMP-thread aware (for max. # of threads = NTHRDS)
(   21) !             Sami Saarinen, ECMWF, 07/07/05 : Quick-sort method finally arrived (and applicable to multikeys, too)
(   22) !                                              Quick-sort the default for scalar machines ("non-VPP"), VPPs is radix-sort
(   23) !             Sami Saarinen, ECMWF, 03/07/07 : Quick-sort method uses stable approach (was not guaranteed so before)
(   24) !             Sami Saarinen, ECMWF, 15/10/07 : Subroutines put into a common file ../include/ecsort_shared.h and
(   25) !                                              preprocessed from there
(   26) !             Sami Saarinen, ECMWF, 15/10/07 : NTHRDS increased from 32 to 64
(   27) !             Sami Saarinen, ECMWF, 16/10/07 : The default sorting method can be overriden via export EC_SORTING_METHOD=[<nu
(   28) !             Sami Saarinen, ECMWF, 30/10/07 : Support for CountingSort added as part of QuickSort speedup
(   29) !             Sami Saarinen, ECMWF, 31/10/07 : CALL SORTING_METHOD() now prints the prevailing method from EC_SORTING_METHOD
(   30) !             Sami Saarinen, ECMWF, 01/11/07 : CountingSort implemented as independent method
(   31) !             Sami Saarinen, ECMWF, 06/11/07 : index_adj added as an optional argument to init_index ; new routine adjust_in
(   32) !             Sami Saarinen, ECMWF, 07/11/07 : threshold length "nomp" (see below). Override with EC_SORTING_NOMP.
(   33) !             Sami Saarinen, ECMWF, 12/11/07 : Gnome-sort -- the easiest sort on Earth (and very slow for large arrays)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 2

(   34) !             Sami Saarinen, ECMWF, 15/11/07 : OpenMP-sorting still under development. Do NOT override the EC_SORTING_NOMP y
(   35) !             Sami Saarinen, ECMWF, 05/12/07 : When export EC_SORTING_INFO=0, then no info messages are printed from CALL so
(   36) !             Sami Saarinen, ECMWF, 20/12/07 : export EC_SORTING_INFO=0, rather than =1 is now the default --> less hassling
(   37) 
(   38) 
(   39) IMPLICIT NONE
(   40) SAVE
(   41) PRIVATE
(   42) 
(   43) INTEGER(KIND=JPIM), PARAMETER :: NTHRDS = 64 ! ***Note: A hardcoded max number of threads !!!
(   44) 
(   45) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_INT4  = 4
(   46) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_INT8  = 8
(   47) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_REAL4 = 4
(   48) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_REAL8 = 8
(   49) 
(   50) INTEGER(KIND=JPIM), PARAMETER :: MIN_METHOD = 1
(   51) INTEGER(KIND=JPIM), PARAMETER :: MAX_METHOD = 5
(   52) 
(   53) INTEGER(KIND=JPIM), PARAMETER :: RADIXSORT_METHOD = 1
(   54) INTEGER(KIND=JPIM), PARAMETER :: HEAPSORT_METHOD  = 2
(   55) INTEGER(KIND=JPIM), PARAMETER :: QUICKSORT_METHOD = 3
(   56) INTEGER(KIND=JPIM), PARAMETER :: COUNTINGSORT_METHOD = 4
(   57) INTEGER(KIND=JPIM), PARAMETER :: GNOMESORT_METHOD = 5
(   58) 
(   59) CHARACTER(LEN=12), PARAMETER :: METHOD_NAME(MIN_METHOD:MAX_METHOD) = &
(   60)      & (/&
(   61)      &   'RADIXSORT   ' &
(   62)      &  ,'HEAPSORT    ' &
(   63)      &  ,'QUICKSORT   ' &
(   64)      &  ,'COUNTINGSORT' &
(   65)      &  ,'GNOMESORT   ' &
(   66)      &  /)
(   67) 
(   68) !-- Select such method for default_method, which also works for multikey sorts
(   69) !   Vector machines should choose radixsort_method, others quicksort_method (oh, sorry, countingsort_method!)
(   70) !
(   71) !   Note: Occasionally radixsort_method may be faster on non-vector machines, too
(   72) #if defined(VPP) || defined(NECSX)
(   73) INTEGER(KIND=JPIM) :: DEFAULT_METHOD = RADIXSORT_METHOD
(   74) INTEGER(KIND=JPIM) :: CURRENT_METHOD(NTHRDS) = RADIXSORT_METHOD
(   75) #else
(   76) INTEGER(KIND=JPIM) :: DEFAULT_METHOD = COUNTINGSORT_METHOD
(   77) INTEGER(KIND=JPIM) :: CURRENT_METHOD(NTHRDS) = COUNTINGSORT_METHOD
(   78) #endif
(   79) 
(   80) !-- A threshold length after which OpenMP in sorting, merging, copying may kick in.
(   81) !   Override with EC_SORTING_NOMP. Detected while initializing/calling SORTING_METHOD
(   82) !   Non-positive values (<= 0) indicate that OpenMP will NOT be attempted at all
(   83) INTEGER(KIND=JPIM) :: NOMP = -1
(   84) 
(   85) !-- EC_SORTING_INFO = MPL-proc id [1..$NPES] to print the info message when CALL sorting_method()
(   86) !                   : 0 (no print; the default)
(   87) !                   : 1 (print on MPL-task one)
(   88) !                   : > 1 and <= $NPES (some other MPL-task than 1 prints)
(   89) INTEGER(KIND=JPIM) :: NSINFO = 0
(   90) 
(   91) INTERFACE KEYSORT






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 3

(   92) MODULE PROCEDURE &
(   93)      &INT4_KEYSORT_1D, INT4_KEYSORT_2D, &
(   94)      &INT8_KEYSORT_1D, INT8_KEYSORT_2D, &
(   95)      &REAL8_KEYSORT_1D, REAL8_KEYSORT_2D, &
(   96)      &REAL4_KEYSORT_1D, REAL4_KEYSORT_2D
(   97) END INTERFACE
(   98) 
(   99) INTERFACE SORTING_METHOD
(  100) MODULE PROCEDURE INT_SORTING_METHOD, STR_SORTING_METHOD
(  101) END INTERFACE
(  102) 
(  103) PUBLIC :: KEYSORT
(  104) PUBLIC :: INIT_INDEX, GET_RANK, ADJUST_INDEX
(  105) PUBLIC :: SORTING_METHOD
(  106) 
(  107) CONTAINS
(  108) 
(  109) !----------------------------
(  110) !--   Public subroutines   --
(  111) !----------------------------
(  112) 
(  113) SUBROUTINE INT_SORTING_METHOD(INEW, IOLD)
(  114) INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)  :: INEW
(  115) INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: IOLD
(  116) INTEGER(KIND=JPIM) :: ITMP, IMYPROC, INPES
(  117) INTEGER(KIND=JPIM) :: ITID
(  118) CHARACTER(LEN=20) CLENV
(  119) LOGICAL, SAVE :: LLFIRST = .TRUE.
(  120) LOGICAL LLOMP, LLHOOK_OK
(  121) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  122) !-- This maybe called from the very first call of DR_HOOK_UTIL ...
(  123) LLHOOK_OK = LHOOK .AND. (PRESENT(INEW) .OR. PRESENT(IOLD))
(  124) IF (LLHOOK_OK) CALL DR_HOOK('ECSORT_MIX:INT_SORTING_METHOD',0,ZHOOK_HANDLE)
(  125) ITID = OML_MY_THREAD()
(  126) LLOMP = OML_IN_PARALLEL()
(  127) IF (PRESENT(IOLD)) IOLD = CURRENT_METHOD(ITID)
(  128) ITMP = -1
(  129) IF (PRESENT(INEW)) THEN
(  130)   ITMP = INEW
(  131) ELSE IF (.NOT.LLOMP) THEN ! Override the default method (only if outside the OpenMP)
(  132)   ITMP = -1 ! no change
(  133)   IF (LLFIRST) THEN ! Do once per execution only
(  134)     INPES = MPL_NPROC()
(  135)     CALL GET_ENVIRONMENT_VARIABLE('EC_SORTING_INFO',CLENV) ! ../support/env.c
(  136)     IF (CLENV /= ' ') THEN
(  137)       ITMP = NSINFO
(  138)       READ(CLENV,'(i20)',END=89,ERR=89) ITMP
(  139)       GOTO 88
(  140) 89    CONTINUE
(  141)       ITMP = NSINFO ! no change
(  142) 88    CONTINUE
(  143)       IF (ITMP <= 0) THEN
(  144)         NSINFO = 0
(  145)       ELSE IF (ITMP >= 1 .AND. ITMP <= INPES) THEN
(  146)         NSINFO = ITMP
(  147)       ENDIF
(  148)     ENDIF
(  149)     IMYPROC = MPL_MYRANK()






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 4

(  150)     CALL GET_ENVIRONMENT_VARIABLE('EC_SORTING_METHOD',CLENV) ! ../support/env.c
(  151)     IF (CLENV /= ' ') THEN
(  152)        IF (IMYPROC == NSINFO) WRITE(0,'(a)')'<EC_SORTING_METHOD='//TRIM(CLENV)
(  153)        CALL TOUPPER(CLENV)
(  154)        SELECT CASE (CLENV)
(  155)        CASE ('RADIX', 'RADIXSORT')
(  156)           ITMP = RADIXSORT_METHOD
(  157)        CASE ('HEAP', 'HEAPSORT')
(  158)           ITMP = HEAPSORT_METHOD
(  159)        CASE ('QUICK', 'QUICKSORT', 'QSORT')
(  160)           ITMP = QUICKSORT_METHOD
(  161)        CASE ('COUNT', 'COUNTINGSORT', 'COUNTSORT')
(  162)           ITMP = COUNTINGSORT_METHOD
(  163)        CASE ('GNOME', 'GNOMESORT')
(  164)           ITMP = GNOMESORT_METHOD
(  165)        CASE ('DEFAULT', 'DEF')
(  166)           ITMP = -1 ! no change
(  167)        CASE DEFAULT
(  168)           READ(CLENV,'(i20)',END=99,ERR=99) ITMP
(  169)           GOTO 98
(  170) 99        CONTINUE
(  171)           ITMP = -1 ! no change
(  172) 98        CONTINUE
(  173)        END SELECT
(  174)     ENDIF
(  175) 
(  176)     IF (ITMP < MIN_METHOD .OR. ITMP > MAX_METHOD) ITMP = DEFAULT_METHOD
(  177)     DEFAULT_METHOD = ITMP
(  178)     CURRENT_METHOD(:) = ITMP
(  179)     IF (IMYPROC == NSINFO) &
(  180)          & WRITE(0,'(a,i1,a)')'>EC_SORTING_METHOD=',DEFAULT_METHOD,&
(  181)          & ' # '//METHOD_NAME(DEFAULT_METHOD)
(  182) 
(  183)     CALL GET_ENVIRONMENT_VARIABLE('EC_SORTING_NOMP',CLENV)
(  184)     IF (CLENV /= ' ') THEN
(  185)        IF (IMYPROC == NSINFO) WRITE(0,'(a)')'<EC_SORTING_NOMP='//TRIM(CLENV)
(  186)        READ(CLENV,'(i20)',END=199,ERR=199) ITMP
(  187)        GOTO 198
(  188) 199    CONTINUE
(  189)        ITMP = NOMP ! no change
(  190) 198    CONTINUE
(  191)        NOMP = ITMP
(  192)     ENDIF
(  193) 
(  194)     IF (IMYPROC == NSINFO) THEN
(  195)       WRITE(CLENV,'(i20)') NOMP
(  196)       WRITE(0,'(a)')'>EC_SORTING_NOMP='//TRIM(ADJUSTL(CLENV))
(  197)     ENDIF
(  198) 
(  199)     ITMP = DEFAULT_METHOD
(  200)     LLFIRST = .FALSE.
(  201)   ENDIF
(  202) ENDIF
(  203) 
(  204) IF (ITMP < MIN_METHOD .OR. ITMP > MAX_METHOD) ITMP = DEFAULT_METHOD
(  205) IF (LLOMP) THEN ! Only this thread sees the change
(  206)   CURRENT_METHOD(ITID) = ITMP
(  207) ELSE ! All threads see the change






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 5

(  208)   CURRENT_METHOD(:) = ITMP
(  209) ENDIF
(  210) IF (LLHOOK_OK) CALL DR_HOOK('ECSORT_MIX:INT_SORTING_METHOD',1,ZHOOK_HANDLE)
(  211) END SUBROUTINE INT_SORTING_METHOD
(  212) 
(  213) 
(  214) SUBROUTINE STR_SORTING_METHOD(CDNEW, IOLD)
(  215) CHARACTER(LEN=*), INTENT(IN) :: CDNEW
(  216) INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: IOLD
(  217) CHARACTER(LEN=LEN(CDNEW)) CLNEW
(  218) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  219) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:STR_SORTING_METHOD',0,ZHOOK_HANDLE)
(  220) CLNEW = CDNEW
(  221) CALL TOUPPER(CLNEW)
(  222) SELECT CASE (CLNEW)
(  223) CASE ('RADIX', 'RADIXSORT')
(  224)   CALL SORTING_METHOD(RADIXSORT_METHOD, IOLD)
(  225) CASE ('HEAP', 'HEAPSORT')
(  226)   CALL SORTING_METHOD(HEAPSORT_METHOD, IOLD)
(  227) CASE ('QUICK', 'QUICKSORT', 'QSORT')
(  228)   CALL SORTING_METHOD(QUICKSORT_METHOD, IOLD)
(  229) CASE ('COUNT', 'COUNTINGSORT', 'COUNTSORT')
(  230)   CALL SORTING_METHOD(COUNTINGSORT_METHOD, IOLD)
(  231) CASE ('GNOME', 'GNOMESORT')
(  232)   CALL SORTING_METHOD(GNOMESORT_METHOD, IOLD)
(  233) CASE ('DEFAULT', 'DEF')
(  234)   CALL SORTING_METHOD(DEFAULT_METHOD, IOLD)
(  235) CASE DEFAULT
(  236)   CALL SORTING_METHOD(DEFAULT_METHOD, IOLD)
(  237) END SELECT
(  238) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:STR_SORTING_METHOD',1,ZHOOK_HANDLE)
(  239) END SUBROUTINE STR_SORTING_METHOD
(  240) 
(  241) 
(  242) SUBROUTINE INIT_INDEX(INDEX, INDEX_ADJ)
(  243) INTEGER(KIND=JPIM), INTENT(OUT):: INDEX(:)
(  244) INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: INDEX_ADJ
(  245) INTEGER(KIND=JPIM) :: I, N
(  246) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  247) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INIT_INDEX',0,ZHOOK_HANDLE)
(  248) N = SIZE(INDEX)
(  249) IF (PRESENT(INDEX_ADJ)) THEN
(  250)   DO I=1,N
(  251)     INDEX(I) = I + INDEX_ADJ
(  252)   ENDDO
(  253) ELSE
(  254)   DO I=1,N
(  255)     INDEX(I) = I
(  256)   ENDDO
(  257) ENDIF
(  258) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INIT_INDEX',1,ZHOOK_HANDLE)
(  259) END SUBROUTINE INIT_INDEX
(  260) 
(  261) 
(  262) SUBROUTINE ADJUST_INDEX(INDEX, INDEX_ADJ)
(  263) INTEGER(KIND=JPIM), INTENT(INOUT):: INDEX(:)
(  264) INTEGER(KIND=JPIM), INTENT(IN) :: INDEX_ADJ
(  265) INTEGER(KIND=JPIM) :: I, N






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 6

(  266) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  267) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:ADJUST_INDEX',0,ZHOOK_HANDLE)
(  268) IF (INDEX_ADJ /= 0) THEN
(  269)   N = SIZE(INDEX)
(  270)   DO I=1,N
(  271)     INDEX(I) = INDEX(I) + INDEX_ADJ
(  272)   ENDDO
(  273) ENDIF
(  274) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:ADJUST_INDEX',1,ZHOOK_HANDLE)
(  275) END SUBROUTINE ADJUST_INDEX
(  276) 
(  277) 
(  278) SUBROUTINE GET_RANK(INDEX, RANK, INDEX_ADJ)
(  279) INTEGER(KIND=JPIM), INTENT(IN) :: INDEX(:)
(  280) INTEGER(KIND=JPIM), INTENT(OUT):: RANK(:)
(  281) INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: INDEX_ADJ
(  282) INTEGER(KIND=JPIM) :: I, N
(  283) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  284) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:GET_RANK',0,ZHOOK_HANDLE)
(  285) N = MIN(SIZE(INDEX),SIZE(RANK))
(  286) IF (PRESENT(INDEX_ADJ)) THEN
(  287)   DO I=1,N
(  288)     RANK(INDEX(I)+INDEX_ADJ) = I
(  289)   ENDDO
(  290) ELSE
(  291)   DO I=1,N
(  292)     RANK(INDEX(I)) = I
(  293)   ENDDO
(  294) ENDIF
(  295) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:GET_RANK',1,ZHOOK_HANDLE)
(  296) END SUBROUTINE GET_RANK
(  297) 
(  298) 
(  299) #undef INT_VERSION
(  300) #undef REAL_VERSION
(  301) 
(  302) !-- Create version for INTEGER(KIND=JPIM)
(  303) #define INT_VERSION   4
(  304) #define REAL_VERSION  0
(  305) #include "ecsort_shared.h"
(  306) #undef INT_VERSION
(  307) #undef REAL_VERSION
(  308) 
(  309) !-- Create version for INTEGER(KIND=JPIB)
(  310) #define INT_VERSION   8
(  311) #define REAL_VERSION  0
(  312) #include "ecsort_shared.h"
(  313) #undef INT_VERSION
(  314) #undef REAL_VERSION
(  315) 
(  316) !-- Create version for REAL(KIND=JPRM)
(  317) #define INT_VERSION   0
(  318) #define REAL_VERSION  4
(  319) #include "ecsort_shared.h"
(  320) #undef INT_VERSION
(  321) #undef REAL_VERSION
(  322) 
(  323) !-- Create version for REAL(KIND=JPRB)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 7

(  324) #define INT_VERSION   0
(  325) #define REAL_VERSION  8
(  326) #include "ecsort_shared.h"
(  327) #undef INT_VERSION
(  328) #undef REAL_VERSION
(  329) 
(  330) END MODULE ECSORT_MIX

























































NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 8

(    1) # 1 "ecsort_mix.F90"
(    1) # 4 "ecsort_mix.F90"
(    4) MODULE ECSORT_MIX
(    5) USE PARKIND1   , ONLY : JPIM     ,JPIB     ,JPRB     ,JPRM    ,JPRD
(    6) USE YOMHOOK    , ONLY : LHOOK, DR_HOOK
(    7) USE OML_MOD     , ONLY : OML_MAX_THREADS, OML_MY_THREAD, OML_IN_PARALLEL
(    8) USE STRHANDLER_MOD , ONLY : TOUPPER
(    9) USE MPL_MODULE , ONLY : MPL_MYRANK, MPL_NPROC
(   10) # 11 "ecsort_mix.F90"
(   11) !$
(   12) !..   Author: Sami Saarinen, ECMWF, 10/02/98
(   13) !     Fixes : Sami Saarinen, ECMWF, 08/11/99 : Sub-arrays go now correctly (look for addrdiff)
(   14) !                                              Genuine real(4) sort "re-habilitated"
(   15) !                                              sizeof_int, _real4 & _real8 HARDCODED !
(   16) !             Sami Saarinen, ECMWF, 11/10/00 : REAL*4 version included (REAL_M)
(   17) !             Sami Saarinen, ECMWF, 28/11/03 : Calls to DR_HOOK added manually (on top of CY28)
(   18) !             Sami Saarinen, ECMWF, 18/02/05 : 64-bit integer sorting introduced (for CY30)
(   19) !             Sami Saarinen, ECMWF, 22/02/05 : Using genuine 64-bit rsort64() => one-pass through data
(   20) !             Sami Saarinen, ECMWF, 06/07/05 : "current_method" made OpenMP-thread aware (for max. # of threads = NTHRDS)
(   21) !             Sami Saarinen, ECMWF, 07/07/05 : Quick-sort method finally arrived (and applicable to multikeys, too)
(   22) !                                              Quick-sort the default for scalar machines ("non-VPP"), VPPs is radix-sort
(   23) !             Sami Saarinen, ECMWF, 03/07/07 : Quick-sort method uses stable approach (was not guaranteed so before)
(   24) !             Sami Saarinen, ECMWF, 15/10/07 : Subroutines put into a common file ../include/ecsort_shared.h and
(   25) !                                              preprocessed from there
(   26) !             Sami Saarinen, ECMWF, 15/10/07 : NTHRDS increased from 32 to 64
(   27) !             Sami Saarinen, ECMWF, 16/10/07 : The default sorting method can be overriden via export EC_SORTING_METHOD=[<number>|<string>]
(   28) !             Sami Saarinen, ECMWF, 30/10/07 : Support for CountingSort added as part of QuickSort speedup
(   29) !             Sami Saarinen, ECMWF, 31/10/07 : CALL SORTING_METHOD() now prints the prevailing method from EC_SORTING_METHOD
(   30) !             Sami Saarinen, ECMWF, 01/11/07 : CountingSort implemented as independent method
(   31) !             Sami Saarinen, ECMWF, 06/11/07 : index_adj added as an optional argument to init_index ; new routine adjust_index()
(   32) !             Sami Saarinen, ECMWF, 07/11/07 : threshold length "nomp" (see below). Override with EC_SORTING_NOMP.
(   33) !             Sami Saarinen, ECMWF, 12/11/07 : Gnome-sort -- the easiest sort on Earth (and very slow for large arrays)
(   34) !             Sami Saarinen, ECMWF, 15/11/07 : OpenMP-sorting still under development. Do NOT override the EC_SORTING_NOMP yet.
(   35) !             Sami Saarinen, ECMWF, 05/12/07 : When export EC_SORTING_INFO=0, then no info messages are printed from CALL sorting_method()
(   36) !             Sami Saarinen, ECMWF, 20/12/07 : export EC_SORTING_INFO=0, rather than =1 is now the default --> less hassling output
(   37) # 39 "ecsort_mix.F90"
(   39) IMPLICIT NONE
(   40) SAVE
(   41) PRIVATE
(   42) # 43 "ecsort_mix.F90"
(   43) INTEGER(KIND=JPIM), PARAMETER :: NTHRDS = 64 ! ***Note: A hardcoded max number of threads !!!
(   44) # 45 "ecsort_mix.F90"
(   45) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_INT4  = 4
(   46) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_INT8  = 8
(   47) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_REAL4 = 4
(   48) INTEGER(KIND=JPIM), PARAMETER :: SIZEOF_REAL8 = 8
(   49) # 50 "ecsort_mix.F90"
(   50) INTEGER(KIND=JPIM), PARAMETER :: MIN_METHOD = 1
(   51) INTEGER(KIND=JPIM), PARAMETER :: MAX_METHOD = 5
(   52) # 53 "ecsort_mix.F90"
(   53) INTEGER(KIND=JPIM), PARAMETER :: RADIXSORT_METHOD = 1
(   54) INTEGER(KIND=JPIM), PARAMETER :: HEAPSORT_METHOD  = 2
(   55) INTEGER(KIND=JPIM), PARAMETER :: QUICKSORT_METHOD = 3
(   56) INTEGER(KIND=JPIM), PARAMETER :: COUNTINGSORT_METHOD = 4
(   57) INTEGER(KIND=JPIM), PARAMETER :: GNOMESORT_METHOD = 5
(   58) # 59 "ecsort_mix.F90"
(   59) CHARACTER(LEN=12), PARAMETER :: METHOD_NAME(MIN_METHOD:MAX_METHOD) = &
(   60)      & (/&






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 9

(   61)      &   'RADIXSORT   ' &
(   62)      &  ,'HEAPSORT    ' &
(   63)      &  ,'QUICKSORT   ' &
(   64)      &  ,'COUNTINGSORT' &
(   65)      &  ,'GNOMESORT   ' &
(   66)      &  /)
(   67) # 68 "ecsort_mix.F90"
(   68) !-- Select such method for default_method, which also works for multikey sorts
(   69) !   Vector machines should choose radixsort_method, others quicksort_method (oh, sorry, countingsort_method!)
(   70) !
(   71) !   Note: Occasionally radixsort_method may be faster on non-vector machines, too
(   72) # 76 "ecsort_mix.F90"
(   76) INTEGER(KIND=JPIM) :: DEFAULT_METHOD = COUNTINGSORT_METHOD
(   77) INTEGER(KIND=JPIM) :: CURRENT_METHOD(NTHRDS) = COUNTINGSORT_METHOD
(   78) # 80 "ecsort_mix.F90"
(   80) !-- A threshold length after which OpenMP in sorting, merging, copying may kick in.
(   81) !   Override with EC_SORTING_NOMP. Detected while initializing/calling SORTING_METHOD
(   82) !   Non-positive values (<= 0) indicate that OpenMP will NOT be attempted at all
(   83) INTEGER(KIND=JPIM) :: NOMP = -1
(   84) # 85 "ecsort_mix.F90"
(   85) !-- EC_SORTING_INFO = MPL-proc id [1..$NPES] to print the info message when CALL sorting_method()
(   86) !                   : 0 (no print; the default)
(   87) !                   : 1 (print on MPL-task one)
(   88) !                   : > 1 and <= $NPES (some other MPL-task than 1 prints)
(   89) INTEGER(KIND=JPIM) :: NSINFO = 0
(   90) # 91 "ecsort_mix.F90"
(   91) INTERFACE KEYSORT
(   92) MODULE PROCEDURE &
(   93)      &INT4_KEYSORT_1D, INT4_KEYSORT_2D, &
(   94)      &INT8_KEYSORT_1D, INT8_KEYSORT_2D, &
(   95)      &REAL8_KEYSORT_1D, REAL8_KEYSORT_2D, &
(   96)      &REAL4_KEYSORT_1D, REAL4_KEYSORT_2D
(   97) END INTERFACE
(   98) # 99 "ecsort_mix.F90"
(   99) INTERFACE SORTING_METHOD
(  100) MODULE PROCEDURE INT_SORTING_METHOD, STR_SORTING_METHOD
(  101) END INTERFACE
(  102) # 103 "ecsort_mix.F90"
(  103) PUBLIC :: KEYSORT
(  104) PUBLIC :: INIT_INDEX, GET_RANK, ADJUST_INDEX
(  105) PUBLIC :: SORTING_METHOD
(  106) # 107 "ecsort_mix.F90"
(  107) CONTAINS
(  108) # 109 "ecsort_mix.F90"
(  109) !----------------------------
(  110) !--   Public subroutines   --
(  111) !----------------------------
(  112) # 113 "ecsort_mix.F90"
(  113) SUBROUTINE INT_SORTING_METHOD(INEW, IOLD)
(  114) INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)  :: INEW
(  115) INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: IOLD
(  116) INTEGER(KIND=JPIM) :: ITMP, IMYPROC, INPES
(  117) INTEGER(KIND=JPIM) :: ITID
(  118) CHARACTER(LEN=20) CLENV
(  119) LOGICAL, SAVE :: LLFIRST = .TRUE.
(  120) LOGICAL LLOMP, LLHOOK_OK
(  121) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  122) !-- This maybe called from the very first call of DR_HOOK_UTIL ...






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 10

(  123) LLHOOK_OK = LHOOK .AND. (PRESENT(INEW) .OR. PRESENT(IOLD))
(  124) IF (LLHOOK_OK) CALL DR_HOOK('ECSORT_MIX:INT_SORTING_METHOD',0,ZHOOK_HANDLE)
(  125) ITID = OML_MY_THREAD()
(  126) LLOMP = OML_IN_PARALLEL()
(  127) IF (PRESENT(IOLD)) IOLD = CURRENT_METHOD(ITID)
(  128) ITMP = -1
(  129) IF (PRESENT(INEW)) THEN
(  130)   ITMP = INEW
(  131) ELSE IF (.NOT.LLOMP) THEN ! Override the default method (only if outside the OpenMP)
(  132)   ITMP = -1 ! no change
(  133)   IF (LLFIRST) THEN ! Do once per execution only
(  134)     INPES = MPL_NPROC()
(  135)     CALL GET_ENVIRONMENT_VARIABLE('EC_SORTING_INFO',CLENV) ! ../support/env.c
(  136)     IF (CLENV /= ' ') THEN
(  137)       ITMP = NSINFO
(  138)       READ(CLENV,'(i20)',END=89,ERR=89) ITMP
(  139)       GOTO 88
(  140) 89    CONTINUE
(  141)       ITMP = NSINFO ! no change
(  142) 88    CONTINUE
(  143)       IF (ITMP <= 0) THEN
(  144)         NSINFO = 0
(  145)       ELSE IF (ITMP >= 1 .AND. ITMP <= INPES) THEN
(  146)         NSINFO = ITMP
(  147)       ENDIF
(  148)     ENDIF
(  149)     IMYPROC = MPL_MYRANK()
(  150)     CALL GET_ENVIRONMENT_VARIABLE('EC_SORTING_METHOD',CLENV) ! ../support/env.c
(  151)     IF (CLENV /= ' ') THEN
(  152)        IF (IMYPROC == NSINFO) WRITE(0,'(a)')'<EC_SORTING_METHOD='//TRIM(CLENV)
(  153)        CALL TOUPPER(CLENV)
(  154)        SELECT CASE (CLENV)
(  155)        CASE ('RADIX', 'RADIXSORT')
(  156)           ITMP = RADIXSORT_METHOD
(  157)        CASE ('HEAP', 'HEAPSORT')
(  158)           ITMP = HEAPSORT_METHOD
(  159)        CASE ('QUICK', 'QUICKSORT', 'QSORT')
(  160)           ITMP = QUICKSORT_METHOD
(  161)        CASE ('COUNT', 'COUNTINGSORT', 'COUNTSORT')
(  162)           ITMP = COUNTINGSORT_METHOD
(  163)        CASE ('GNOME', 'GNOMESORT')
(  164)           ITMP = GNOMESORT_METHOD
(  165)        CASE ('DEFAULT', 'DEF')
(  166)           ITMP = -1 ! no change
(  167)        CASE DEFAULT
(  168)           READ(CLENV,'(i20)',END=99,ERR=99) ITMP
(  169)           GOTO 98
(  170) 99        CONTINUE
(  171)           ITMP = -1 ! no change
(  172) 98        CONTINUE
(  173)        END SELECT
(  174)     ENDIF
(  175) # 176 "ecsort_mix.F90"
(  176)     IF (ITMP < MIN_METHOD .OR. ITMP > MAX_METHOD) ITMP = DEFAULT_METHOD
(  177)     DEFAULT_METHOD = ITMP
(  178)     CURRENT_METHOD(:) = ITMP
(  179)     IF (IMYPROC == NSINFO) &
(  180)          & WRITE(0,'(a,i1,a)')'>EC_SORTING_METHOD=',DEFAULT_METHOD,&






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 11

(  181)          & ' # '//METHOD_NAME(DEFAULT_METHOD)
(  182) # 183 "ecsort_mix.F90"
(  183)     CALL GET_ENVIRONMENT_VARIABLE('EC_SORTING_NOMP',CLENV)
(  184)     IF (CLENV /= ' ') THEN
(  185)        IF (IMYPROC == NSINFO) WRITE(0,'(a)')'<EC_SORTING_NOMP='//TRIM(CLENV)
(  186)        READ(CLENV,'(i20)',END=199,ERR=199) ITMP
(  187)        GOTO 198
(  188) 199    CONTINUE
(  189)        ITMP = NOMP ! no change
(  190) 198    CONTINUE
(  191)        NOMP = ITMP
(  192)     ENDIF
(  193) # 194 "ecsort_mix.F90"
(  194)     IF (IMYPROC == NSINFO) THEN
(  195)       WRITE(CLENV,'(i20)') NOMP
(  196)       WRITE(0,'(a)')'>EC_SORTING_NOMP='//TRIM(ADJUSTL(CLENV))
(  197)     ENDIF
(  198) # 199 "ecsort_mix.F90"
(  199)     ITMP = DEFAULT_METHOD
(  200)     LLFIRST = .FALSE.
(  201)   ENDIF
(  202) ENDIF
(  203) # 204 "ecsort_mix.F90"
(  204) IF (ITMP < MIN_METHOD .OR. ITMP > MAX_METHOD) ITMP = DEFAULT_METHOD
(  205) IF (LLOMP) THEN ! Only this thread sees the change
(  206)   CURRENT_METHOD(ITID) = ITMP
(  207) ELSE ! All threads see the change
(  208)   CURRENT_METHOD(:) = ITMP
(  209) ENDIF
(  210) IF (LLHOOK_OK) CALL DR_HOOK('ECSORT_MIX:INT_SORTING_METHOD',1,ZHOOK_HANDLE)
(  211) END SUBROUTINE INT_SORTING_METHOD
(  212) # 214 "ecsort_mix.F90"
(  214) SUBROUTINE STR_SORTING_METHOD(CDNEW, IOLD)
(  215) CHARACTER(LEN=*), INTENT(IN) :: CDNEW
(  216) INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: IOLD
(  217) CHARACTER(LEN=LEN(CDNEW)) CLNEW
(  218) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  219) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:STR_SORTING_METHOD',0,ZHOOK_HANDLE)
(  220) CLNEW = CDNEW
(  221) CALL TOUPPER(CLNEW)
(  222) SELECT CASE (CLNEW)
(  223) CASE ('RADIX', 'RADIXSORT')
(  224)   CALL SORTING_METHOD(RADIXSORT_METHOD, IOLD)
(  225) CASE ('HEAP', 'HEAPSORT')
(  226)   CALL SORTING_METHOD(HEAPSORT_METHOD, IOLD)
(  227) CASE ('QUICK', 'QUICKSORT', 'QSORT')
(  228)   CALL SORTING_METHOD(QUICKSORT_METHOD, IOLD)
(  229) CASE ('COUNT', 'COUNTINGSORT', 'COUNTSORT')
(  230)   CALL SORTING_METHOD(COUNTINGSORT_METHOD, IOLD)
(  231) CASE ('GNOME', 'GNOMESORT')
(  232)   CALL SORTING_METHOD(GNOMESORT_METHOD, IOLD)
(  233) CASE ('DEFAULT', 'DEF')
(  234)   CALL SORTING_METHOD(DEFAULT_METHOD, IOLD)
(  235) CASE DEFAULT
(  236)   CALL SORTING_METHOD(DEFAULT_METHOD, IOLD)
(  237) END SELECT
(  238) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:STR_SORTING_METHOD',1,ZHOOK_HANDLE)
(  239) END SUBROUTINE STR_SORTING_METHOD






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 12

(  240) # 242 "ecsort_mix.F90"
(  242) SUBROUTINE INIT_INDEX(INDEX, INDEX_ADJ)
(  243) INTEGER(KIND=JPIM), INTENT(OUT):: INDEX(:)
(  244) INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: INDEX_ADJ
(  245) INTEGER(KIND=JPIM) :: I, N
(  246) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  247) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INIT_INDEX',0,ZHOOK_HANDLE)
(  248) N = SIZE(INDEX)
(  249) IF (PRESENT(INDEX_ADJ)) THEN
(  250)   DO I=1,N
(  251)     INDEX(I) = I + INDEX_ADJ
(  252)   ENDDO
(  253) ELSE
(  254)   DO I=1,N
(  255)     INDEX(I) = I
(  256)   ENDDO
(  257) ENDIF
(  258) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INIT_INDEX',1,ZHOOK_HANDLE)
(  259) END SUBROUTINE INIT_INDEX
(  260) # 262 "ecsort_mix.F90"
(  262) SUBROUTINE ADJUST_INDEX(INDEX, INDEX_ADJ)
(  263) INTEGER(KIND=JPIM), INTENT(INOUT):: INDEX(:)
(  264) INTEGER(KIND=JPIM), INTENT(IN) :: INDEX_ADJ
(  265) INTEGER(KIND=JPIM) :: I, N
(  266) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  267) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:ADJUST_INDEX',0,ZHOOK_HANDLE)
(  268) IF (INDEX_ADJ /= 0) THEN
(  269)   N = SIZE(INDEX)
(  270)   DO I=1,N
(  271)     INDEX(I) = INDEX(I) + INDEX_ADJ
(  272)   ENDDO
(  273) ENDIF
(  274) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:ADJUST_INDEX',1,ZHOOK_HANDLE)
(  275) END SUBROUTINE ADJUST_INDEX
(  276) # 278 "ecsort_mix.F90"
(  278) SUBROUTINE GET_RANK(INDEX, RANK, INDEX_ADJ)
(  279) INTEGER(KIND=JPIM), INTENT(IN) :: INDEX(:)
(  280) INTEGER(KIND=JPIM), INTENT(OUT):: RANK(:)
(  281) INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: INDEX_ADJ
(  282) INTEGER(KIND=JPIM) :: I, N
(  283) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  284) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:GET_RANK',0,ZHOOK_HANDLE)
(  285) N = MIN(SIZE(INDEX),SIZE(RANK))
(  286) IF (PRESENT(INDEX_ADJ)) THEN
(  287)   DO I=1,N
(  288)     RANK(INDEX(I)+INDEX_ADJ) = I
(  289)   ENDDO
(  290) ELSE
(  291)   DO I=1,N
(  292)     RANK(INDEX(I)) = I
(  293)   ENDDO
(  294) ENDIF
(  295) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:GET_RANK',1,ZHOOK_HANDLE)
(  296) END SUBROUTINE GET_RANK
(  297) # 302 "ecsort_mix.F90"
(  302) !-- Create version for INTEGER(KIND=JPIM)
(  303) # 305 "ecsort_mix.F90"
(  305) # 1 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 13

(    1) !*** ecsort_shared.h ***
(    2) # 85 ".D[15]/ecsort_shared.h"
(   85) !----------------------------
(   86) !--   Public subroutines   --
(   87) !----------------------------
(   88) # 90 ".D[15]/ecsort_shared.h"
(   90) SUBROUTINE INT4_KEYSORT_1D(rc, a, n, method, descending, index, init)
(   91) !-- Please note that we assume that a(:) occupies consecutive memory locations
(   92) INTEGER(KIND=JPIM), intent(out)           :: rc
(   93) INTEGER(KIND=JPIM)         , intent(inout)         :: a(:)
(   94) INTEGER(KIND=JPIM), intent(in)            :: n
(   95) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: method
(   96) logical, intent(in), OPTIONAL  :: descending
(   97) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(   98) logical, intent(in), OPTIONAL  :: init
(   99) ! === END OF INTERFACE BLOCK ===
(  100) INTEGER(KIND=JPIM)          , allocatable :: aa(:,:)
(  101) INTEGER(KIND=JPIM) :: imethod, irev, idummy, index_adj
(  102) logical :: LLfast, LLdescending, LLomp_okay, LLinit
(  103) INTEGER(KIND=JPIM) :: ITID, ichunk, iret, inumt
(  104) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  105) # 106 ".D[15]/ecsort_shared.h"
(  106) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_KEYSORT_1D',0,ZHOOK_HANDLE)
(  107) # 108 ".D[15]/ecsort_shared.h"
(  108) rc = 0
(  109) if (n <= 0 .or. size(a) <= 0) goto 99
(  110) # 111 ".D[15]/ecsort_shared.h"
(  111) if (present(descending)) then
(  112)   LLdescending = descending
(  113) else
(  114)   LLdescending = .FALSE.
(  115) endif
(  116) # 117 ".D[15]/ecsort_shared.h"
(  117) irev = 0
(  118) if (LLdescending) irev = 1
(  119) # 120 ".D[15]/ecsort_shared.h"
(  120) ITID = OML_MY_THREAD()
(  121) imethod = current_method(ITID)
(  122) if (present(method)) then
(  123)   imethod = min(max(min_method,method),max_method)
(  124) endif
(  125) # 126 ".D[15]/ecsort_shared.h"
(  126) if (imethod /= quicksort_method .and. &
(  127)    &imethod /= countingsort_method) then
(  128)   LLfast = .FALSE.
(  129) else if (imethod == quicksort_method) then
(  130)   !-- hasn't been implemented if index is present ;-(
(  131)   LLfast = (&
(  132)        & .not.present(index) .and. &
(  133)        & .not.present(init))
(  134) else if (imethod == countingsort_method) then
(  135)   !-- index-presence is ok
(  136)   LLfast = .TRUE.
(  137) endif
(  138) # 139 ".D[15]/ecsort_shared.h"
(  139) if (LLfast) then
(  140)   !- Only Quick-sort & CountingSort covered
(  141) # 142 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 14

(  142)   if (imethod == quicksort_method) then
(  143)     inumt = OML_MAX_THREADS()
(  144)     LLomp_okay = (inumt > 1 .and. nomp >= inumt .and. n >= nomp)
(  145)     LLomp_okay = (LLomp_okay .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  146)     if (LLomp_okay) then
(  147)       !-- Max 2-way OpenMP parallelism for now ...
(  148)       ichunk = n/2
(  149) !$OMP PARALLEL PRIVATE(iret)
(  150) !$OMP SECTIONS
(  151) !$OMP SECTION
(  152)       CALL ecqsortfast(11, ichunk, a(1), irev, iret)
(  153) !$OMP SECTION
(  154)       CALL ecqsortfast(11, n-ichunk, a(ichunk+1), irev, iret)
(  155) !$OMP END SECTIONS
(  156) !$OMP END PARALLEL
(  157)       CALL ecmerge2(11, 1, ichunk, n-ichunk, a(1), &
(  158)            & idummy, 0, 1, irev, idummy, rc)
(  159)     else
(  160)       CALL ecqsortfast(11, n, a(1), irev, rc)
(  161)     endif
(  162)     GOTO 99
(  163) # 164 ".D[15]/ecsort_shared.h"
(  164)   else if (imethod == countingsort_method) then
(  165)     if (.not.present(index)) then
(  166)       CALL ec_countingsort(11, n, 1, 1, a(1), idummy, 0, 1, irev, rc)
(  167)     else
(  168)       LLinit = .FALSE.
(  169)       if (present(init)) LLinit = init
(  170)       if (LLinit) then
(  171)         CALL init_index(index, index_adj=-1)
(  172)         index_adj = 0
(  173)       else
(  174)         index_adj = 1
(  175)       endif
(  176)       CALL ec_countingsort(11, n, 1, 1, a(1), index(1), size(index), index_adj, irev, rc)
(  177)       if (index_adj == 0) CALL adjust_index(index, +1)
(  178)     endif
(  179)     GOTO 99
(  180) # 181 ".D[15]/ecsort_shared.h"
(  181)   else
(  182)     LLfast = .false.
(  183)   endif
(  184) endif
(  185) # 186 ".D[15]/ecsort_shared.h"
(  186) !-- LLfast == .FALSE. :
(  187) # 188 ".D[15]/ecsort_shared.h"
(  188) allocate(aa(n,1))
(  189) # 190 ".D[15]/ecsort_shared.h"
(  190) if (LLdescending) then
(  191)   aa(1:n,1) = -a(1:n)
(  192) else
(  193)   aa(1:n,1) = a(1:n)
(  194) endif
(  195) # 196 ".D[15]/ecsort_shared.h"
(  196) CALL keysort(rc, aa, n, method=method, index=index, init=init)
(  197) # 198 ".D[15]/ecsort_shared.h"
(  198) if (LLdescending) then
(  199)   a(1:n) = -aa(1:n,1)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 15

(  200) else
(  201)   a(1:n) = aa(1:n,1)
(  202) endif
(  203) # 204 ".D[15]/ecsort_shared.h"
(  204) deallocate(aa)
(  205) # 206 ".D[15]/ecsort_shared.h"
(  206) 99 continue
(  207) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_KEYSORT_1D',1,ZHOOK_HANDLE,n)
(  208) END SUBROUTINE
(  209) # 211 ".D[15]/ecsort_shared.h"
(  211) SUBROUTINE INT4_KEYSORT_2D(&
(  212)      &rc, a, n,&
(  213)      &key, multikey, method,&
(  214)      &index, init, transposed)
(  215) # 216 ".D[15]/ecsort_shared.h"
(  216) INTEGER(KIND=JPIM), intent(out)           :: rc
(  217) INTEGER(KIND=JPIM)         , intent(inout)         :: a(:,:)
(  218) INTEGER(KIND=JPIM), intent(in)            :: n
(  219) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: key, method
(  220) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: multikey(:)
(  221) logical, intent(in), OPTIONAL  :: transposed
(  222) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(  223) logical, intent(in), OPTIONAL  :: init
(  224) ! === END OF INTERFACE BLOCK ===
(  225) INTEGER(KIND=JPIM), POINTER :: iindex(:)
(  226) INTEGER(KIND=JPIM) :: ikey, istride, imethod, inumkeys, imethod_1st, imethod_rest
(  227) INTEGER(KIND=JPIM) :: lda, iptr, i, j, sda, idiff, irev, inumt, jkey, jj, ilastkey
(  228) INTEGER(KIND=JPIM) :: j1, j2, jmid, inum, imax, iadd, imod, iret, inc, iamax, ibmax
(  229) INTEGER(KIND=JPIM)         , allocatable :: data(:)
(  230) INTEGER(KIND=JPIM), allocatable :: ikeys(:), ista(:), ichunk(:), irank(:)
(  231) logical LLinit, LLdescending, LLtrans, LLomp_okay, LLadjusted, LLdebug, LLomp_prefix
(  232) character(len=1) clenv
(  233) REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_SUBHANDLE
(  234) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE0
(  235) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE1
(  236) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE2
(  237) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE3
(  238) INTEGER(KIND=JPIM) :: ITID
(  239) # 240 ".D[15]/ecsort_shared.h"
(  240) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_KEYSORT_2D',0,ZHOOK_HANDLE)
(  241) # 242 ".D[15]/ecsort_shared.h"
(  242) rc = 0
(  243) lda = size(a, dim=1)
(  244) sda = size(a, dim=2)
(  245) if (n <= 0 .or. lda <= 0 .or. sda <= 0) goto 99
(  246) # 247 ".D[15]/ecsort_shared.h"
(  247) inumt = OML_MAX_THREADS()
(  248) ITID = OML_MY_THREAD()
(  249) imethod = current_method(ITID)
(  250) if (present(method)) then
(  251)   imethod = min(max(min_method,method),max_method)
(  252) endif
(  253) imethod_1st = imethod
(  254) imethod_rest = imethod
(  255) # 256 ".D[15]/ecsort_shared.h"
(  256) ikey = 1
(  257) if (present(key)) ikey = key
(  258) # 259 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 16

(  259) if (present(multikey)) then
(  260)   allocate(ikeys(size(multikey)))
(  261)   ikeys(:) = multikey(:)
(  262) else
(  263)   allocate(ikeys(1))
(  264)   ikeys(1) = ikey
(  265) endif
(  266) inumkeys = size(ikeys)
(  267) # 268 ".D[15]/ecsort_shared.h"
(  268) !-- Only the RADIX-sort & now also QUICK-sort & CountingSort give the result we want with multiple keys
(  269) if (inumkeys > 1 .and. &
(  270)     imethod /= radixsort_method .and. &
(  271)     imethod /= quicksort_method .and. &
(  272)     imethod /= countingsort_method) then
(  273)    imethod = default_method
(  274)    imethod_1st = imethod
(  275)    imethod_rest = imethod
(  276)    !-- Since "default_method" may now be [overridden as] HEAP-sort, make sure its then "radixsort_method"
(  277)    !   Note: The first sweep may still be e.g. HEAP-sort
(  278)    if (imethod /= radixsort_method .and. &
(  279)        imethod /= quicksort_method .and. &
(  280)        imethod /= countingsort_method) then
(  281)      imethod = radixsort_method
(  282)      imethod_rest = imethod
(  283)    endif
(  284) endif
(  285) # 286 ".D[15]/ecsort_shared.h"
(  286) LLinit = .FALSE.
(  287) if (present(init)) LLinit = init
(  288) # 289 ".D[15]/ecsort_shared.h"
(  289) if (present(index)) then
(  290)   iindex => index(1:n)
(  291) else
(  292)   allocate(iindex(n))
(  293)   LLinit = .TRUE.
(  294) endif
(  295) # 296 ".D[15]/ecsort_shared.h"
(  296) if (LLinit) CALL init_index(iindex)
(  297) # 298 ".D[15]/ecsort_shared.h"
(  298) istride = 1
(  299) LLtrans = .FALSE.
(  300) if (present(transposed)) LLtrans = transposed
(  301) if (LLtrans) then
(  302)   istride = lda
(  303) else if (sda >= 2 .and. lda >= 1) then
(  304) !-- Check for presence of sub-array and adjust lda automatically
(  305)   call addrdiff(a(1,1),a(1,2),idiff)
(  306)   ! lda below: The true leading dimension; overrides sub-arrays one
(  307)   lda = idiff/sizeof_int4
(  308) endif
(  309) # 310 ".D[15]/ecsort_shared.h"
(  310) ilastkey = 0
(  311) LLadjusted = .FALSE.
(  312) LLomp_prefix = .FALSE.
(  313) !$ LLomp_prefix = (istride == 1 .and. nomp >= inumt .and. n >= nomp)
(  314) if (LLomp_prefix) then
(  315)   call get_environment_variable('EC_SORTING_DEBUG',clenv)
(  316)   LLdebug = (clenv == '1' .and. n < 10000)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 17

(  317)   if (LLdebug) write(0,*)'>> EC_SORTING_DEBUG=1'
(  318) else
(  319)   LLdebug = .FALSE.
(  320) endif
(  321) # 322 ".D[15]/ecsort_shared.h"
(  322) 1000 format(1x,a,2i12,:,/,(10i5))
(  323) 1001 format(1x,'[#',i2,']:',a,(10i5))
(  324) 1002 format(1x,'[#',i2,']:',a,:,/,(10i5))
(  325) 1003 format(1x,'[#',i2,']:',a,2i12,:,/,(10i5))
(  326) 1004 format(1x,a,:,(10i5))
(  327) 1005 format(1x,a,i2,1x,a)
(  328) # 329 ".D[15]/ecsort_shared.h"
(  329) imethod = imethod_1st
(  330) KEYLOOP: do jkey=inumkeys,1,-1
(  331) !--   Sort by the least significant key first
(  332)   ikey = abs(ikeys(jkey))
(  333)   if (ikey == 0) cycle KEYLOOP
(  334) # 335 ".D[15]/ecsort_shared.h"
(  335)   if (istride == 1) then
(  336)     iptr = lda * (ikey - 1) + 1
(  337)   else
(  338)     iptr = ikey
(  339)   endif
(  340) # 341 ".D[15]/ecsort_shared.h"
(  341)   if (LLdebug) then
(  342)     write(0,1000) '<BEGIN>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  343)     if (LLadjusted) then
(  344)       CALL INT4_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,1)
(  345)     else
(  346)       CALL INT4_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,0)
(  347)     endif
(  348)     ilastkey = ikey
(  349)   endif
(  350) # 351 ".D[15]/ecsort_shared.h"
(  351)   LLdescending = (ikeys(jkey) < 0)
(  352)   irev = 0
(  353)   if (LLdescending) irev = 1
(  354) # 355 ".D[15]/ecsort_shared.h"
(  355)   !-- Since "irev" is passed into the ecqsort, no explicit reversing is needed --> savings
(  356)   if (imethod == quicksort_method .or. &
(  357)       imethod == countingsort_method) LLdescending = .FALSE.
(  358) # 359 ".D[15]/ecsort_shared.h"
(  359)   if (LLdescending) then
(  360)     if (istride == 1) then
(  361)       a(1:n,ikey) = -a(1:n,ikey)
(  362)     else
(  363)       a(ikey,1:n) = -a(ikey,1:n)
(  364)     endif
(  365)     irev = 0 ! prevents use of "reverse" algorithm in ecmerge2 for radix-sort
(  366)   endif
(  367) # 368 ".D[15]/ecsort_shared.h"
(  368)   LLomp_okay = LLomp_prefix .and. (inumt > 1) .and. (&
(  369)        & imethod == radixsort_method .or. &
(  370)        & imethod == quicksort_method .or. &
(  371)        & imethod == countingsort_method)
(  372)   LLomp_okay = LLomp_okay .and. (.not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  373) # 374 ".D[15]/ecsort_shared.h"
(  374)   if (.not.LLomp_okay) then






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 18

(  375)     select case (imethod)
(  376)     case (radixsort_method)
(  377)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_11',0,ZHOOK_SUBHANDLE0)
(  378) # 381 ".D[15]/ecsort_shared.h"
(  381)       CALL rsort32_func(11, n, istride, iptr, a(1,1), iindex(1), 1, rc)
(  382) # 383 ".D[15]/ecsort_shared.h"
(  383)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_11',1,ZHOOK_SUBHANDLE0, n)
(  384)     case (heapsort_method)
(  385)       if (istride == 1) then
(  386)         CALL INT4_HEAPSORT(11, n, a(1:n, ikey), rc, irev, istride, iindex)
(  387)       else
(  388)         CALL INT4_HEAPSORT(11, n, a(ikey, 1:n), rc, irev, istride, iindex)
(  389)       endif
(  390)     case (quicksort_method)
(  391)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_ECQSORT',0,ZHOOK_SUBHANDLE0)
(  392)       CALL ecqsort(11, n, istride, iptr, a(1,1), iindex(1), 1, irev, rc)
(  393)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_ECQSORT',1,ZHOOK_SUBHANDLE0,n)
(  394)     case (countingsort_method)
(  395)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_COUNT',0,ZHOOK_SUBHANDLE0)
(  396)       CALL ec_countingsort(11, n, istride, iptr, a(1,1), iindex(1), n, 1, irev, rc)
(  397)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_COUNT',1,ZHOOK_SUBHANDLE0,n)
(  398)     case (gnomesort_method)
(  399)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_GNOME',0,ZHOOK_SUBHANDLE0)
(  400)       CALL ecgnomesort(11, n, istride, iptr, a(1,1), iindex(1), n, 1, rc)
(  401)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_GNOME',1,ZHOOK_SUBHANDLE0,n)
(  402)     end select
(  403) # 404 ".D[15]/ecsort_shared.h"
(  404)   else ! i.e. LLomp_okay ; radix, quick & counting -sorts only
(  405)     if (.not.allocated(ista)) then
(  406)       allocate(ista(inumt+1),ichunk(inumt))
(  407)       inc = n/inumt
(  408)       iadd = 1
(  409)       imod = mod(n,inumt)
(  410)       if (imod == 0) iadd = 0
(  411)       ista(1) = 1
(  412)       do j=2,inumt
(  413)         ista(j) = ista(j-1) + inc + iadd
(  414)         if (iadd > 0 .and. j > imod) iadd = 0
(  415)       enddo
(  416)       ista(inumt+1) = n + 1
(  417)       do j=1,inumt
(  418)         ichunk(j) = ista(j+1) - ista(j)
(  419)       enddo
(  420)       if (LLdebug) then
(  421)         write(0,1005) '>> imethod,name=',imethod,method_name(imethod)
(  422)         write(0,1004) '>> inumt,n,nomp=',inumt,n,nomp
(  423)         write(0,1004) '>> ista(1:inumt+1)=',ista(1:inumt+1)
(  424)         write(0,1004) '>> ichunk(1:inumt)=',ichunk(1:inumt)
(  425)       endif
(  426)       allocate(irank(n))
(  427)     endif
(  428) # 429 ".D[15]/ecsort_shared.h"
(  429)     if (LLdebug) write(0,1004) '>>KEYLOOP: jkey,ikey,irev,iptr=',jkey,ikey,irev,iptr
(  430) # 431 ".D[15]/ecsort_shared.h"
(  431)     if (.not.LLadjusted) then ! only once
(  432)       if (LLdebug) write(0,1000) '<1>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  433)       call adjust_index(iindex, -1) ! Fortran -> C
(  434)       if (LLdebug) write(0,1000) '<2>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 19

(  435)       LLadjusted = .TRUE.
(  436)     endif
(  437) # 438 ".D[15]/ecsort_shared.h"
(  438)     if (LLdebug) write(0,*)'>> Sorting inumt-chunks in parallel'
(  439) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iret,inc,ITID,ZHOOK_SUBHANDLE1,ZHOOK_SUBHANDLE2)
(  440)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',0,ZHOOK_SUBHANDLE1)
(  441)     ITID = OML_MY_THREAD()
(  442) !$OMP DO SCHEDULE(DYNAMIC,1)
(  443)     do j=1,inumt
(  444)       j1 = ista(j)
(  445)       inum = ichunk(j)
(  446)       j2 = j1 + inum - 1
(  447)       inc = j1
(  448)       if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum,inc=',j,j1,j2,inum,inc
(  449)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  450)       select case (imethod)
(  451)       case (radixsort_method)
(  452)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_11',0,ZHOOK_SUBHANDLE2)
(  453) # 456 ".D[15]/ecsort_shared.h"
(  456)         CALL rsort32_func(11, inum, istride, iptr, a(1,1), iindex(j1), 0, iret)
(  457) # 458 ".D[15]/ecsort_shared.h"
(  458)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_11',1,ZHOOK_SUBHANDLE2, inum)
(  459)       case (quicksort_method)
(  460)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_ECQSORT',0,ZHOOK_SUBHANDLE2)
(  461)         CALL ecqsort(11, inum, istride, iptr, a(1,1), iindex(j1), 0, irev, iret)
(  462)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_ECQSORT',1,ZHOOK_SUBHANDLE2,inum)
(  463)       case (countingsort_method)
(  464)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_COUNT',0,ZHOOK_SUBHANDLE2)
(  465)         CALL ec_countingsort(11, inum, istride, iptr, a(1,1), iindex(j1), inum, 0, irev, iret)
(  466)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_COUNT',1,ZHOOK_SUBHANDLE2,inum)
(  467)       end select
(  468)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  469)     enddo
(  470) !$OMP END DO
(  471)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',1,ZHOOK_SUBHANDLE1)
(  472) !$OMP END PARALLEL
(  473) # 474 ".D[15]/ecsort_shared.h"
(  474)     if (LLdebug) write(0,1000) '<after_sort>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  475)     if (LLdebug) CALL INT4_DBGPRINT(0,'<after_sort>',a,iindex,n,ikey,1,n,1)
(  476)     CALL get_rank(iindex, irank, index_adj=+1)
(  477) # 478 ".D[15]/ecsort_shared.h"
(  478)     if (LLdebug) write(0,*) '>> Merge neighbouring chunks in parallel as much as possible'
(  479)     inc = 2
(  480)     imax = (inumt+inc-1)/inc
(  481)     do jj=1,imax
(  482)       if (LLdebug) write(0,1001) jj,'<before_merge> jj,inc,imax,inumt=',jj,inc,imax,inumt
(  483) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iamax,ibmax,jmid,iret,ZHOOK_SUBHANDLE3,ITID)
(  484)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',0,ZHOOK_SUBHANDLE3)
(  485)       ITID = OML_MY_THREAD()
(  486) !$OMP DO SCHEDULE(DYNAMIC,1)
(  487)       do j=1,inumt,inc
(  488)         j1 = j
(  489)         j2 = j + inc - 1
(  490)         jmid = (j1 + j2)/2 + 1
(  491)         j2 = min(j2,inumt)
(  492)         jmid = min(jmid,inumt)
(  493)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,jmid=',j,j1,j2,jmid
(  494)         iamax = ista(jmid) - ista(j1)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 20

(  495)         inum = sum(ichunk(j1:j2))
(  496)         ibmax = inum - iamax
(  497)         if (LLdebug) write(0,1001) ITID,'j,iamax,ibmax,inum=',j,iamax,ibmax,inum
(  498)         if (iamax == 0 .or. ibmax == 0 .or. inum == 0) cycle
(  499)         j1 = ista(j1)
(  500)         j2 = ista(j2+1) - 1
(  501)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum=',j,j1,j2,inum
(  502)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  503)         call ecmerge2(11, iptr, iamax, ibmax, a(1,1), &
(  504)              & iindex(j1), inum, 0, irev, irank(1), iret)
(  505)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  506)       enddo ! do j=1,inumt,inc
(  507) !$OMP END DO
(  508)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',1,ZHOOK_SUBHANDLE3)
(  509) !$OMP END PARALLEL
(  510) # 511 ".D[15]/ecsort_shared.h"
(  511)       if (LLdebug) write(0,1003) jj,'<after_merge>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  512)       if (LLdebug) CALL INT4_DBGPRINT(jj,'<after_merge>',a,iindex,n,ikey,1,n,1)
(  513) # 514 ".D[15]/ecsort_shared.h"
(  514)       inc = inc * 2
(  515)     enddo ! do jj=1,imax
(  516)     rc = n
(  517)   endif ! if (LLomp_okay)
(  518) # 519 ".D[15]/ecsort_shared.h"
(  519)   if (LLdescending) then
(  520)     if (istride == 1) then
(  521)       a(1:n,ikey) = -a(1:n,ikey)
(  522)     else
(  523)       a(ikey,1:n) = -a(ikey,1:n)
(  524)     endif
(  525)   endif
(  526) # 527 ".D[15]/ecsort_shared.h"
(  527)   if (LLadjusted .and. imethod /= imethod_rest) then ! Restore back immediately
(  528)     if (LLdebug) write(0,1000) '<3a>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  529)     call adjust_index(iindex, +1) ! C -> Fortran
(  530)     if (LLdebug) write(0,1000) '<4a>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  531)     LLadjusted = .FALSE.
(  532)   endif
(  533) # 534 ".D[15]/ecsort_shared.h"
(  534)   imethod = imethod_rest
(  535) enddo KEYLOOP
(  536) # 537 ".D[15]/ecsort_shared.h"
(  537) deallocate(ikeys)
(  538) if (allocated(ista)) deallocate(ista)
(  539) if (allocated(ichunk)) deallocate(ichunk)
(  540) if (allocated(irank)) deallocate(irank)
(  541) # 542 ".D[15]/ecsort_shared.h"
(  542) if (LLadjusted) then ! Restore back
(  543)   if (LLdebug) write(0,1000) '<3b>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  544)   call adjust_index(iindex, +1) ! C -> Fortran
(  545)   if (LLdebug) write(0,1000) '<4b>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  546)   LLadjusted = .FALSE.
(  547) endif
(  548) # 549 ".D[15]/ecsort_shared.h"
(  549) if (LLdebug) write(0,1000) '<END>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  550) if (LLdebug) CALL INT4_DBGPRINT(0,'<END>',a,iindex,n,ilastkey,1,n,0)
(  551) # 552 ".D[15]/ecsort_shared.h"
(  552) if (.not.present(index)) then






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 21

(  553)   LLomp_okay = (nomp >= inumt .and. n >= nomp)
(  554)   if (istride == 1) then
(  555)     LLomp_okay = (LLomp_okay .and. sda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  556) !$OMP PARALLEL PRIVATE(j,data) IF (LLomp_okay)
(  557)     allocate(data(n))
(  558) !$OMP DO SCHEDULE(DYNAMIC,1)
(  559)     do j=1,sda
(  560)       data(1:n) = a(iindex(1:n),j)
(  561)       a(1:n,j) = data(1:n)
(  562)     enddo
(  563) !$OMP END DO
(  564)     deallocate(data)
(  565) !$OMP END PARALLEL
(  566)   else
(  567)     LLomp_okay = (LLomp_okay .and. lda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  568) !$OMP PARALLEL PRIVATE(i,data) IF (LLomp_okay)
(  569)     allocate(data(n))
(  570) !$OMP DO SCHEDULE(DYNAMIC,1)
(  571)     do i=1,lda
(  572)       data(1:n) = a(i,iindex(1:n))
(  573)       a(i,1:n) = data(1:n)
(  574)     enddo
(  575) !$OMP END DO
(  576)     deallocate(data)
(  577) !$OMP END PARALLEL
(  578)   endif
(  579) # 580 ".D[15]/ecsort_shared.h"
(  580)   deallocate(iindex)
(  581) endif
(  582) # 583 ".D[15]/ecsort_shared.h"
(  583) 99 continue
(  584) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_KEYSORT_2D',1,ZHOOK_HANDLE,n*inumkeys)
(  585) END SUBROUTINE
(  586) # 587 ".D[15]/ecsort_shared.h"
(  587) !-----------------------------
(  588) !--   Private subroutines   --
(  589) !-----------------------------
(  590) # 591 ".D[15]/ecsort_shared.h"
(  591) SUBROUTINE INT4_DBGPRINT(jj, cdstr, a, index, n, key, k1, k2, kadd)
(  592) character(len=*), intent(in) :: cdstr
(  593) INTEGER(KIND=JPIM), intent(in) :: jj, n, key, k1, k2, kadd
(  594) INTEGER(KIND=JPIM), intent(in) :: index(:)
(  595) INTEGER(KIND=JPIM), intent(in) :: a(:,:)
(  596) INTEGER(KIND=JPIM) :: i,j
(  597) 1000 FORMAT(i3,a,5i5)
(  598) 1011 FORMAT((5i12)) ! integer*4
(  599) 1012 FORMAT(1p,(5g20.12)) ! real*8
(  600) 1013 FORMAT(1p,(5g20.12)) ! real*4
(  601) 1014 FORMAT((5i12)) ! integer*8
(  602) WRITE(0,1000) jj,cdstr//': n,key,k1,k2,kadd,a(index(k1:k2)+kadd,:)=',&
(  603)      &                     n,key,k1,k2,kadd
(  604) do j=k1,k2
(  605)   i = index(j)+kadd
(  606)   WRITE(0,'(2i6)',advance='no') j,i-kadd
(  607)   WRITE(0,1011) a(i,:)
(  608) enddo
(  609) END SUBROUTINE
(  610) # 611 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 22

(  611) SUBROUTINE INT4_HEAPSORT(id, n, a, rc, irev, istride, index)
(  612) INTEGER(KIND=JPIM), intent(in) :: id, n, irev, istride
(  613) INTEGER(KIND=JPIM), intent(in) :: a(:)
(  614) INTEGER(KIND=JPIM), intent(out) :: rc
(  615) INTEGER(KIND=JPIM), intent(inout) :: index(:)
(  616) INTEGER(KIND=JPIM) :: i,j,right,left,idx
(  617) INTEGER(KIND=JPIM) :: tmp
(  618) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  619) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_HEAPSORT',0,ZHOOK_HANDLE)
(  620) rc = 0
(  621) if (n <= 0 .or. size(a) <= 0) goto 99
(  622) left  = n/2+1
(  623) right = n
(  624) LOOP: do
(  625)   if (left > 1) then
(  626)     left = left - 1
(  627)     idx  = index(left)
(  628)   else
(  629)     idx = index(right)
(  630)     index(right) = index(1)
(  631)     right = right - 1
(  632)     if (right == 1) then
(  633)       index(1) = idx
(  634)       exit LOOP
(  635)     endif
(  636)   endif
(  637)   tmp = a(idx)
(  638)   i = left
(  639)   j = 2*left
(  640)   do while (j <= right)
(  641)     if (j < right) then
(  642)       if (a(index(j)) < a(index(j+1))) j = j + 1
(  643)     endif
(  644)     if (tmp < a(index(j))) then
(  645)       index(i) = index(j)
(  646)       i = j
(  647)       j = 2*j
(  648)     else
(  649)       j = right + 1
(  650)     endif
(  651)   enddo
(  652)   index(i) = idx
(  653) enddo LOOP
(  654) rc = n
(  655) 99 continue
(  656) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT4_HEAPSORT',1,ZHOOK_HANDLE)
(  657) END SUBROUTINE
(  658) # 306 "ecsort_mix.F90"
(  306) # 309 "ecsort_mix.F90"
(  309) !-- Create version for INTEGER(KIND=JPIB)
(  310) # 312 "ecsort_mix.F90"
(  312) # 1 ".D[15]/ecsort_shared.h"
(    1) !*** ecsort_shared.h ***
(    2) # 85 ".D[15]/ecsort_shared.h"
(   85) !----------------------------
(   86) !--   Public subroutines   --
(   87) !----------------------------
(   88) # 90 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 23

(   90) SUBROUTINE INT8_KEYSORT_1D(rc, a, n, method, descending, index, init)
(   91) !-- Please note that we assume that a(:) occupies consecutive memory locations
(   92) INTEGER(KIND=JPIM), intent(out)           :: rc
(   93) INTEGER(KIND=JPIB)         , intent(inout)         :: a(:)
(   94) INTEGER(KIND=JPIM), intent(in)            :: n
(   95) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: method
(   96) logical, intent(in), OPTIONAL  :: descending
(   97) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(   98) logical, intent(in), OPTIONAL  :: init
(   99) ! === END OF INTERFACE BLOCK ===
(  100) INTEGER(KIND=JPIB)          , allocatable :: aa(:,:)
(  101) INTEGER(KIND=JPIM) :: imethod, irev, idummy, index_adj
(  102) logical :: LLfast, LLdescending, LLomp_okay, LLinit
(  103) INTEGER(KIND=JPIM) :: ITID, ichunk, iret, inumt
(  104) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  105) # 106 ".D[15]/ecsort_shared.h"
(  106) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_KEYSORT_1D',0,ZHOOK_HANDLE)
(  107) # 108 ".D[15]/ecsort_shared.h"
(  108) rc = 0
(  109) if (n <= 0 .or. size(a) <= 0) goto 99
(  110) # 111 ".D[15]/ecsort_shared.h"
(  111) if (present(descending)) then
(  112)   LLdescending = descending
(  113) else
(  114)   LLdescending = .FALSE.
(  115) endif
(  116) # 117 ".D[15]/ecsort_shared.h"
(  117) irev = 0
(  118) if (LLdescending) irev = 1
(  119) # 120 ".D[15]/ecsort_shared.h"
(  120) ITID = OML_MY_THREAD()
(  121) imethod = current_method(ITID)
(  122) if (present(method)) then
(  123)   imethod = min(max(min_method,method),max_method)
(  124) endif
(  125) # 126 ".D[15]/ecsort_shared.h"
(  126) if (imethod /= quicksort_method .and. &
(  127)    &imethod /= countingsort_method) then
(  128)   LLfast = .FALSE.
(  129) else if (imethod == quicksort_method) then
(  130)   !-- hasn't been implemented if index is present ;-(
(  131)   LLfast = (&
(  132)        & .not.present(index) .and. &
(  133)        & .not.present(init))
(  134) else if (imethod == countingsort_method) then
(  135)   !-- index-presence is ok
(  136)   LLfast = .TRUE.
(  137) endif
(  138) # 139 ".D[15]/ecsort_shared.h"
(  139) if (LLfast) then
(  140)   !- Only Quick-sort & CountingSort covered
(  141) # 142 ".D[15]/ecsort_shared.h"
(  142)   if (imethod == quicksort_method) then
(  143)     inumt = OML_MAX_THREADS()
(  144)     LLomp_okay = (inumt > 1 .and. nomp >= inumt .and. n >= nomp)
(  145)     LLomp_okay = (LLomp_okay .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  146)     if (LLomp_okay) then
(  147)       !-- Max 2-way OpenMP parallelism for now ...






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 24

(  148)       ichunk = n/2
(  149) !$OMP PARALLEL PRIVATE(iret)
(  150) !$OMP SECTIONS
(  151) !$OMP SECTION
(  152)       CALL ecqsortfast(14, ichunk, a(1), irev, iret)
(  153) !$OMP SECTION
(  154)       CALL ecqsortfast(14, n-ichunk, a(ichunk+1), irev, iret)
(  155) !$OMP END SECTIONS
(  156) !$OMP END PARALLEL
(  157)       CALL ecmerge2(14, 1, ichunk, n-ichunk, a(1), &
(  158)            & idummy, 0, 1, irev, idummy, rc)
(  159)     else
(  160)       CALL ecqsortfast(14, n, a(1), irev, rc)
(  161)     endif
(  162)     GOTO 99
(  163) # 164 ".D[15]/ecsort_shared.h"
(  164)   else if (imethod == countingsort_method) then
(  165)     if (.not.present(index)) then
(  166)       CALL ec_countingsort(14, n, 1, 1, a(1), idummy, 0, 1, irev, rc)
(  167)     else
(  168)       LLinit = .FALSE.
(  169)       if (present(init)) LLinit = init
(  170)       if (LLinit) then
(  171)         CALL init_index(index, index_adj=-1)
(  172)         index_adj = 0
(  173)       else
(  174)         index_adj = 1
(  175)       endif
(  176)       CALL ec_countingsort(14, n, 1, 1, a(1), index(1), size(index), index_adj, irev, rc)
(  177)       if (index_adj == 0) CALL adjust_index(index, +1)
(  178)     endif
(  179)     GOTO 99
(  180) # 181 ".D[15]/ecsort_shared.h"
(  181)   else
(  182)     LLfast = .false.
(  183)   endif
(  184) endif
(  185) # 186 ".D[15]/ecsort_shared.h"
(  186) !-- LLfast == .FALSE. :
(  187) # 188 ".D[15]/ecsort_shared.h"
(  188) allocate(aa(n,1))
(  189) # 190 ".D[15]/ecsort_shared.h"
(  190) if (LLdescending) then
(  191)   aa(1:n,1) = -a(1:n)
(  192) else
(  193)   aa(1:n,1) = a(1:n)
(  194) endif
(  195) # 196 ".D[15]/ecsort_shared.h"
(  196) CALL keysort(rc, aa, n, method=method, index=index, init=init)
(  197) # 198 ".D[15]/ecsort_shared.h"
(  198) if (LLdescending) then
(  199)   a(1:n) = -aa(1:n,1)
(  200) else
(  201)   a(1:n) = aa(1:n,1)
(  202) endif
(  203) # 204 ".D[15]/ecsort_shared.h"
(  204) deallocate(aa)
(  205) # 206 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 25

(  206) 99 continue
(  207) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_KEYSORT_1D',1,ZHOOK_HANDLE,n)
(  208) END SUBROUTINE
(  209) # 211 ".D[15]/ecsort_shared.h"
(  211) SUBROUTINE INT8_KEYSORT_2D(&
(  212)      &rc, a, n,&
(  213)      &key, multikey, method,&
(  214)      &index, init, transposed)
(  215) # 216 ".D[15]/ecsort_shared.h"
(  216) INTEGER(KIND=JPIM), intent(out)           :: rc
(  217) INTEGER(KIND=JPIB)         , intent(inout)         :: a(:,:)
(  218) INTEGER(KIND=JPIM), intent(in)            :: n
(  219) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: key, method
(  220) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: multikey(:)
(  221) logical, intent(in), OPTIONAL  :: transposed
(  222) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(  223) logical, intent(in), OPTIONAL  :: init
(  224) ! === END OF INTERFACE BLOCK ===
(  225) INTEGER(KIND=JPIM), POINTER :: iindex(:)
(  226) INTEGER(KIND=JPIM) :: ikey, istride, imethod, inumkeys, imethod_1st, imethod_rest
(  227) INTEGER(KIND=JPIM) :: lda, iptr, i, j, sda, idiff, irev, inumt, jkey, jj, ilastkey
(  228) INTEGER(KIND=JPIM) :: j1, j2, jmid, inum, imax, iadd, imod, iret, inc, iamax, ibmax
(  229) INTEGER(KIND=JPIB)         , allocatable :: data(:)
(  230) INTEGER(KIND=JPIM), allocatable :: ikeys(:), ista(:), ichunk(:), irank(:)
(  231) logical LLinit, LLdescending, LLtrans, LLomp_okay, LLadjusted, LLdebug, LLomp_prefix
(  232) character(len=1) clenv
(  233) REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_SUBHANDLE
(  234) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE0
(  235) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE1
(  236) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE2
(  237) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE3
(  238) INTEGER(KIND=JPIM) :: ITID
(  239) # 240 ".D[15]/ecsort_shared.h"
(  240) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_KEYSORT_2D',0,ZHOOK_HANDLE)
(  241) # 242 ".D[15]/ecsort_shared.h"
(  242) rc = 0
(  243) lda = size(a, dim=1)
(  244) sda = size(a, dim=2)
(  245) if (n <= 0 .or. lda <= 0 .or. sda <= 0) goto 99
(  246) # 247 ".D[15]/ecsort_shared.h"
(  247) inumt = OML_MAX_THREADS()
(  248) ITID = OML_MY_THREAD()
(  249) imethod = current_method(ITID)
(  250) if (present(method)) then
(  251)   imethod = min(max(min_method,method),max_method)
(  252) endif
(  253) imethod_1st = imethod
(  254) imethod_rest = imethod
(  255) # 256 ".D[15]/ecsort_shared.h"
(  256) ikey = 1
(  257) if (present(key)) ikey = key
(  258) # 259 ".D[15]/ecsort_shared.h"
(  259) if (present(multikey)) then
(  260)   allocate(ikeys(size(multikey)))
(  261)   ikeys(:) = multikey(:)
(  262) else
(  263)   allocate(ikeys(1))
(  264)   ikeys(1) = ikey






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 26

(  265) endif
(  266) inumkeys = size(ikeys)
(  267) # 268 ".D[15]/ecsort_shared.h"
(  268) !-- Only the RADIX-sort & now also QUICK-sort & CountingSort give the result we want with multiple keys
(  269) if (inumkeys > 1 .and. &
(  270)     imethod /= radixsort_method .and. &
(  271)     imethod /= quicksort_method .and. &
(  272)     imethod /= countingsort_method) then
(  273)    imethod = default_method
(  274)    imethod_1st = imethod
(  275)    imethod_rest = imethod
(  276)    !-- Since "default_method" may now be [overridden as] HEAP-sort, make sure its then "radixsort_method"
(  277)    !   Note: The first sweep may still be e.g. HEAP-sort
(  278)    if (imethod /= radixsort_method .and. &
(  279)        imethod /= quicksort_method .and. &
(  280)        imethod /= countingsort_method) then
(  281)      imethod = radixsort_method
(  282)      imethod_rest = imethod
(  283)    endif
(  284) endif
(  285) # 286 ".D[15]/ecsort_shared.h"
(  286) LLinit = .FALSE.
(  287) if (present(init)) LLinit = init
(  288) # 289 ".D[15]/ecsort_shared.h"
(  289) if (present(index)) then
(  290)   iindex => index(1:n)
(  291) else
(  292)   allocate(iindex(n))
(  293)   LLinit = .TRUE.
(  294) endif
(  295) # 296 ".D[15]/ecsort_shared.h"
(  296) if (LLinit) CALL init_index(iindex)
(  297) # 298 ".D[15]/ecsort_shared.h"
(  298) istride = 1
(  299) LLtrans = .FALSE.
(  300) if (present(transposed)) LLtrans = transposed
(  301) if (LLtrans) then
(  302)   istride = lda
(  303) else if (sda >= 2 .and. lda >= 1) then
(  304) !-- Check for presence of sub-array and adjust lda automatically
(  305)   call addrdiff(a(1,1),a(1,2),idiff)
(  306)   ! lda below: The true leading dimension; overrides sub-arrays one
(  307)   lda = idiff/sizeof_int8
(  308) endif
(  309) # 310 ".D[15]/ecsort_shared.h"
(  310) ilastkey = 0
(  311) LLadjusted = .FALSE.
(  312) LLomp_prefix = .FALSE.
(  313) !$ LLomp_prefix = (istride == 1 .and. nomp >= inumt .and. n >= nomp)
(  314) if (LLomp_prefix) then
(  315)   call get_environment_variable('EC_SORTING_DEBUG',clenv)
(  316)   LLdebug = (clenv == '1' .and. n < 10000)
(  317)   if (LLdebug) write(0,*)'>> EC_SORTING_DEBUG=1'
(  318) else
(  319)   LLdebug = .FALSE.
(  320) endif
(  321) # 322 ".D[15]/ecsort_shared.h"
(  322) 1000 format(1x,a,2i12,:,/,(10i5))






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 27

(  323) 1001 format(1x,'[#',i2,']:',a,(10i5))
(  324) 1002 format(1x,'[#',i2,']:',a,:,/,(10i5))
(  325) 1003 format(1x,'[#',i2,']:',a,2i12,:,/,(10i5))
(  326) 1004 format(1x,a,:,(10i5))
(  327) 1005 format(1x,a,i2,1x,a)
(  328) # 329 ".D[15]/ecsort_shared.h"
(  329) imethod = imethod_1st
(  330) KEYLOOP: do jkey=inumkeys,1,-1
(  331) !--   Sort by the least significant key first
(  332)   ikey = abs(ikeys(jkey))
(  333)   if (ikey == 0) cycle KEYLOOP
(  334) # 335 ".D[15]/ecsort_shared.h"
(  335)   if (istride == 1) then
(  336)     iptr = lda * (ikey - 1) + 1
(  337)   else
(  338)     iptr = ikey
(  339)   endif
(  340) # 341 ".D[15]/ecsort_shared.h"
(  341)   if (LLdebug) then
(  342)     write(0,1000) '<BEGIN>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  343)     if (LLadjusted) then
(  344)       CALL INT8_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,1)
(  345)     else
(  346)       CALL INT8_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,0)
(  347)     endif
(  348)     ilastkey = ikey
(  349)   endif
(  350) # 351 ".D[15]/ecsort_shared.h"
(  351)   LLdescending = (ikeys(jkey) < 0)
(  352)   irev = 0
(  353)   if (LLdescending) irev = 1
(  354) # 355 ".D[15]/ecsort_shared.h"
(  355)   !-- Since "irev" is passed into the ecqsort, no explicit reversing is needed --> savings
(  356)   if (imethod == quicksort_method .or. &
(  357)       imethod == countingsort_method) LLdescending = .FALSE.
(  358) # 359 ".D[15]/ecsort_shared.h"
(  359)   if (LLdescending) then
(  360)     if (istride == 1) then
(  361)       a(1:n,ikey) = -a(1:n,ikey)
(  362)     else
(  363)       a(ikey,1:n) = -a(ikey,1:n)
(  364)     endif
(  365)     irev = 0 ! prevents use of "reverse" algorithm in ecmerge2 for radix-sort
(  366)   endif
(  367) # 368 ".D[15]/ecsort_shared.h"
(  368)   LLomp_okay = LLomp_prefix .and. (inumt > 1) .and. (&
(  369)        & imethod == radixsort_method .or. &
(  370)        & imethod == quicksort_method .or. &
(  371)        & imethod == countingsort_method)
(  372)   LLomp_okay = LLomp_okay .and. (.not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  373) # 374 ".D[15]/ecsort_shared.h"
(  374)   if (.not.LLomp_okay) then
(  375)     select case (imethod)
(  376)     case (radixsort_method)
(  377)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_14',0,ZHOOK_SUBHANDLE0)
(  378) # 379 ".D[15]/ecsort_shared.h"
(  379)       CALL rsort64(14, n, istride, iptr, a(1,1), iindex(1), 1, rc)
(  380) # 383 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 28

(  383)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_14',1,ZHOOK_SUBHANDLE0, n)
(  384)     case (heapsort_method)
(  385)       if (istride == 1) then
(  386)         CALL INT8_HEAPSORT(14, n, a(1:n, ikey), rc, irev, istride, iindex)
(  387)       else
(  388)         CALL INT8_HEAPSORT(14, n, a(ikey, 1:n), rc, irev, istride, iindex)
(  389)       endif
(  390)     case (quicksort_method)
(  391)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_ECQSORT',0,ZHOOK_SUBHANDLE0)
(  392)       CALL ecqsort(14, n, istride, iptr, a(1,1), iindex(1), 1, irev, rc)
(  393)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_ECQSORT',1,ZHOOK_SUBHANDLE0,n)
(  394)     case (countingsort_method)
(  395)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_COUNT',0,ZHOOK_SUBHANDLE0)
(  396)       CALL ec_countingsort(14, n, istride, iptr, a(1,1), iindex(1), n, 1, irev, rc)
(  397)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_COUNT',1,ZHOOK_SUBHANDLE0,n)
(  398)     case (gnomesort_method)
(  399)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_GNOME',0,ZHOOK_SUBHANDLE0)
(  400)       CALL ecgnomesort(14, n, istride, iptr, a(1,1), iindex(1), n, 1, rc)
(  401)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_GNOME',1,ZHOOK_SUBHANDLE0,n)
(  402)     end select
(  403) # 404 ".D[15]/ecsort_shared.h"
(  404)   else ! i.e. LLomp_okay ; radix, quick & counting -sorts only
(  405)     if (.not.allocated(ista)) then
(  406)       allocate(ista(inumt+1),ichunk(inumt))
(  407)       inc = n/inumt
(  408)       iadd = 1
(  409)       imod = mod(n,inumt)
(  410)       if (imod == 0) iadd = 0
(  411)       ista(1) = 1
(  412)       do j=2,inumt
(  413)         ista(j) = ista(j-1) + inc + iadd
(  414)         if (iadd > 0 .and. j > imod) iadd = 0
(  415)       enddo
(  416)       ista(inumt+1) = n + 1
(  417)       do j=1,inumt
(  418)         ichunk(j) = ista(j+1) - ista(j)
(  419)       enddo
(  420)       if (LLdebug) then
(  421)         write(0,1005) '>> imethod,name=',imethod,method_name(imethod)
(  422)         write(0,1004) '>> inumt,n,nomp=',inumt,n,nomp
(  423)         write(0,1004) '>> ista(1:inumt+1)=',ista(1:inumt+1)
(  424)         write(0,1004) '>> ichunk(1:inumt)=',ichunk(1:inumt)
(  425)       endif
(  426)       allocate(irank(n))
(  427)     endif
(  428) # 429 ".D[15]/ecsort_shared.h"
(  429)     if (LLdebug) write(0,1004) '>>KEYLOOP: jkey,ikey,irev,iptr=',jkey,ikey,irev,iptr
(  430) # 431 ".D[15]/ecsort_shared.h"
(  431)     if (.not.LLadjusted) then ! only once
(  432)       if (LLdebug) write(0,1000) '<1>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  433)       call adjust_index(iindex, -1) ! Fortran -> C
(  434)       if (LLdebug) write(0,1000) '<2>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  435)       LLadjusted = .TRUE.
(  436)     endif
(  437) # 438 ".D[15]/ecsort_shared.h"
(  438)     if (LLdebug) write(0,*)'>> Sorting inumt-chunks in parallel'
(  439) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iret,inc,ITID,ZHOOK_SUBHANDLE1,ZHOOK_SUBHANDLE2)
(  440)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',0,ZHOOK_SUBHANDLE1)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 29

(  441)     ITID = OML_MY_THREAD()
(  442) !$OMP DO SCHEDULE(DYNAMIC,1)
(  443)     do j=1,inumt
(  444)       j1 = ista(j)
(  445)       inum = ichunk(j)
(  446)       j2 = j1 + inum - 1
(  447)       inc = j1
(  448)       if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum,inc=',j,j1,j2,inum,inc
(  449)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  450)       select case (imethod)
(  451)       case (radixsort_method)
(  452)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_14',0,ZHOOK_SUBHANDLE2)
(  453) # 454 ".D[15]/ecsort_shared.h"
(  454)         CALL rsort64(14, inum, istride, iptr, a(1,1), iindex(j1), 0, iret)
(  455) # 458 ".D[15]/ecsort_shared.h"
(  458)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_14',1,ZHOOK_SUBHANDLE2, inum)
(  459)       case (quicksort_method)
(  460)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_ECQSORT',0,ZHOOK_SUBHANDLE2)
(  461)         CALL ecqsort(14, inum, istride, iptr, a(1,1), iindex(j1), 0, irev, iret)
(  462)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_ECQSORT',1,ZHOOK_SUBHANDLE2,inum)
(  463)       case (countingsort_method)
(  464)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_COUNT',0,ZHOOK_SUBHANDLE2)
(  465)         CALL ec_countingsort(14, inum, istride, iptr, a(1,1), iindex(j1), inum, 0, irev, iret)
(  466)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_COUNT',1,ZHOOK_SUBHANDLE2,inum)
(  467)       end select
(  468)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  469)     enddo
(  470) !$OMP END DO
(  471)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',1,ZHOOK_SUBHANDLE1)
(  472) !$OMP END PARALLEL
(  473) # 474 ".D[15]/ecsort_shared.h"
(  474)     if (LLdebug) write(0,1000) '<after_sort>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  475)     if (LLdebug) CALL INT8_DBGPRINT(0,'<after_sort>',a,iindex,n,ikey,1,n,1)
(  476)     CALL get_rank(iindex, irank, index_adj=+1)
(  477) # 478 ".D[15]/ecsort_shared.h"
(  478)     if (LLdebug) write(0,*) '>> Merge neighbouring chunks in parallel as much as possible'
(  479)     inc = 2
(  480)     imax = (inumt+inc-1)/inc
(  481)     do jj=1,imax
(  482)       if (LLdebug) write(0,1001) jj,'<before_merge> jj,inc,imax,inumt=',jj,inc,imax,inumt
(  483) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iamax,ibmax,jmid,iret,ZHOOK_SUBHANDLE3,ITID)
(  484)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',0,ZHOOK_SUBHANDLE3)
(  485)       ITID = OML_MY_THREAD()
(  486) !$OMP DO SCHEDULE(DYNAMIC,1)
(  487)       do j=1,inumt,inc
(  488)         j1 = j
(  489)         j2 = j + inc - 1
(  490)         jmid = (j1 + j2)/2 + 1
(  491)         j2 = min(j2,inumt)
(  492)         jmid = min(jmid,inumt)
(  493)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,jmid=',j,j1,j2,jmid
(  494)         iamax = ista(jmid) - ista(j1)
(  495)         inum = sum(ichunk(j1:j2))
(  496)         ibmax = inum - iamax
(  497)         if (LLdebug) write(0,1001) ITID,'j,iamax,ibmax,inum=',j,iamax,ibmax,inum
(  498)         if (iamax == 0 .or. ibmax == 0 .or. inum == 0) cycle
(  499)         j1 = ista(j1)
(  500)         j2 = ista(j2+1) - 1






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 30

(  501)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum=',j,j1,j2,inum
(  502)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  503)         call ecmerge2(14, iptr, iamax, ibmax, a(1,1), &
(  504)              & iindex(j1), inum, 0, irev, irank(1), iret)
(  505)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  506)       enddo ! do j=1,inumt,inc
(  507) !$OMP END DO
(  508)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',1,ZHOOK_SUBHANDLE3)
(  509) !$OMP END PARALLEL
(  510) # 511 ".D[15]/ecsort_shared.h"
(  511)       if (LLdebug) write(0,1003) jj,'<after_merge>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  512)       if (LLdebug) CALL INT8_DBGPRINT(jj,'<after_merge>',a,iindex,n,ikey,1,n,1)
(  513) # 514 ".D[15]/ecsort_shared.h"
(  514)       inc = inc * 2
(  515)     enddo ! do jj=1,imax
(  516)     rc = n
(  517)   endif ! if (LLomp_okay)
(  518) # 519 ".D[15]/ecsort_shared.h"
(  519)   if (LLdescending) then
(  520)     if (istride == 1) then
(  521)       a(1:n,ikey) = -a(1:n,ikey)
(  522)     else
(  523)       a(ikey,1:n) = -a(ikey,1:n)
(  524)     endif
(  525)   endif
(  526) # 527 ".D[15]/ecsort_shared.h"
(  527)   if (LLadjusted .and. imethod /= imethod_rest) then ! Restore back immediately
(  528)     if (LLdebug) write(0,1000) '<3a>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  529)     call adjust_index(iindex, +1) ! C -> Fortran
(  530)     if (LLdebug) write(0,1000) '<4a>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  531)     LLadjusted = .FALSE.
(  532)   endif
(  533) # 534 ".D[15]/ecsort_shared.h"
(  534)   imethod = imethod_rest
(  535) enddo KEYLOOP
(  536) # 537 ".D[15]/ecsort_shared.h"
(  537) deallocate(ikeys)
(  538) if (allocated(ista)) deallocate(ista)
(  539) if (allocated(ichunk)) deallocate(ichunk)
(  540) if (allocated(irank)) deallocate(irank)
(  541) # 542 ".D[15]/ecsort_shared.h"
(  542) if (LLadjusted) then ! Restore back
(  543)   if (LLdebug) write(0,1000) '<3b>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  544)   call adjust_index(iindex, +1) ! C -> Fortran
(  545)   if (LLdebug) write(0,1000) '<4b>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  546)   LLadjusted = .FALSE.
(  547) endif
(  548) # 549 ".D[15]/ecsort_shared.h"
(  549) if (LLdebug) write(0,1000) '<END>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  550) if (LLdebug) CALL INT8_DBGPRINT(0,'<END>',a,iindex,n,ilastkey,1,n,0)
(  551) # 552 ".D[15]/ecsort_shared.h"
(  552) if (.not.present(index)) then
(  553)   LLomp_okay = (nomp >= inumt .and. n >= nomp)
(  554)   if (istride == 1) then
(  555)     LLomp_okay = (LLomp_okay .and. sda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  556) !$OMP PARALLEL PRIVATE(j,data) IF (LLomp_okay)
(  557)     allocate(data(n))
(  558) !$OMP DO SCHEDULE(DYNAMIC,1)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 31

(  559)     do j=1,sda
(  560)       data(1:n) = a(iindex(1:n),j)
(  561)       a(1:n,j) = data(1:n)
(  562)     enddo
(  563) !$OMP END DO
(  564)     deallocate(data)
(  565) !$OMP END PARALLEL
(  566)   else
(  567)     LLomp_okay = (LLomp_okay .and. lda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  568) !$OMP PARALLEL PRIVATE(i,data) IF (LLomp_okay)
(  569)     allocate(data(n))
(  570) !$OMP DO SCHEDULE(DYNAMIC,1)
(  571)     do i=1,lda
(  572)       data(1:n) = a(i,iindex(1:n))
(  573)       a(i,1:n) = data(1:n)
(  574)     enddo
(  575) !$OMP END DO
(  576)     deallocate(data)
(  577) !$OMP END PARALLEL
(  578)   endif
(  579) # 580 ".D[15]/ecsort_shared.h"
(  580)   deallocate(iindex)
(  581) endif
(  582) # 583 ".D[15]/ecsort_shared.h"
(  583) 99 continue
(  584) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_KEYSORT_2D',1,ZHOOK_HANDLE,n*inumkeys)
(  585) END SUBROUTINE
(  586) # 587 ".D[15]/ecsort_shared.h"
(  587) !-----------------------------
(  588) !--   Private subroutines   --
(  589) !-----------------------------
(  590) # 591 ".D[15]/ecsort_shared.h"
(  591) SUBROUTINE INT8_DBGPRINT(jj, cdstr, a, index, n, key, k1, k2, kadd)
(  592) character(len=*), intent(in) :: cdstr
(  593) INTEGER(KIND=JPIM), intent(in) :: jj, n, key, k1, k2, kadd
(  594) INTEGER(KIND=JPIM), intent(in) :: index(:)
(  595) INTEGER(KIND=JPIB), intent(in) :: a(:,:)
(  596) INTEGER(KIND=JPIM) :: i,j
(  597) 1000 FORMAT(i3,a,5i5)
(  598) 1011 FORMAT((5i12)) ! integer*4
(  599) 1012 FORMAT(1p,(5g20.12)) ! real*8
(  600) 1013 FORMAT(1p,(5g20.12)) ! real*4
(  601) 1014 FORMAT((5i12)) ! integer*8
(  602) WRITE(0,1000) jj,cdstr//': n,key,k1,k2,kadd,a(index(k1:k2)+kadd,:)=',&
(  603)      &                     n,key,k1,k2,kadd
(  604) do j=k1,k2
(  605)   i = index(j)+kadd
(  606)   WRITE(0,'(2i6)',advance='no') j,i-kadd
(  607)   WRITE(0,1014) a(i,:)
(  608) enddo
(  609) END SUBROUTINE
(  610) # 611 ".D[15]/ecsort_shared.h"
(  611) SUBROUTINE INT8_HEAPSORT(id, n, a, rc, irev, istride, index)
(  612) INTEGER(KIND=JPIM), intent(in) :: id, n, irev, istride
(  613) INTEGER(KIND=JPIB), intent(in) :: a(:)
(  614) INTEGER(KIND=JPIM), intent(out) :: rc
(  615) INTEGER(KIND=JPIM), intent(inout) :: index(:)
(  616) INTEGER(KIND=JPIM) :: i,j,right,left,idx






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 32

(  617) INTEGER(KIND=JPIB) :: tmp
(  618) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  619) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_HEAPSORT',0,ZHOOK_HANDLE)
(  620) rc = 0
(  621) if (n <= 0 .or. size(a) <= 0) goto 99
(  622) left  = n/2+1
(  623) right = n
(  624) LOOP: do
(  625)   if (left > 1) then
(  626)     left = left - 1
(  627)     idx  = index(left)
(  628)   else
(  629)     idx = index(right)
(  630)     index(right) = index(1)
(  631)     right = right - 1
(  632)     if (right == 1) then
(  633)       index(1) = idx
(  634)       exit LOOP
(  635)     endif
(  636)   endif
(  637)   tmp = a(idx)
(  638)   i = left
(  639)   j = 2*left
(  640)   do while (j <= right)
(  641)     if (j < right) then
(  642)       if (a(index(j)) < a(index(j+1))) j = j + 1
(  643)     endif
(  644)     if (tmp < a(index(j))) then
(  645)       index(i) = index(j)
(  646)       i = j
(  647)       j = 2*j
(  648)     else
(  649)       j = right + 1
(  650)     endif
(  651)   enddo
(  652)   index(i) = idx
(  653) enddo LOOP
(  654) rc = n
(  655) 99 continue
(  656) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:INT8_HEAPSORT',1,ZHOOK_HANDLE)
(  657) END SUBROUTINE
(  658) # 313 "ecsort_mix.F90"
(  313) # 316 "ecsort_mix.F90"
(  316) !-- Create version for REAL(KIND=JPRM)
(  317) # 319 "ecsort_mix.F90"
(  319) # 1 ".D[15]/ecsort_shared.h"
(    1) !*** ecsort_shared.h ***
(    2) # 85 ".D[15]/ecsort_shared.h"
(   85) !----------------------------
(   86) !--   Public subroutines   --
(   87) !----------------------------
(   88) # 90 ".D[15]/ecsort_shared.h"
(   90) SUBROUTINE REAL4_KEYSORT_1D(rc, a, n, method, descending, index, init)
(   91) !-- Please note that we assume that a(:) occupies consecutive memory locations
(   92) INTEGER(KIND=JPIM), intent(out)           :: rc
(   93) REAL(KIND=JPRM)         , intent(inout)         :: a(:)
(   94) INTEGER(KIND=JPIM), intent(in)            :: n
(   95) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: method






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 33

(   96) logical, intent(in), OPTIONAL  :: descending
(   97) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(   98) logical, intent(in), OPTIONAL  :: init
(   99) ! === END OF INTERFACE BLOCK ===
(  100) REAL(KIND=JPRM)          , allocatable :: aa(:,:)
(  101) INTEGER(KIND=JPIM) :: imethod, irev, idummy, index_adj
(  102) logical :: LLfast, LLdescending, LLomp_okay, LLinit
(  103) INTEGER(KIND=JPIM) :: ITID, ichunk, iret, inumt
(  104) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  105) # 106 ".D[15]/ecsort_shared.h"
(  106) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_KEYSORT_1D',0,ZHOOK_HANDLE)
(  107) # 108 ".D[15]/ecsort_shared.h"
(  108) rc = 0
(  109) if (n <= 0 .or. size(a) <= 0) goto 99
(  110) # 111 ".D[15]/ecsort_shared.h"
(  111) if (present(descending)) then
(  112)   LLdescending = descending
(  113) else
(  114)   LLdescending = .FALSE.
(  115) endif
(  116) # 117 ".D[15]/ecsort_shared.h"
(  117) irev = 0
(  118) if (LLdescending) irev = 1
(  119) # 120 ".D[15]/ecsort_shared.h"
(  120) ITID = OML_MY_THREAD()
(  121) imethod = current_method(ITID)
(  122) if (present(method)) then
(  123)   imethod = min(max(min_method,method),max_method)
(  124) endif
(  125) # 126 ".D[15]/ecsort_shared.h"
(  126) if (imethod /= quicksort_method .and. &
(  127)    &imethod /= countingsort_method) then
(  128)   LLfast = .FALSE.
(  129) else if (imethod == quicksort_method) then
(  130)   !-- hasn't been implemented if index is present ;-(
(  131)   LLfast = (&
(  132)        & .not.present(index) .and. &
(  133)        & .not.present(init))
(  134) else if (imethod == countingsort_method) then
(  135)   !-- index-presence is ok
(  136)   LLfast = .TRUE.
(  137) endif
(  138) # 139 ".D[15]/ecsort_shared.h"
(  139) if (LLfast) then
(  140)   !- Only Quick-sort & CountingSort covered
(  141) # 142 ".D[15]/ecsort_shared.h"
(  142)   if (imethod == quicksort_method) then
(  143)     inumt = OML_MAX_THREADS()
(  144)     LLomp_okay = (inumt > 1 .and. nomp >= inumt .and. n >= nomp)
(  145)     LLomp_okay = (LLomp_okay .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  146)     if (LLomp_okay) then
(  147)       !-- Max 2-way OpenMP parallelism for now ...
(  148)       ichunk = n/2
(  149) !$OMP PARALLEL PRIVATE(iret)
(  150) !$OMP SECTIONS
(  151) !$OMP SECTION
(  152)       CALL ecqsortfast(13, ichunk, a(1), irev, iret)
(  153) !$OMP SECTION






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 34

(  154)       CALL ecqsortfast(13, n-ichunk, a(ichunk+1), irev, iret)
(  155) !$OMP END SECTIONS
(  156) !$OMP END PARALLEL
(  157)       CALL ecmerge2(13, 1, ichunk, n-ichunk, a(1), &
(  158)            & idummy, 0, 1, irev, idummy, rc)
(  159)     else
(  160)       CALL ecqsortfast(13, n, a(1), irev, rc)
(  161)     endif
(  162)     GOTO 99
(  163) # 164 ".D[15]/ecsort_shared.h"
(  164)   else if (imethod == countingsort_method) then
(  165)     if (.not.present(index)) then
(  166)       CALL ec_countingsort(13, n, 1, 1, a(1), idummy, 0, 1, irev, rc)
(  167)     else
(  168)       LLinit = .FALSE.
(  169)       if (present(init)) LLinit = init
(  170)       if (LLinit) then
(  171)         CALL init_index(index, index_adj=-1)
(  172)         index_adj = 0
(  173)       else
(  174)         index_adj = 1
(  175)       endif
(  176)       CALL ec_countingsort(13, n, 1, 1, a(1), index(1), size(index), index_adj, irev, rc)
(  177)       if (index_adj == 0) CALL adjust_index(index, +1)
(  178)     endif
(  179)     GOTO 99
(  180) # 181 ".D[15]/ecsort_shared.h"
(  181)   else
(  182)     LLfast = .false.
(  183)   endif
(  184) endif
(  185) # 186 ".D[15]/ecsort_shared.h"
(  186) !-- LLfast == .FALSE. :
(  187) # 188 ".D[15]/ecsort_shared.h"
(  188) allocate(aa(n,1))
(  189) # 190 ".D[15]/ecsort_shared.h"
(  190) if (LLdescending) then
(  191)   aa(1:n,1) = -a(1:n)
(  192) else
(  193)   aa(1:n,1) = a(1:n)
(  194) endif
(  195) # 196 ".D[15]/ecsort_shared.h"
(  196) CALL keysort(rc, aa, n, method=method, index=index, init=init)
(  197) # 198 ".D[15]/ecsort_shared.h"
(  198) if (LLdescending) then
(  199)   a(1:n) = -aa(1:n,1)
(  200) else
(  201)   a(1:n) = aa(1:n,1)
(  202) endif
(  203) # 204 ".D[15]/ecsort_shared.h"
(  204) deallocate(aa)
(  205) # 206 ".D[15]/ecsort_shared.h"
(  206) 99 continue
(  207) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_KEYSORT_1D',1,ZHOOK_HANDLE,n)
(  208) END SUBROUTINE
(  209) # 211 ".D[15]/ecsort_shared.h"
(  211) SUBROUTINE REAL4_KEYSORT_2D(&
(  212)      &rc, a, n,&






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 35

(  213)      &key, multikey, method,&
(  214)      &index, init, transposed)
(  215) # 216 ".D[15]/ecsort_shared.h"
(  216) INTEGER(KIND=JPIM), intent(out)           :: rc
(  217) REAL(KIND=JPRM)         , intent(inout)         :: a(:,:)
(  218) INTEGER(KIND=JPIM), intent(in)            :: n
(  219) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: key, method
(  220) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: multikey(:)
(  221) logical, intent(in), OPTIONAL  :: transposed
(  222) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(  223) logical, intent(in), OPTIONAL  :: init
(  224) ! === END OF INTERFACE BLOCK ===
(  225) INTEGER(KIND=JPIM), POINTER :: iindex(:)
(  226) INTEGER(KIND=JPIM) :: ikey, istride, imethod, inumkeys, imethod_1st, imethod_rest
(  227) INTEGER(KIND=JPIM) :: lda, iptr, i, j, sda, idiff, irev, inumt, jkey, jj, ilastkey
(  228) INTEGER(KIND=JPIM) :: j1, j2, jmid, inum, imax, iadd, imod, iret, inc, iamax, ibmax
(  229) REAL(KIND=JPRM)         , allocatable :: data(:)
(  230) INTEGER(KIND=JPIM), allocatable :: ikeys(:), ista(:), ichunk(:), irank(:)
(  231) logical LLinit, LLdescending, LLtrans, LLomp_okay, LLadjusted, LLdebug, LLomp_prefix
(  232) character(len=1) clenv
(  233) REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_SUBHANDLE
(  234) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE0
(  235) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE1
(  236) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE2
(  237) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE3
(  238) INTEGER(KIND=JPIM) :: ITID
(  239) # 240 ".D[15]/ecsort_shared.h"
(  240) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_KEYSORT_2D',0,ZHOOK_HANDLE)
(  241) # 242 ".D[15]/ecsort_shared.h"
(  242) rc = 0
(  243) lda = size(a, dim=1)
(  244) sda = size(a, dim=2)
(  245) if (n <= 0 .or. lda <= 0 .or. sda <= 0) goto 99
(  246) # 247 ".D[15]/ecsort_shared.h"
(  247) inumt = OML_MAX_THREADS()
(  248) ITID = OML_MY_THREAD()
(  249) imethod = current_method(ITID)
(  250) if (present(method)) then
(  251)   imethod = min(max(min_method,method),max_method)
(  252) endif
(  253) imethod_1st = imethod
(  254) imethod_rest = imethod
(  255) # 256 ".D[15]/ecsort_shared.h"
(  256) ikey = 1
(  257) if (present(key)) ikey = key
(  258) # 259 ".D[15]/ecsort_shared.h"
(  259) if (present(multikey)) then
(  260)   allocate(ikeys(size(multikey)))
(  261)   ikeys(:) = multikey(:)
(  262) else
(  263)   allocate(ikeys(1))
(  264)   ikeys(1) = ikey
(  265) endif
(  266) inumkeys = size(ikeys)
(  267) # 268 ".D[15]/ecsort_shared.h"
(  268) !-- Only the RADIX-sort & now also QUICK-sort & CountingSort give the result we want with multiple keys
(  269) if (inumkeys > 1 .and. &
(  270)     imethod /= radixsort_method .and. &






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 36

(  271)     imethod /= quicksort_method .and. &
(  272)     imethod /= countingsort_method) then
(  273)    imethod = default_method
(  274)    imethod_1st = imethod
(  275)    imethod_rest = imethod
(  276)    !-- Since "default_method" may now be [overridden as] HEAP-sort, make sure its then "radixsort_method"
(  277)    !   Note: The first sweep may still be e.g. HEAP-sort
(  278)    if (imethod /= radixsort_method .and. &
(  279)        imethod /= quicksort_method .and. &
(  280)        imethod /= countingsort_method) then
(  281)      imethod = radixsort_method
(  282)      imethod_rest = imethod
(  283)    endif
(  284) endif
(  285) # 286 ".D[15]/ecsort_shared.h"
(  286) LLinit = .FALSE.
(  287) if (present(init)) LLinit = init
(  288) # 289 ".D[15]/ecsort_shared.h"
(  289) if (present(index)) then
(  290)   iindex => index(1:n)
(  291) else
(  292)   allocate(iindex(n))
(  293)   LLinit = .TRUE.
(  294) endif
(  295) # 296 ".D[15]/ecsort_shared.h"
(  296) if (LLinit) CALL init_index(iindex)
(  297) # 298 ".D[15]/ecsort_shared.h"
(  298) istride = 1
(  299) LLtrans = .FALSE.
(  300) if (present(transposed)) LLtrans = transposed
(  301) if (LLtrans) then
(  302)   istride = lda
(  303) else if (sda >= 2 .and. lda >= 1) then
(  304) !-- Check for presence of sub-array and adjust lda automatically
(  305)   call addrdiff(a(1,1),a(1,2),idiff)
(  306)   ! lda below: The true leading dimension; overrides sub-arrays one
(  307)   lda = idiff/sizeof_real4
(  308) endif
(  309) # 310 ".D[15]/ecsort_shared.h"
(  310) ilastkey = 0
(  311) LLadjusted = .FALSE.
(  312) LLomp_prefix = .FALSE.
(  313) !$ LLomp_prefix = (istride == 1 .and. nomp >= inumt .and. n >= nomp)
(  314) if (LLomp_prefix) then
(  315)   call get_environment_variable('EC_SORTING_DEBUG',clenv)
(  316)   LLdebug = (clenv == '1' .and. n < 10000)
(  317)   if (LLdebug) write(0,*)'>> EC_SORTING_DEBUG=1'
(  318) else
(  319)   LLdebug = .FALSE.
(  320) endif
(  321) # 322 ".D[15]/ecsort_shared.h"
(  322) 1000 format(1x,a,2i12,:,/,(10i5))
(  323) 1001 format(1x,'[#',i2,']:',a,(10i5))
(  324) 1002 format(1x,'[#',i2,']:',a,:,/,(10i5))
(  325) 1003 format(1x,'[#',i2,']:',a,2i12,:,/,(10i5))
(  326) 1004 format(1x,a,:,(10i5))
(  327) 1005 format(1x,a,i2,1x,a)
(  328) # 329 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 37

(  329) imethod = imethod_1st
(  330) KEYLOOP: do jkey=inumkeys,1,-1
(  331) !--   Sort by the least significant key first
(  332)   ikey = abs(ikeys(jkey))
(  333)   if (ikey == 0) cycle KEYLOOP
(  334) # 335 ".D[15]/ecsort_shared.h"
(  335)   if (istride == 1) then
(  336)     iptr = lda * (ikey - 1) + 1
(  337)   else
(  338)     iptr = ikey
(  339)   endif
(  340) # 341 ".D[15]/ecsort_shared.h"
(  341)   if (LLdebug) then
(  342)     write(0,1000) '<BEGIN>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  343)     if (LLadjusted) then
(  344)       CALL REAL4_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,1)
(  345)     else
(  346)       CALL REAL4_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,0)
(  347)     endif
(  348)     ilastkey = ikey
(  349)   endif
(  350) # 351 ".D[15]/ecsort_shared.h"
(  351)   LLdescending = (ikeys(jkey) < 0)
(  352)   irev = 0
(  353)   if (LLdescending) irev = 1
(  354) # 355 ".D[15]/ecsort_shared.h"
(  355)   !-- Since "irev" is passed into the ecqsort, no explicit reversing is needed --> savings
(  356)   if (imethod == quicksort_method .or. &
(  357)       imethod == countingsort_method) LLdescending = .FALSE.
(  358) # 359 ".D[15]/ecsort_shared.h"
(  359)   if (LLdescending) then
(  360)     if (istride == 1) then
(  361)       a(1:n,ikey) = -a(1:n,ikey)
(  362)     else
(  363)       a(ikey,1:n) = -a(ikey,1:n)
(  364)     endif
(  365)     irev = 0 ! prevents use of "reverse" algorithm in ecmerge2 for radix-sort
(  366)   endif
(  367) # 368 ".D[15]/ecsort_shared.h"
(  368)   LLomp_okay = LLomp_prefix .and. (inumt > 1) .and. (&
(  369)        & imethod == radixsort_method .or. &
(  370)        & imethod == quicksort_method .or. &
(  371)        & imethod == countingsort_method)
(  372)   LLomp_okay = LLomp_okay .and. (.not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  373) # 374 ".D[15]/ecsort_shared.h"
(  374)   if (.not.LLomp_okay) then
(  375)     select case (imethod)
(  376)     case (radixsort_method)
(  377)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_13',0,ZHOOK_SUBHANDLE0)
(  378) # 381 ".D[15]/ecsort_shared.h"
(  381)       CALL rsort32_func(13, n, istride, iptr, a(1,1), iindex(1), 1, rc)
(  382) # 383 ".D[15]/ecsort_shared.h"
(  383)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_13',1,ZHOOK_SUBHANDLE0, n)
(  384)     case (heapsort_method)
(  385)       if (istride == 1) then
(  386)         CALL REAL4_HEAPSORT(13, n, a(1:n, ikey), rc, irev, istride, iindex)
(  387)       else
(  388)         CALL REAL4_HEAPSORT(13, n, a(ikey, 1:n), rc, irev, istride, iindex)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 38

(  389)       endif
(  390)     case (quicksort_method)
(  391)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_ECQSORT',0,ZHOOK_SUBHANDLE0)
(  392)       CALL ecqsort(13, n, istride, iptr, a(1,1), iindex(1), 1, irev, rc)
(  393)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_ECQSORT',1,ZHOOK_SUBHANDLE0,n)
(  394)     case (countingsort_method)
(  395)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_COUNT',0,ZHOOK_SUBHANDLE0)
(  396)       CALL ec_countingsort(13, n, istride, iptr, a(1,1), iindex(1), n, 1, irev, rc)
(  397)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_COUNT',1,ZHOOK_SUBHANDLE0,n)
(  398)     case (gnomesort_method)
(  399)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_GNOME',0,ZHOOK_SUBHANDLE0)
(  400)       CALL ecgnomesort(13, n, istride, iptr, a(1,1), iindex(1), n, 1, rc)
(  401)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_GNOME',1,ZHOOK_SUBHANDLE0,n)
(  402)     end select
(  403) # 404 ".D[15]/ecsort_shared.h"
(  404)   else ! i.e. LLomp_okay ; radix, quick & counting -sorts only
(  405)     if (.not.allocated(ista)) then
(  406)       allocate(ista(inumt+1),ichunk(inumt))
(  407)       inc = n/inumt
(  408)       iadd = 1
(  409)       imod = mod(n,inumt)
(  410)       if (imod == 0) iadd = 0
(  411)       ista(1) = 1
(  412)       do j=2,inumt
(  413)         ista(j) = ista(j-1) + inc + iadd
(  414)         if (iadd > 0 .and. j > imod) iadd = 0
(  415)       enddo
(  416)       ista(inumt+1) = n + 1
(  417)       do j=1,inumt
(  418)         ichunk(j) = ista(j+1) - ista(j)
(  419)       enddo
(  420)       if (LLdebug) then
(  421)         write(0,1005) '>> imethod,name=',imethod,method_name(imethod)
(  422)         write(0,1004) '>> inumt,n,nomp=',inumt,n,nomp
(  423)         write(0,1004) '>> ista(1:inumt+1)=',ista(1:inumt+1)
(  424)         write(0,1004) '>> ichunk(1:inumt)=',ichunk(1:inumt)
(  425)       endif
(  426)       allocate(irank(n))
(  427)     endif
(  428) # 429 ".D[15]/ecsort_shared.h"
(  429)     if (LLdebug) write(0,1004) '>>KEYLOOP: jkey,ikey,irev,iptr=',jkey,ikey,irev,iptr
(  430) # 431 ".D[15]/ecsort_shared.h"
(  431)     if (.not.LLadjusted) then ! only once
(  432)       if (LLdebug) write(0,1000) '<1>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  433)       call adjust_index(iindex, -1) ! Fortran -> C
(  434)       if (LLdebug) write(0,1000) '<2>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  435)       LLadjusted = .TRUE.
(  436)     endif
(  437) # 438 ".D[15]/ecsort_shared.h"
(  438)     if (LLdebug) write(0,*)'>> Sorting inumt-chunks in parallel'
(  439) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iret,inc,ITID,ZHOOK_SUBHANDLE1,ZHOOK_SUBHANDLE2)
(  440)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',0,ZHOOK_SUBHANDLE1)
(  441)     ITID = OML_MY_THREAD()
(  442) !$OMP DO SCHEDULE(DYNAMIC,1)
(  443)     do j=1,inumt
(  444)       j1 = ista(j)
(  445)       inum = ichunk(j)
(  446)       j2 = j1 + inum - 1






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 39

(  447)       inc = j1
(  448)       if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum,inc=',j,j1,j2,inum,inc
(  449)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  450)       select case (imethod)
(  451)       case (radixsort_method)
(  452)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_13',0,ZHOOK_SUBHANDLE2)
(  453) # 456 ".D[15]/ecsort_shared.h"
(  456)         CALL rsort32_func(13, inum, istride, iptr, a(1,1), iindex(j1), 0, iret)
(  457) # 458 ".D[15]/ecsort_shared.h"
(  458)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT32_FUNC_13',1,ZHOOK_SUBHANDLE2, inum)
(  459)       case (quicksort_method)
(  460)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_ECQSORT',0,ZHOOK_SUBHANDLE2)
(  461)         CALL ecqsort(13, inum, istride, iptr, a(1,1), iindex(j1), 0, irev, iret)
(  462)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_ECQSORT',1,ZHOOK_SUBHANDLE2,inum)
(  463)       case (countingsort_method)
(  464)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_COUNT',0,ZHOOK_SUBHANDLE2)
(  465)         CALL ec_countingsort(13, inum, istride, iptr, a(1,1), iindex(j1), inum, 0, irev, iret)
(  466)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_COUNT',1,ZHOOK_SUBHANDLE2,inum)
(  467)       end select
(  468)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  469)     enddo
(  470) !$OMP END DO
(  471)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',1,ZHOOK_SUBHANDLE1)
(  472) !$OMP END PARALLEL
(  473) # 474 ".D[15]/ecsort_shared.h"
(  474)     if (LLdebug) write(0,1000) '<after_sort>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  475)     if (LLdebug) CALL REAL4_DBGPRINT(0,'<after_sort>',a,iindex,n,ikey,1,n,1)
(  476)     CALL get_rank(iindex, irank, index_adj=+1)
(  477) # 478 ".D[15]/ecsort_shared.h"
(  478)     if (LLdebug) write(0,*) '>> Merge neighbouring chunks in parallel as much as possible'
(  479)     inc = 2
(  480)     imax = (inumt+inc-1)/inc
(  481)     do jj=1,imax
(  482)       if (LLdebug) write(0,1001) jj,'<before_merge> jj,inc,imax,inumt=',jj,inc,imax,inumt
(  483) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iamax,ibmax,jmid,iret,ZHOOK_SUBHANDLE3,ITID)
(  484)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',0,ZHOOK_SUBHANDLE3)
(  485)       ITID = OML_MY_THREAD()
(  486) !$OMP DO SCHEDULE(DYNAMIC,1)
(  487)       do j=1,inumt,inc
(  488)         j1 = j
(  489)         j2 = j + inc - 1
(  490)         jmid = (j1 + j2)/2 + 1
(  491)         j2 = min(j2,inumt)
(  492)         jmid = min(jmid,inumt)
(  493)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,jmid=',j,j1,j2,jmid
(  494)         iamax = ista(jmid) - ista(j1)
(  495)         inum = sum(ichunk(j1:j2))
(  496)         ibmax = inum - iamax
(  497)         if (LLdebug) write(0,1001) ITID,'j,iamax,ibmax,inum=',j,iamax,ibmax,inum
(  498)         if (iamax == 0 .or. ibmax == 0 .or. inum == 0) cycle
(  499)         j1 = ista(j1)
(  500)         j2 = ista(j2+1) - 1
(  501)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum=',j,j1,j2,inum
(  502)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  503)         call ecmerge2(13, iptr, iamax, ibmax, a(1,1), &
(  504)              & iindex(j1), inum, 0, irev, irank(1), iret)
(  505)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  506)       enddo ! do j=1,inumt,inc






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 40

(  507) !$OMP END DO
(  508)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',1,ZHOOK_SUBHANDLE3)
(  509) !$OMP END PARALLEL
(  510) # 511 ".D[15]/ecsort_shared.h"
(  511)       if (LLdebug) write(0,1003) jj,'<after_merge>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  512)       if (LLdebug) CALL REAL4_DBGPRINT(jj,'<after_merge>',a,iindex,n,ikey,1,n,1)
(  513) # 514 ".D[15]/ecsort_shared.h"
(  514)       inc = inc * 2
(  515)     enddo ! do jj=1,imax
(  516)     rc = n
(  517)   endif ! if (LLomp_okay)
(  518) # 519 ".D[15]/ecsort_shared.h"
(  519)   if (LLdescending) then
(  520)     if (istride == 1) then
(  521)       a(1:n,ikey) = -a(1:n,ikey)
(  522)     else
(  523)       a(ikey,1:n) = -a(ikey,1:n)
(  524)     endif
(  525)   endif
(  526) # 527 ".D[15]/ecsort_shared.h"
(  527)   if (LLadjusted .and. imethod /= imethod_rest) then ! Restore back immediately
(  528)     if (LLdebug) write(0,1000) '<3a>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  529)     call adjust_index(iindex, +1) ! C -> Fortran
(  530)     if (LLdebug) write(0,1000) '<4a>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  531)     LLadjusted = .FALSE.
(  532)   endif
(  533) # 534 ".D[15]/ecsort_shared.h"
(  534)   imethod = imethod_rest
(  535) enddo KEYLOOP
(  536) # 537 ".D[15]/ecsort_shared.h"
(  537) deallocate(ikeys)
(  538) if (allocated(ista)) deallocate(ista)
(  539) if (allocated(ichunk)) deallocate(ichunk)
(  540) if (allocated(irank)) deallocate(irank)
(  541) # 542 ".D[15]/ecsort_shared.h"
(  542) if (LLadjusted) then ! Restore back
(  543)   if (LLdebug) write(0,1000) '<3b>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  544)   call adjust_index(iindex, +1) ! C -> Fortran
(  545)   if (LLdebug) write(0,1000) '<4b>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  546)   LLadjusted = .FALSE.
(  547) endif
(  548) # 549 ".D[15]/ecsort_shared.h"
(  549) if (LLdebug) write(0,1000) '<END>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  550) if (LLdebug) CALL REAL4_DBGPRINT(0,'<END>',a,iindex,n,ilastkey,1,n,0)
(  551) # 552 ".D[15]/ecsort_shared.h"
(  552) if (.not.present(index)) then
(  553)   LLomp_okay = (nomp >= inumt .and. n >= nomp)
(  554)   if (istride == 1) then
(  555)     LLomp_okay = (LLomp_okay .and. sda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  556) !$OMP PARALLEL PRIVATE(j,data) IF (LLomp_okay)
(  557)     allocate(data(n))
(  558) !$OMP DO SCHEDULE(DYNAMIC,1)
(  559)     do j=1,sda
(  560)       data(1:n) = a(iindex(1:n),j)
(  561)       a(1:n,j) = data(1:n)
(  562)     enddo
(  563) !$OMP END DO
(  564)     deallocate(data)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 41

(  565) !$OMP END PARALLEL
(  566)   else
(  567)     LLomp_okay = (LLomp_okay .and. lda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  568) !$OMP PARALLEL PRIVATE(i,data) IF (LLomp_okay)
(  569)     allocate(data(n))
(  570) !$OMP DO SCHEDULE(DYNAMIC,1)
(  571)     do i=1,lda
(  572)       data(1:n) = a(i,iindex(1:n))
(  573)       a(i,1:n) = data(1:n)
(  574)     enddo
(  575) !$OMP END DO
(  576)     deallocate(data)
(  577) !$OMP END PARALLEL
(  578)   endif
(  579) # 580 ".D[15]/ecsort_shared.h"
(  580)   deallocate(iindex)
(  581) endif
(  582) # 583 ".D[15]/ecsort_shared.h"
(  583) 99 continue
(  584) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_KEYSORT_2D',1,ZHOOK_HANDLE,n*inumkeys)
(  585) END SUBROUTINE
(  586) # 587 ".D[15]/ecsort_shared.h"
(  587) !-----------------------------
(  588) !--   Private subroutines   --
(  589) !-----------------------------
(  590) # 591 ".D[15]/ecsort_shared.h"
(  591) SUBROUTINE REAL4_DBGPRINT(jj, cdstr, a, index, n, key, k1, k2, kadd)
(  592) character(len=*), intent(in) :: cdstr
(  593) INTEGER(KIND=JPIM), intent(in) :: jj, n, key, k1, k2, kadd
(  594) INTEGER(KIND=JPIM), intent(in) :: index(:)
(  595) REAL(KIND=JPRM), intent(in) :: a(:,:)
(  596) INTEGER(KIND=JPIM) :: i,j
(  597) 1000 FORMAT(i3,a,5i5)
(  598) 1011 FORMAT((5i12)) ! integer*4
(  599) 1012 FORMAT(1p,(5g20.12)) ! real*8
(  600) 1013 FORMAT(1p,(5g20.12)) ! real*4
(  601) 1014 FORMAT((5i12)) ! integer*8
(  602) WRITE(0,1000) jj,cdstr//': n,key,k1,k2,kadd,a(index(k1:k2)+kadd,:)=',&
(  603)      &                     n,key,k1,k2,kadd
(  604) do j=k1,k2
(  605)   i = index(j)+kadd
(  606)   WRITE(0,'(2i6)',advance='no') j,i-kadd
(  607)   WRITE(0,1013) a(i,:)
(  608) enddo
(  609) END SUBROUTINE
(  610) # 611 ".D[15]/ecsort_shared.h"
(  611) SUBROUTINE REAL4_HEAPSORT(id, n, a, rc, irev, istride, index)
(  612) INTEGER(KIND=JPIM), intent(in) :: id, n, irev, istride
(  613) REAL(KIND=JPRM), intent(in) :: a(:)
(  614) INTEGER(KIND=JPIM), intent(out) :: rc
(  615) INTEGER(KIND=JPIM), intent(inout) :: index(:)
(  616) INTEGER(KIND=JPIM) :: i,j,right,left,idx
(  617) REAL(KIND=JPRM) :: tmp
(  618) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  619) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_HEAPSORT',0,ZHOOK_HANDLE)
(  620) rc = 0
(  621) if (n <= 0 .or. size(a) <= 0) goto 99
(  622) left  = n/2+1






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 42

(  623) right = n
(  624) LOOP: do
(  625)   if (left > 1) then
(  626)     left = left - 1
(  627)     idx  = index(left)
(  628)   else
(  629)     idx = index(right)
(  630)     index(right) = index(1)
(  631)     right = right - 1
(  632)     if (right == 1) then
(  633)       index(1) = idx
(  634)       exit LOOP
(  635)     endif
(  636)   endif
(  637)   tmp = a(idx)
(  638)   i = left
(  639)   j = 2*left
(  640)   do while (j <= right)
(  641)     if (j < right) then
(  642)       if (a(index(j)) < a(index(j+1))) j = j + 1
(  643)     endif
(  644)     if (tmp < a(index(j))) then
(  645)       index(i) = index(j)
(  646)       i = j
(  647)       j = 2*j
(  648)     else
(  649)       j = right + 1
(  650)     endif
(  651)   enddo
(  652)   index(i) = idx
(  653) enddo LOOP
(  654) rc = n
(  655) 99 continue
(  656) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL4_HEAPSORT',1,ZHOOK_HANDLE)
(  657) END SUBROUTINE
(  658) # 320 "ecsort_mix.F90"
(  320) # 323 "ecsort_mix.F90"
(  323) !-- Create version for REAL(KIND=JPRB)
(  324) # 326 "ecsort_mix.F90"
(  326) # 1 ".D[15]/ecsort_shared.h"
(    1) !*** ecsort_shared.h ***
(    2) # 85 ".D[15]/ecsort_shared.h"
(   85) !----------------------------
(   86) !--   Public subroutines   --
(   87) !----------------------------
(   88) # 90 ".D[15]/ecsort_shared.h"
(   90) SUBROUTINE REAL8_KEYSORT_1D(rc, a, n, method, descending, index, init)
(   91) !-- Please note that we assume that a(:) occupies consecutive memory locations
(   92) INTEGER(KIND=JPIM), intent(out)           :: rc
(   93) REAL(KIND=JPRD)         , intent(inout)         :: a(:)
(   94) INTEGER(KIND=JPIM), intent(in)            :: n
(   95) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: method
(   96) logical, intent(in), OPTIONAL  :: descending
(   97) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(   98) logical, intent(in), OPTIONAL  :: init
(   99) ! === END OF INTERFACE BLOCK ===
(  100) REAL(KIND=JPRD)          , allocatable :: aa(:,:)
(  101) INTEGER(KIND=JPIM) :: imethod, irev, idummy, index_adj






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 43

(  102) logical :: LLfast, LLdescending, LLomp_okay, LLinit
(  103) INTEGER(KIND=JPIM) :: ITID, ichunk, iret, inumt
(  104) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  105) # 106 ".D[15]/ecsort_shared.h"
(  106) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_KEYSORT_1D',0,ZHOOK_HANDLE)
(  107) # 108 ".D[15]/ecsort_shared.h"
(  108) rc = 0
(  109) if (n <= 0 .or. size(a) <= 0) goto 99
(  110) # 111 ".D[15]/ecsort_shared.h"
(  111) if (present(descending)) then
(  112)   LLdescending = descending
(  113) else
(  114)   LLdescending = .FALSE.
(  115) endif
(  116) # 117 ".D[15]/ecsort_shared.h"
(  117) irev = 0
(  118) if (LLdescending) irev = 1
(  119) # 120 ".D[15]/ecsort_shared.h"
(  120) ITID = OML_MY_THREAD()
(  121) imethod = current_method(ITID)
(  122) if (present(method)) then
(  123)   imethod = min(max(min_method,method),max_method)
(  124) endif
(  125) # 126 ".D[15]/ecsort_shared.h"
(  126) if (imethod /= quicksort_method .and. &
(  127)    &imethod /= countingsort_method) then
(  128)   LLfast = .FALSE.
(  129) else if (imethod == quicksort_method) then
(  130)   !-- hasn't been implemented if index is present ;-(
(  131)   LLfast = (&
(  132)        & .not.present(index) .and. &
(  133)        & .not.present(init))
(  134) else if (imethod == countingsort_method) then
(  135)   !-- index-presence is ok
(  136)   LLfast = .TRUE.
(  137) endif
(  138) # 139 ".D[15]/ecsort_shared.h"
(  139) if (LLfast) then
(  140)   !- Only Quick-sort & CountingSort covered
(  141) # 142 ".D[15]/ecsort_shared.h"
(  142)   if (imethod == quicksort_method) then
(  143)     inumt = OML_MAX_THREADS()
(  144)     LLomp_okay = (inumt > 1 .and. nomp >= inumt .and. n >= nomp)
(  145)     LLomp_okay = (LLomp_okay .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  146)     if (LLomp_okay) then
(  147)       !-- Max 2-way OpenMP parallelism for now ...
(  148)       ichunk = n/2
(  149) !$OMP PARALLEL PRIVATE(iret)
(  150) !$OMP SECTIONS
(  151) !$OMP SECTION
(  152)       CALL ecqsortfast(12, ichunk, a(1), irev, iret)
(  153) !$OMP SECTION
(  154)       CALL ecqsortfast(12, n-ichunk, a(ichunk+1), irev, iret)
(  155) !$OMP END SECTIONS
(  156) !$OMP END PARALLEL
(  157)       CALL ecmerge2(12, 1, ichunk, n-ichunk, a(1), &
(  158)            & idummy, 0, 1, irev, idummy, rc)
(  159)     else






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 44

(  160)       CALL ecqsortfast(12, n, a(1), irev, rc)
(  161)     endif
(  162)     GOTO 99
(  163) # 164 ".D[15]/ecsort_shared.h"
(  164)   else if (imethod == countingsort_method) then
(  165)     if (.not.present(index)) then
(  166)       CALL ec_countingsort(12, n, 1, 1, a(1), idummy, 0, 1, irev, rc)
(  167)     else
(  168)       LLinit = .FALSE.
(  169)       if (present(init)) LLinit = init
(  170)       if (LLinit) then
(  171)         CALL init_index(index, index_adj=-1)
(  172)         index_adj = 0
(  173)       else
(  174)         index_adj = 1
(  175)       endif
(  176)       CALL ec_countingsort(12, n, 1, 1, a(1), index(1), size(index), index_adj, irev, rc)
(  177)       if (index_adj == 0) CALL adjust_index(index, +1)
(  178)     endif
(  179)     GOTO 99
(  180) # 181 ".D[15]/ecsort_shared.h"
(  181)   else
(  182)     LLfast = .false.
(  183)   endif
(  184) endif
(  185) # 186 ".D[15]/ecsort_shared.h"
(  186) !-- LLfast == .FALSE. :
(  187) # 188 ".D[15]/ecsort_shared.h"
(  188) allocate(aa(n,1))
(  189) # 190 ".D[15]/ecsort_shared.h"
(  190) if (LLdescending) then
(  191)   aa(1:n,1) = -a(1:n)
(  192) else
(  193)   aa(1:n,1) = a(1:n)
(  194) endif
(  195) # 196 ".D[15]/ecsort_shared.h"
(  196) CALL keysort(rc, aa, n, method=method, index=index, init=init)
(  197) # 198 ".D[15]/ecsort_shared.h"
(  198) if (LLdescending) then
(  199)   a(1:n) = -aa(1:n,1)
(  200) else
(  201)   a(1:n) = aa(1:n,1)
(  202) endif
(  203) # 204 ".D[15]/ecsort_shared.h"
(  204) deallocate(aa)
(  205) # 206 ".D[15]/ecsort_shared.h"
(  206) 99 continue
(  207) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_KEYSORT_1D',1,ZHOOK_HANDLE,n)
(  208) END SUBROUTINE
(  209) # 211 ".D[15]/ecsort_shared.h"
(  211) SUBROUTINE REAL8_KEYSORT_2D(&
(  212)      &rc, a, n,&
(  213)      &key, multikey, method,&
(  214)      &index, init, transposed)
(  215) # 216 ".D[15]/ecsort_shared.h"
(  216) INTEGER(KIND=JPIM), intent(out)           :: rc
(  217) REAL(KIND=JPRD)         , intent(inout)         :: a(:,:)
(  218) INTEGER(KIND=JPIM), intent(in)            :: n






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 45

(  219) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: key, method
(  220) INTEGER(KIND=JPIM), intent(in), OPTIONAL  :: multikey(:)
(  221) logical, intent(in), OPTIONAL  :: transposed
(  222) INTEGER(KIND=JPIM), intent(inout), TARGET, OPTIONAL :: index(:)
(  223) logical, intent(in), OPTIONAL  :: init
(  224) ! === END OF INTERFACE BLOCK ===
(  225) INTEGER(KIND=JPIM), POINTER :: iindex(:)
(  226) INTEGER(KIND=JPIM) :: ikey, istride, imethod, inumkeys, imethod_1st, imethod_rest
(  227) INTEGER(KIND=JPIM) :: lda, iptr, i, j, sda, idiff, irev, inumt, jkey, jj, ilastkey
(  228) INTEGER(KIND=JPIM) :: j1, j2, jmid, inum, imax, iadd, imod, iret, inc, iamax, ibmax
(  229) REAL(KIND=JPRD)         , allocatable :: data(:)
(  230) INTEGER(KIND=JPIM), allocatable :: ikeys(:), ista(:), ichunk(:), irank(:)
(  231) logical LLinit, LLdescending, LLtrans, LLomp_okay, LLadjusted, LLdebug, LLomp_prefix
(  232) character(len=1) clenv
(  233) REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_SUBHANDLE
(  234) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE0
(  235) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE1
(  236) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE2
(  237) REAL(KIND=JPRB) :: ZHOOK_SUBHANDLE3
(  238) INTEGER(KIND=JPIM) :: ITID
(  239) # 240 ".D[15]/ecsort_shared.h"
(  240) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_KEYSORT_2D',0,ZHOOK_HANDLE)
(  241) # 242 ".D[15]/ecsort_shared.h"
(  242) rc = 0
(  243) lda = size(a, dim=1)
(  244) sda = size(a, dim=2)
(  245) if (n <= 0 .or. lda <= 0 .or. sda <= 0) goto 99
(  246) # 247 ".D[15]/ecsort_shared.h"
(  247) inumt = OML_MAX_THREADS()
(  248) ITID = OML_MY_THREAD()
(  249) imethod = current_method(ITID)
(  250) if (present(method)) then
(  251)   imethod = min(max(min_method,method),max_method)
(  252) endif
(  253) imethod_1st = imethod
(  254) imethod_rest = imethod
(  255) # 256 ".D[15]/ecsort_shared.h"
(  256) ikey = 1
(  257) if (present(key)) ikey = key
(  258) # 259 ".D[15]/ecsort_shared.h"
(  259) if (present(multikey)) then
(  260)   allocate(ikeys(size(multikey)))
(  261)   ikeys(:) = multikey(:)
(  262) else
(  263)   allocate(ikeys(1))
(  264)   ikeys(1) = ikey
(  265) endif
(  266) inumkeys = size(ikeys)
(  267) # 268 ".D[15]/ecsort_shared.h"
(  268) !-- Only the RADIX-sort & now also QUICK-sort & CountingSort give the result we want with multiple keys
(  269) if (inumkeys > 1 .and. &
(  270)     imethod /= radixsort_method .and. &
(  271)     imethod /= quicksort_method .and. &
(  272)     imethod /= countingsort_method) then
(  273)    imethod = default_method
(  274)    imethod_1st = imethod
(  275)    imethod_rest = imethod
(  276)    !-- Since "default_method" may now be [overridden as] HEAP-sort, make sure its then "radixsort_method"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 46

(  277)    !   Note: The first sweep may still be e.g. HEAP-sort
(  278)    if (imethod /= radixsort_method .and. &
(  279)        imethod /= quicksort_method .and. &
(  280)        imethod /= countingsort_method) then
(  281)      imethod = radixsort_method
(  282)      imethod_rest = imethod
(  283)    endif
(  284) endif
(  285) # 286 ".D[15]/ecsort_shared.h"
(  286) LLinit = .FALSE.
(  287) if (present(init)) LLinit = init
(  288) # 289 ".D[15]/ecsort_shared.h"
(  289) if (present(index)) then
(  290)   iindex => index(1:n)
(  291) else
(  292)   allocate(iindex(n))
(  293)   LLinit = .TRUE.
(  294) endif
(  295) # 296 ".D[15]/ecsort_shared.h"
(  296) if (LLinit) CALL init_index(iindex)
(  297) # 298 ".D[15]/ecsort_shared.h"
(  298) istride = 1
(  299) LLtrans = .FALSE.
(  300) if (present(transposed)) LLtrans = transposed
(  301) if (LLtrans) then
(  302)   istride = lda
(  303) else if (sda >= 2 .and. lda >= 1) then
(  304) !-- Check for presence of sub-array and adjust lda automatically
(  305)   call addrdiff(a(1,1),a(1,2),idiff)
(  306)   ! lda below: The true leading dimension; overrides sub-arrays one
(  307)   lda = idiff/sizeof_real8
(  308) endif
(  309) # 310 ".D[15]/ecsort_shared.h"
(  310) ilastkey = 0
(  311) LLadjusted = .FALSE.
(  312) LLomp_prefix = .FALSE.
(  313) !$ LLomp_prefix = (istride == 1 .and. nomp >= inumt .and. n >= nomp)
(  314) if (LLomp_prefix) then
(  315)   call get_environment_variable('EC_SORTING_DEBUG',clenv)
(  316)   LLdebug = (clenv == '1' .and. n < 10000)
(  317)   if (LLdebug) write(0,*)'>> EC_SORTING_DEBUG=1'
(  318) else
(  319)   LLdebug = .FALSE.
(  320) endif
(  321) # 322 ".D[15]/ecsort_shared.h"
(  322) 1000 format(1x,a,2i12,:,/,(10i5))
(  323) 1001 format(1x,'[#',i2,']:',a,(10i5))
(  324) 1002 format(1x,'[#',i2,']:',a,:,/,(10i5))
(  325) 1003 format(1x,'[#',i2,']:',a,2i12,:,/,(10i5))
(  326) 1004 format(1x,a,:,(10i5))
(  327) 1005 format(1x,a,i2,1x,a)
(  328) # 329 ".D[15]/ecsort_shared.h"
(  329) imethod = imethod_1st
(  330) KEYLOOP: do jkey=inumkeys,1,-1
(  331) !--   Sort by the least significant key first
(  332)   ikey = abs(ikeys(jkey))
(  333)   if (ikey == 0) cycle KEYLOOP
(  334) # 335 ".D[15]/ecsort_shared.h"






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 47

(  335)   if (istride == 1) then
(  336)     iptr = lda * (ikey - 1) + 1
(  337)   else
(  338)     iptr = ikey
(  339)   endif
(  340) # 341 ".D[15]/ecsort_shared.h"
(  341)   if (LLdebug) then
(  342)     write(0,1000) '<BEGIN>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  343)     if (LLadjusted) then
(  344)       CALL REAL8_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,1)
(  345)     else
(  346)       CALL REAL8_DBGPRINT(-jkey,'<BEGIN>',a,iindex,n,ikey,1,n,0)
(  347)     endif
(  348)     ilastkey = ikey
(  349)   endif
(  350) # 351 ".D[15]/ecsort_shared.h"
(  351)   LLdescending = (ikeys(jkey) < 0)
(  352)   irev = 0
(  353)   if (LLdescending) irev = 1
(  354) # 355 ".D[15]/ecsort_shared.h"
(  355)   !-- Since "irev" is passed into the ecqsort, no explicit reversing is needed --> savings
(  356)   if (imethod == quicksort_method .or. &
(  357)       imethod == countingsort_method) LLdescending = .FALSE.
(  358) # 359 ".D[15]/ecsort_shared.h"
(  359)   if (LLdescending) then
(  360)     if (istride == 1) then
(  361)       a(1:n,ikey) = -a(1:n,ikey)
(  362)     else
(  363)       a(ikey,1:n) = -a(ikey,1:n)
(  364)     endif
(  365)     irev = 0 ! prevents use of "reverse" algorithm in ecmerge2 for radix-sort
(  366)   endif
(  367) # 368 ".D[15]/ecsort_shared.h"
(  368)   LLomp_okay = LLomp_prefix .and. (inumt > 1) .and. (&
(  369)        & imethod == radixsort_method .or. &
(  370)        & imethod == quicksort_method .or. &
(  371)        & imethod == countingsort_method)
(  372)   LLomp_okay = LLomp_okay .and. (.not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  373) # 374 ".D[15]/ecsort_shared.h"
(  374)   if (.not.LLomp_okay) then
(  375)     select case (imethod)
(  376)     case (radixsort_method)
(  377)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_12',0,ZHOOK_SUBHANDLE0)
(  378) # 379 ".D[15]/ecsort_shared.h"
(  379)       CALL rsort64(12, n, istride, iptr, a(1,1), iindex(1), 1, rc)
(  380) # 383 ".D[15]/ecsort_shared.h"
(  383)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_12',1,ZHOOK_SUBHANDLE0, n)
(  384)     case (heapsort_method)
(  385)       if (istride == 1) then
(  386)         CALL REAL8_HEAPSORT(12, n, a(1:n, ikey), rc, irev, istride, iindex)
(  387)       else
(  388)         CALL REAL8_HEAPSORT(12, n, a(ikey, 1:n), rc, irev, istride, iindex)
(  389)       endif
(  390)     case (quicksort_method)
(  391)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_ECQSORT',0,ZHOOK_SUBHANDLE0)
(  392)       CALL ecqsort(12, n, istride, iptr, a(1,1), iindex(1), 1, irev, rc)
(  393)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_ECQSORT',1,ZHOOK_SUBHANDLE0,n)
(  394)     case (countingsort_method)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 48

(  395)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_COUNT',0,ZHOOK_SUBHANDLE0)
(  396)       CALL ec_countingsort(12, n, istride, iptr, a(1,1), iindex(1), n, 1, irev, rc)
(  397)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_COUNT',1,ZHOOK_SUBHANDLE0,n)
(  398)     case (gnomesort_method)
(  399)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_GNOME',0,ZHOOK_SUBHANDLE0)
(  400)       CALL ecgnomesort(12, n, istride, iptr, a(1,1), iindex(1), n, 1, rc)
(  401)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_GNOME',1,ZHOOK_SUBHANDLE0,n)
(  402)     end select
(  403) # 404 ".D[15]/ecsort_shared.h"
(  404)   else ! i.e. LLomp_okay ; radix, quick & counting -sorts only
(  405)     if (.not.allocated(ista)) then
(  406)       allocate(ista(inumt+1),ichunk(inumt))
(  407)       inc = n/inumt
(  408)       iadd = 1
(  409)       imod = mod(n,inumt)
(  410)       if (imod == 0) iadd = 0
(  411)       ista(1) = 1
(  412)       do j=2,inumt
(  413)         ista(j) = ista(j-1) + inc + iadd
(  414)         if (iadd > 0 .and. j > imod) iadd = 0
(  415)       enddo
(  416)       ista(inumt+1) = n + 1
(  417)       do j=1,inumt
(  418)         ichunk(j) = ista(j+1) - ista(j)
(  419)       enddo
(  420)       if (LLdebug) then
(  421)         write(0,1005) '>> imethod,name=',imethod,method_name(imethod)
(  422)         write(0,1004) '>> inumt,n,nomp=',inumt,n,nomp
(  423)         write(0,1004) '>> ista(1:inumt+1)=',ista(1:inumt+1)
(  424)         write(0,1004) '>> ichunk(1:inumt)=',ichunk(1:inumt)
(  425)       endif
(  426)       allocate(irank(n))
(  427)     endif
(  428) # 429 ".D[15]/ecsort_shared.h"
(  429)     if (LLdebug) write(0,1004) '>>KEYLOOP: jkey,ikey,irev,iptr=',jkey,ikey,irev,iptr
(  430) # 431 ".D[15]/ecsort_shared.h"
(  431)     if (.not.LLadjusted) then ! only once
(  432)       if (LLdebug) write(0,1000) '<1>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  433)       call adjust_index(iindex, -1) ! Fortran -> C
(  434)       if (LLdebug) write(0,1000) '<2>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  435)       LLadjusted = .TRUE.
(  436)     endif
(  437) # 438 ".D[15]/ecsort_shared.h"
(  438)     if (LLdebug) write(0,*)'>> Sorting inumt-chunks in parallel'
(  439) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iret,inc,ITID,ZHOOK_SUBHANDLE1,ZHOOK_SUBHANDLE2)
(  440)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',0,ZHOOK_SUBHANDLE1)
(  441)     ITID = OML_MY_THREAD()
(  442) !$OMP DO SCHEDULE(DYNAMIC,1)
(  443)     do j=1,inumt
(  444)       j1 = ista(j)
(  445)       inum = ichunk(j)
(  446)       j2 = j1 + inum - 1
(  447)       inc = j1
(  448)       if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum,inc=',j,j1,j2,inum,inc
(  449)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  450)       select case (imethod)
(  451)       case (radixsort_method)
(  452)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_12',0,ZHOOK_SUBHANDLE2)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 49

(  453) # 454 ".D[15]/ecsort_shared.h"
(  454)         CALL rsort64(12, inum, istride, iptr, a(1,1), iindex(j1), 0, iret)
(  455) # 458 ".D[15]/ecsort_shared.h"
(  458)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:RSORT64_12',1,ZHOOK_SUBHANDLE2, inum)
(  459)       case (quicksort_method)
(  460)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_ECQSORT',0,ZHOOK_SUBHANDLE2)
(  461)         CALL ecqsort(12, inum, istride, iptr, a(1,1), iindex(j1), 0, irev, iret)
(  462)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_ECQSORT',1,ZHOOK_SUBHANDLE2,inum)
(  463)       case (countingsort_method)
(  464)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_COUNT',0,ZHOOK_SUBHANDLE2)
(  465)         CALL ec_countingsort(12, inum, istride, iptr, a(1,1), iindex(j1), inum, 0, irev, iret)
(  466)         IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_COUNT',1,ZHOOK_SUBHANDLE2,inum)
(  467)       end select
(  468)       if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  469)     enddo
(  470) !$OMP END DO
(  471)     IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPSORT',1,ZHOOK_SUBHANDLE1)
(  472) !$OMP END PARALLEL
(  473) # 474 ".D[15]/ecsort_shared.h"
(  474)     if (LLdebug) write(0,1000) '<after_sort>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  475)     if (LLdebug) CALL REAL8_DBGPRINT(0,'<after_sort>',a,iindex,n,ikey,1,n,1)
(  476)     CALL get_rank(iindex, irank, index_adj=+1)
(  477) # 478 ".D[15]/ecsort_shared.h"
(  478)     if (LLdebug) write(0,*) '>> Merge neighbouring chunks in parallel as much as possible'
(  479)     inc = 2
(  480)     imax = (inumt+inc-1)/inc
(  481)     do jj=1,imax
(  482)       if (LLdebug) write(0,1001) jj,'<before_merge> jj,inc,imax,inumt=',jj,inc,imax,inumt
(  483) !$OMP PARALLEL PRIVATE(j,j1,j2,inum,iamax,ibmax,jmid,iret,ZHOOK_SUBHANDLE3,ITID)
(  484)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',0,ZHOOK_SUBHANDLE3)
(  485)       ITID = OML_MY_THREAD()
(  486) !$OMP DO SCHEDULE(DYNAMIC,1)
(  487)       do j=1,inumt,inc
(  488)         j1 = j
(  489)         j2 = j + inc - 1
(  490)         jmid = (j1 + j2)/2 + 1
(  491)         j2 = min(j2,inumt)
(  492)         jmid = min(jmid,inumt)
(  493)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,jmid=',j,j1,j2,jmid
(  494)         iamax = ista(jmid) - ista(j1)
(  495)         inum = sum(ichunk(j1:j2))
(  496)         ibmax = inum - iamax
(  497)         if (LLdebug) write(0,1001) ITID,'j,iamax,ibmax,inum=',j,iamax,ibmax,inum
(  498)         if (iamax == 0 .or. ibmax == 0 .or. inum == 0) cycle
(  499)         j1 = ista(j1)
(  500)         j2 = ista(j2+1) - 1
(  501)         if (LLdebug) write(0,1001) ITID,'j,j1,j2,inum=',j,j1,j2,inum
(  502)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) > ',iindex(j1:j2)
(  503)         call ecmerge2(12, iptr, iamax, ibmax, a(1,1), &
(  504)              & iindex(j1), inum, 0, irev, irank(1), iret)
(  505)         if (LLdebug) write(0,1002) ITID,'iindex(j1:j2) < ',iindex(j1:j2)
(  506)       enddo ! do j=1,inumt,inc
(  507) !$OMP END DO
(  508)       IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:KEYSORT_2D>OMPMERGE',1,ZHOOK_SUBHANDLE3)
(  509) !$OMP END PARALLEL
(  510) # 511 ".D[15]/ecsort_shared.h"
(  511)       if (LLdebug) write(0,1003) jj,'<after_merge>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  512)       if (LLdebug) CALL REAL8_DBGPRINT(jj,'<after_merge>',a,iindex,n,ikey,1,n,1)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 50

(  513) # 514 ".D[15]/ecsort_shared.h"
(  514)       inc = inc * 2
(  515)     enddo ! do jj=1,imax
(  516)     rc = n
(  517)   endif ! if (LLomp_okay)
(  518) # 519 ".D[15]/ecsort_shared.h"
(  519)   if (LLdescending) then
(  520)     if (istride == 1) then
(  521)       a(1:n,ikey) = -a(1:n,ikey)
(  522)     else
(  523)       a(ikey,1:n) = -a(ikey,1:n)
(  524)     endif
(  525)   endif
(  526) # 527 ".D[15]/ecsort_shared.h"
(  527)   if (LLadjusted .and. imethod /= imethod_rest) then ! Restore back immediately
(  528)     if (LLdebug) write(0,1000) '<3a>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  529)     call adjust_index(iindex, +1) ! C -> Fortran
(  530)     if (LLdebug) write(0,1000) '<4a>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  531)     LLadjusted = .FALSE.
(  532)   endif
(  533) # 534 ".D[15]/ecsort_shared.h"
(  534)   imethod = imethod_rest
(  535) enddo KEYLOOP
(  536) # 537 ".D[15]/ecsort_shared.h"
(  537) deallocate(ikeys)
(  538) if (allocated(ista)) deallocate(ista)
(  539) if (allocated(ichunk)) deallocate(ichunk)
(  540) if (allocated(irank)) deallocate(irank)
(  541) # 542 ".D[15]/ecsort_shared.h"
(  542) if (LLadjusted) then ! Restore back
(  543)   if (LLdebug) write(0,1000) '<3b>iindex(1:n)=',n,sum(iindex(1:n))+n,iindex(1:n)
(  544)   call adjust_index(iindex, +1) ! C -> Fortran
(  545)   if (LLdebug) write(0,1000) '<4b>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  546)   LLadjusted = .FALSE.
(  547) endif
(  548) # 549 ".D[15]/ecsort_shared.h"
(  549) if (LLdebug) write(0,1000) '<END>iindex(1:n)=',n,sum(iindex(1:n)),iindex(1:n)
(  550) if (LLdebug) CALL REAL8_DBGPRINT(0,'<END>',a,iindex,n,ilastkey,1,n,0)
(  551) # 552 ".D[15]/ecsort_shared.h"
(  552) if (.not.present(index)) then
(  553)   LLomp_okay = (nomp >= inumt .and. n >= nomp)
(  554)   if (istride == 1) then
(  555)     LLomp_okay = (LLomp_okay .and. sda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  556) !$OMP PARALLEL PRIVATE(j,data) IF (LLomp_okay)
(  557)     allocate(data(n))
(  558) !$OMP DO SCHEDULE(DYNAMIC,1)
(  559)     do j=1,sda
(  560)       data(1:n) = a(iindex(1:n),j)
(  561)       a(1:n,j) = data(1:n)
(  562)     enddo
(  563) !$OMP END DO
(  564)     deallocate(data)
(  565) !$OMP END PARALLEL
(  566)   else
(  567)     LLomp_okay = (LLomp_okay .and. lda >= inumt .and. .not. OML_IN_PARALLEL()) ! Prevents nested OpenMP
(  568) !$OMP PARALLEL PRIVATE(i,data) IF (LLomp_okay)
(  569)     allocate(data(n))
(  570) !$OMP DO SCHEDULE(DYNAMIC,1)






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 51

(  571)     do i=1,lda
(  572)       data(1:n) = a(i,iindex(1:n))
(  573)       a(i,1:n) = data(1:n)
(  574)     enddo
(  575) !$OMP END DO
(  576)     deallocate(data)
(  577) !$OMP END PARALLEL
(  578)   endif
(  579) # 580 ".D[15]/ecsort_shared.h"
(  580)   deallocate(iindex)
(  581) endif
(  582) # 583 ".D[15]/ecsort_shared.h"
(  583) 99 continue
(  584) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_KEYSORT_2D',1,ZHOOK_HANDLE,n*inumkeys)
(  585) END SUBROUTINE
(  586) # 587 ".D[15]/ecsort_shared.h"
(  587) !-----------------------------
(  588) !--   Private subroutines   --
(  589) !-----------------------------
(  590) # 591 ".D[15]/ecsort_shared.h"
(  591) SUBROUTINE REAL8_DBGPRINT(jj, cdstr, a, index, n, key, k1, k2, kadd)
(  592) character(len=*), intent(in) :: cdstr
(  593) INTEGER(KIND=JPIM), intent(in) :: jj, n, key, k1, k2, kadd
(  594) INTEGER(KIND=JPIM), intent(in) :: index(:)
(  595) REAL(KIND=JPRD), intent(in) :: a(:,:)
(  596) INTEGER(KIND=JPIM) :: i,j
(  597) 1000 FORMAT(i3,a,5i5)
(  598) 1011 FORMAT((5i12)) ! integer*4
(  599) 1012 FORMAT(1p,(5g20.12)) ! real*8
(  600) 1013 FORMAT(1p,(5g20.12)) ! real*4
(  601) 1014 FORMAT((5i12)) ! integer*8
(  602) WRITE(0,1000) jj,cdstr//': n,key,k1,k2,kadd,a(index(k1:k2)+kadd,:)=',&
(  603)      &                     n,key,k1,k2,kadd
(  604) do j=k1,k2
(  605)   i = index(j)+kadd
(  606)   WRITE(0,'(2i6)',advance='no') j,i-kadd
(  607)   WRITE(0,1012) a(i,:)
(  608) enddo
(  609) END SUBROUTINE
(  610) # 611 ".D[15]/ecsort_shared.h"
(  611) SUBROUTINE REAL8_HEAPSORT(id, n, a, rc, irev, istride, index)
(  612) INTEGER(KIND=JPIM), intent(in) :: id, n, irev, istride
(  613) REAL(KIND=JPRD), intent(in) :: a(:)
(  614) INTEGER(KIND=JPIM), intent(out) :: rc
(  615) INTEGER(KIND=JPIM), intent(inout) :: index(:)
(  616) INTEGER(KIND=JPIM) :: i,j,right,left,idx
(  617) REAL(KIND=JPRD) :: tmp
(  618) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  619) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_HEAPSORT',0,ZHOOK_HANDLE)
(  620) rc = 0
(  621) if (n <= 0 .or. size(a) <= 0) goto 99
(  622) left  = n/2+1
(  623) right = n
(  624) LOOP: do
(  625)   if (left > 1) then
(  626)     left = left - 1
(  627)     idx  = index(left)
(  628)   else






NVFORTRAN (Version    20.11)          02/16/2022  17:28:39      page 52

(  629)     idx = index(right)
(  630)     index(right) = index(1)
(  631)     right = right - 1
(  632)     if (right == 1) then
(  633)       index(1) = idx
(  634)       exit LOOP
(  635)     endif
(  636)   endif
(  637)   tmp = a(idx)
(  638)   i = left
(  639)   j = 2*left
(  640)   do while (j <= right)
(  641)     if (j < right) then
(  642)       if (a(index(j)) < a(index(j+1))) j = j + 1
(  643)     endif
(  644)     if (tmp < a(index(j))) then
(  645)       index(i) = index(j)
(  646)       i = j
(  647)       j = 2*j
(  648)     else
(  649)       j = right + 1
(  650)     endif
(  651)   enddo
(  652)   index(i) = idx
(  653) enddo LOOP
(  654) rc = n
(  655) 99 continue
(  656) IF (LHOOK) CALL DR_HOOK('ECSORT_MIX:REAL8_HEAPSORT',1,ZHOOK_HANDLE)
(  657) END SUBROUTINE
(  658) # 327 "ecsort_mix.F90"
(  327) # 330 "ecsort_mix.F90"
(  330) END MODULE ECSORT_MIX
